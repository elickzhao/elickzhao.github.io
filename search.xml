<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Linux下怎样搜索文件]]></title>
      <url>http://elickzhao.github.io/2016/04/Linux%E4%B8%8B%E6%80%8E%E6%A0%B7%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>使用linux系统难免会忘记文件所在的位置，可以使用以下命令对系统中的文件进行搜索。搜索文件的命令为”find“；”locate“；”whereis“；”which“；”type“</p>
</blockquote>
<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>linux下最强大的搜索命令为”find“。<br>它的格式为 <code>find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</code>；<br>比如使用find命令搜索在根目录下的所有interfaces文件所在位置，<br>命令格式为 <code>find / -name  &#39;interfaces&#39;</code></p>
<p>查找当前目录下以@开头的文件或者目录，搜索深度为一级也就是只在当前目录找，不进入子目录<br><code>find . -maxdepth 1 -name &quot;@*&quot;</code></p>
<a id="more"></a>
<h1 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h1><p>使用locate搜索linux系统中的文件，它比find命令快。<br>因为它查询的是数据库(/var/lib/locatedb)，数据库包含本地所有的文件信息。<br>使用locate命令在根目录下搜索interfaces文件的命令为 <code>locate interfaces</code></p>
<h1 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h1><p>使用”whereis“命令可以搜索linux系统中的所有可执行文件即二进制文件。<br>使用whereis命令搜索grep二进制文件的命令为 <code>whereis grep</code>。</p>
<h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p>使用which命令查看系统命令是否存在，并返回系统命令所在的位置。<br>使用which命令查看grep命令是否存在以及存在的目录的命令为 <code>which grep</code>。</p>
<h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><p>使用type命令查看系统中的某个命令是否为系统自带的命令。<br>使用type命令查看cd命令是否为系统自带的命令；查看grep 是否为系统自带的命令。<br><code>type cd</code> <code>type grep</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP 获取服务器详细信息代码]]></title>
      <url>http://elickzhao.github.io/2016/04/PHP%20%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<blockquote>
<p>说明一下为什么写这个.因为docker的link时需要取得环境变量里面的mysql容器的IP地址,所以想用php取得容器的环境变量.原本想用 <code>$_ENV[]</code> 发现没有内容 原来需要修改 <strong>php.ini</strong> 里面 <code>variables_order = &quot;EGPCS&quot;</code><br>上述配置表示PHP 接受的外部变量来源及顺序，EGPCS 是Environment、Get、Post、Cookies 和Server 的缩写。如果variables_order 的配置中缺少E ，则PHP 无法接受环境变量，那么<code>$_ENV</code> 也就为空了。 后来想到用 php 执行 shell 命令 使用exec , system , shell_exec  但还是获取不到 好赖用 system(env) 才发现原来是我登录的用户为 www-data 所以根本获取不到额外的环境变量 所以这个想法只能作罢, 至于下面 是顺手总结的 一些全局变量的用法</p>
</blockquote>
<a id="more"></a>
<table>
<thead>
<tr>
<th>功能</th>
<th style="text-align:center">代码</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取系统类型及版本号：</td>
<td style="text-align:center"><code>php_uname()</code></td>
<td style="text-align:center">(例：Windows NT COMPUTER 5.1 build 2600)</td>
</tr>
<tr>
<td>只获取系统类型：</td>
<td style="text-align:center"><code>php_uname(&#39;s&#39;)</code></td>
<td style="text-align:center">(或：PHP_OS，例：Windows NT)</td>
</tr>
<tr>
<td>只获取系统版本号：</td>
<td style="text-align:center"><code>php_uname(&#39;r&#39;)</code></td>
<td style="text-align:center">无   </td>
</tr>
<tr>
<td>获取PHP运行方式：</td>
<td style="text-align:center"><code>php_sapi_name()</code></td>
<td style="text-align:center">(PHP run mode：apache2handler)</td>
</tr>
<tr>
<td>获取前进程用户名：</td>
<td style="text-align:center"><code>Get_Current_User()</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取PHP版本：</td>
<td style="text-align:center"><code>PHP_VERSION</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取Zend版本：</td>
<td style="text-align:center"><code>Zend_Version()</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取PHP安装路径：</td>
<td style="text-align:center"><code>DEFAULT_INCLUDE_PATH</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取当前文件绝对路径：</td>
<td style="text-align:center"><strong>FILE</strong></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取客户端IP：</td>
<td style="text-align:center"><code>$_SERVER[&#39;REMOTE_ADDR&#39;]</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取服务器解译引擎：</td>
<td style="text-align:center"><code>$_SERVER[&#39;SERVER_SOFTWARE&#39;]</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取服务器CPU数量：</td>
<td style="text-align:center"><code>$_SERVER[&#39;PROCESSOR_IDENTIFIER&#39;]</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取服务器系统目录：</td>
<td style="text-align:center"><code>$_SERVER[&#39;SystemRoot&#39;]</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取服务器域名：</td>
<td style="text-align:center">`$_SERVER[‘SERVER_NAME’]</td>
<td style="text-align:center">(建议使用：$_SERVER[“HTTP_HOST”])`</td>
</tr>
<tr>
<td>获取用户域名：</td>
<td style="text-align:center"><code>$_SERVER[&#39;USERDOMAIN&#39;]</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取服务器语言：</td>
<td style="text-align:center"><code>$_SERVER[&#39;HTTP_ACCEPT_LANGUAGE&#39;]</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取服务器Web端口：</td>
<td style="text-align:center"><code>$_SERVER[&#39;SERVER_PORT&#39;]</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>获取服务器IP：</td>
<td style="text-align:center"><code>GetHostByName($_SERVER[&#39;SERVER_NAME&#39;])</code></td>
<td style="text-align:center">推荐</td>
</tr>
<tr>
<td>获取Http请求中Host值：</td>
<td style="text-align:center"><code>$_SERVER[&quot;HTTP_HOST&quot;]</code></td>
<td style="text-align:center">返回值为域名或IP</td>
</tr>
<tr>
<td>接受请求的服务器IP：</td>
<td style="text-align:center"><code>$_SERVER[&quot;SERVER_ADDR&quot;]</code></td>
<td style="text-align:center">(有时候获取不到，)</td>
</tr>
</tbody>
</table>
<p>在PHP网站开发中，为了满足网站的需要，时常需要对PHP环境变量进行设置和应用，在虚拟主机环境下，有时我们更需要通过PHP环境变量操作函 数来对PHP环境变量值进行设置。为此我们有必要对PHP环境变量先有所熟悉。今天和大家分享PHP环境变量$_SERVER和PHP系统常量的部分详细 说明。</p>
<p>PHP提供了很多默认的系统变量，用于获得系统配置信息、网络请求相关信息等。这些默认的系统变量及其作用如表2-1所示。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$GLOBALS[]</code></td>
<td style="text-align:center">储存当前脚本中的所有全局变量，其KEY为变量名，VALUE为变量值</td>
</tr>
<tr>
<td><code>$_SERVER[]</code></td>
<td style="text-align:center">当前WEB服务器变量数组</td>
</tr>
<tr>
<td><code>$_GET[]</code></td>
<td style="text-align:center">存储以GET方法提交表单中的数据</td>
</tr>
<tr>
<td><code>$_POST[]</code></td>
<td style="text-align:center">存储以POST方法提交表单中的数据</td>
</tr>
<tr>
<td><code>$_COOKIE[]</code></td>
<td style="text-align:center">取得或设置用户浏览器Cookies中存储的变量数组</td>
</tr>
<tr>
<td><code>$_FILES[]</code></td>
<td style="text-align:center">存储上传文件提交到当前脚本的数据</td>
</tr>
<tr>
<td><code>$_ENV[]</code></td>
<td style="text-align:center">存储当前WEB环境变量</td>
</tr>
<tr>
<td><code>$_REQUEST[]</code></td>
<td style="text-align:center">存储提交表单中所有请求数组，其中包括<code>$_GET、$_POST、$_COOKIE和$_SESSION</code>中的所有内容</td>
</tr>
<tr>
<td><code>$_SESSION[]</code></td>
<td style="text-align:center">存储当前脚本的会话变量数组</td>
</tr>
</tbody>
</table>
<p>配置文件的不同，在不同环境下显示的内容可能会有所不同。</p>
<p>与系统变量一样，PHP也提供了一些默认的系统常量供使用。在程序中可以随时应用这些系统常量，但是我们不能任意更改这些常量的值。PHP中常用的一些默认系统常量及其作用如表2-2所示。</p>
<table>
<thead>
<tr>
<th>常量</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FILE</strong></td>
<td style="text-align:center">存储当前脚本的绝对路径及文件名称</td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td style="text-align:center">存储该常量所在的行号</td>
</tr>
<tr>
<td><strong>FUNCTION</strong></td>
<td style="text-align:center">存储该常量所在的函数名称</td>
</tr>
<tr>
<td><strong>CLASS</strong></td>
<td style="text-align:center">存储该常量所在的类的名称</td>
</tr>
<tr>
<td>PHP_VERSION</td>
<td style="text-align:center">存储当前PHP的版本号</td>
</tr>
<tr>
<td>PHP_OS</td>
<td style="text-align:center">存储当前服务器的操作系统</td>
</tr>
</tbody>
</table>
<p> <code>$_GET</code> 和<code>$_POST</code>主要针对FORM表单提交的数据，<br> <code>$_COOKIE</code>和<code>$_SESSION</code>主要针对客户端游览器和服务器端会话数据。<br> <code>$_FILES</code>主要针对文件上传时提交的数据，<br> <code>$_REQUEST</code>主要针对提交表单中所有请求数组，包括<code>$_GET、$_POST</code>、<br> <code>$_COOKIE</code>中的所有内容，你可以通过<code>print_r</code>函数分别输出<code>$_REQUEST</code>或者<code>$_COOKIE</code>等进行比较。</p>
<p>PHP环境变量$_SERVER简介</p>
<p>　　是一个包含服务器端相关信息的PHP全局环境变量，在PHP4.1.0之前的版本使用$HTTP_SERVER_VARS。</p>
<p>　　<code>$_SERVER[&#39;PHP_SELF&#39;]</code> 当前正在执行脚本的文件名，与 document root相关。在FORM表单中，如执行文件是本身，你可以在ACTION中使用<code>$_SERVER[&#39;PHP_SELF&#39;]</code>，好处是当执行文件名有变动时可以不去频繁替换ACTION中的文件名。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$_SERVER[&#39;SERVER_NAME&#39;]</code></td>
<td style="text-align:center">当前运行的PHP程序所在服务器主机的名称。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;REQUEST_METHOD&#39;]</code></td>
<td style="text-align:center">访问页面时的请求方法，即GET、HEAD、POST、PUT。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;DOCUMENT_ROOT&#39;]</code></td>
<td style="text-align:center">当前运行的PHP程序所在的文档根目录。也就是PHP.INI文件中的定义。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;HTTP_REFERER&#39;]</code></td>
<td style="text-align:center">链接到当前页面的前一页面的URL地址。在页面跳转功能中非常有用。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;REMOTE_ADDR&#39;]</code></td>
<td style="text-align:center">正在浏览当前页面访问者的IP地址。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;REMOTE_HOST&#39;]</code></td>
<td style="text-align:center">正在浏览当前页面用户的主机名。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;REMOTE_PORT&#39;]</code></td>
<td style="text-align:center">正在游览的用户连接到服务器时所使用的端口。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;SCRIPT_FILENAME&#39;]</code></td>
<td style="text-align:center">当前执行脚本的绝对路径名。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;SERVER_PORT&#39;]</code></td>
<td style="text-align:center">服务器所使用的端口</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;SCRIPT_NAME&#39;]</code></td>
<td style="text-align:center">包含当前脚本的路径。这在页面需要指向自己时非常有用。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;REQUEST_URI&#39;]</code></td>
<td style="text-align:center">访问此页面所需的URI。如“/index.html”。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;PHP_AUTH_USER&#39;]</code></td>
<td style="text-align:center">应用在HTTP用户登录认证功能中，这个变量是用户输入的用户名。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;PHP_AUTH_PW&#39;]</code></td>
<td style="text-align:center">应用在HTTP用户登录认证功能中，这个变量便是用户输入的密码。</td>
</tr>
<tr>
<td><code>$_SERVER[&#39;AUTH_TYPE&#39;]</code></td>
<td style="text-align:center">应用在HTTP用户登录认证功能中，这个变量便是认证的类型。</td>
</tr>
</tbody>
</table>
<p>　　注：上述提到的这些PHP全局环境变量，在php.ini中的register_globals设置为on时，这些变量在所有PHP程序脚本中都可用，也就是$_SERVER数组被分离了。当然为了安全考虑，还是不要将register_globals打开为好。</p>
<p>　　PHP环境变量$_SERVER的更多信息请参考PHP帮助手册，文章开头提到在虚拟主机环境下我们需要通过PHP环境变量操作函数来对PHP环境变量值进行设置，主要用到ini_set和ini_get，其实还有更多此类函数，比如PHP中的错误报告设置等，其实都涉及到PHP.INI中的相关内容，有机会下次分享。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[脚本报错没有那个文件或目录]]></title>
      <url>http://elickzhao.github.io/2016/04/%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>shell脚本报错：#!binbash 没有那个文件或目录</p>
<p>在Windows下编辑的，文件每行末尾会多出^M，所以先转格式： linux下有个 dos2unix 脚本文件 可以转换</p>
<p>windows下可以使用 Notepad++ 编辑文件 或者 使用 菜单-&gt;编辑-&gt;文档格式转换  来转换文件格式</p>
<p><img src="/image/16-4/5.png" alt="转换格式"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[总结 Dockerfile 一些命令说明]]></title>
      <url>http://elickzhao.github.io/2016/04/%E6%80%BB%E7%BB%93%20Dockerfile%20%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Dockerfile是一个镜像的表示，可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器<br>所有的 Dockerfile 命令格式都是:<br>INSTRUCTION arguments<br>虽然指令忽略大小写，但是建议使用大写。</p>
</blockquote>
<h1 id="FROM-命令"><a href="#FROM-命令" class="headerlink" title="FROM 命令"></a>FROM 命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个设置基本的镜像，为后续的命令使用，所以应该作为Dockerfile的第一条指令。</p>
<p>比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br></pre></td></tr></table></figure></p>
<p>如果没有指定 tag ，则默认tag是latest，如果都没有则会报错。</p>
<h1 id="CMD-命令"><a href="#CMD-命令" class="headerlink" title="CMD 命令"></a>CMD 命令</h1><p>有三种格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (like an exec, preferred form)</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)</span><br><span class="line">CMD command param1 param2 (as a shell)</span><br></pre></td></tr></table></figure></p>
<p>一个Dockerfile里只能有一个CMD，如果有多个，只有最后一个生效。这是为了引用镜像时避免启动服务器而无法配置 所以你可以在最后再写个CMD从而屏蔽原镜像的命令</p>
<a id="more"></a>
<h1 id="RUN-命令"><a href="#RUN-命令" class="headerlink" title="RUN 命令"></a>RUN 命令</h1><p>RUN命令会在上面FROM指定的镜像里执行任何命令，然后提交(commit)结果，提交的镜像会在后面继续用到。</p>
<p>两种格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt; (the command is run in a shell - `/bin/sh -c`)</span><br></pre></td></tr></table></figure></p>
<p>或:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ... ]  (exec form)</span><br><span class="line">#RUN命令等价于:</span><br><span class="line"></span><br><span class="line">docker run image command</span><br><span class="line">docker commit container_id</span><br></pre></td></tr></table></figure></p>
<p>#ENTRYPOINT 命令</p>
<p>有两种语法格式，一种就是上面的(shell方式):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT cmd param1 param2 ...</span><br></pre></td></tr></table></figure></p>
<p>第二种是 exec 格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;cmd&quot;, &quot;param1&quot;, &quot;param2&quot;...]</span><br></pre></td></tr></table></figure></p>
<p>如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;echo&quot;, &quot;Whale you be my container&quot;]</span><br></pre></td></tr></table></figure></p>
<p>ENTRYPOINT 命令设置在容器启动时执行命令 这样 –link 的其他容器环境变量用这个命令将会取得</p>
<blockquote>
<p>这个可能是 和 RUN最大区别 RUN是生成容器时执行一次,还有个区别就是 ENTRYPOINT 和 CMD 一样只执行最后一个  RUN是可以执行多次的<br><del>有一次使用sed命令时 RUN可以用 ENTRYPOINT 虽然能生成容器但是却启动不起来 那次用的Docker-composer 所以也不知道和那个是否有关</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@tankywoo-docker:~# cat Dockerfile</span><br><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT echo &quot;Welcome!&quot;</span><br><span class="line"></span><br><span class="line">root@tankywoo-docker:~# docker run 62fda5e450d5</span><br><span class="line">Welcome!</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>启动几次执行几次 最上面 Step 7 哪行命令<br><img src="/image/16-4/6.png" alt="启动执行ENTRYPOINT"></p>
<blockquote>
<p><strong>简要说明:</strong><br>RUN是在building image时会运行的指令, 在Dockerfile中可以写多条RUN指令.<br>CMD和ENTRYPOINT则是在运行container 时会运行的指令, 都只能写一条, 如果写了多条, 则最后一条生效.<br>CMD和ENTRYPOINT的区别是:<br>CMD在运行时会被command覆盖, ENTRYPOINT不会被运行时的command覆盖, 但是也可以指定.</p>
</blockquote>
<h1 id="ADD-命令"><a href="#ADD-命令" class="headerlink" title="ADD 命令"></a>ADD 命令</h1><p>从src复制文件到container的dest路径:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;src&gt;</code> 是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url<br><code>&lt;dest&gt;</code> 是container中的绝对路径</p>
<h1 id="VOLUME-命令"><a href="#VOLUME-命令" class="headerlink" title="VOLUME 命令"></a>VOLUME 命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;&lt;mountpoint&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p>如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure></p>
<p>创建一个挂载点用于共享目录</p>
<p>#USER 命令</p>
<p>比如指定 memcached 的运行用户，可以使用上面的 ENTRYPOINT 来实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;memcached&quot;, &quot;-u&quot;, &quot;daemon&quot;]</span><br></pre></td></tr></table></figure></p>
<p>更好的方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;memcached&quot;]</span><br><span class="line">USER daemon</span><br></pre></td></tr></table></figure></p>
<p>#MAINTAINER 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>MAINTAINER命令用来指定维护者的姓名和联系方式</p>
<h1 id="EXPOSE-命令"><a href="#EXPOSE-命令" class="headerlink" title="EXPOSE 命令"></a>EXPOSE 命令</h1><p>EXPOSE 命令可以设置一个端口在运行的镜像中暴露在外<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure></p>
<p>比如Nginx使用端口 80，可以把这个端口暴露在外，这样容器外可以看到这个端口并与其通信。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure></p>
<p>详细内容可以看这篇文章 -&gt; <a href="http://www.open-open.com/lib/view/open1435126385232.html" target="_blank" rel="external">Docker网络原则入门：EXPOSE，-p，-P，-link</a></p>
<h1 id="WORKDIR-命令"><a href="#WORKDIR-命令" class="headerlink" title="WORKDIR 命令"></a>WORKDIR 命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /opt/bin</span><br></pre></td></tr></table></figure>
<p>配置RUN, CMD, ENTRYPOINT 命令设置当前工作路径</p>
<p>可以设置多次，如果是相对路径，则相对前一个 WORKDIR 命令</p>
<p>比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /opt/bin</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure></p>
<p>其实是在 /opt/bin 下执行 pwd</p>
<h1 id="ENV-命令"><a href="#ENV-命令" class="headerlink" title="ENV 命令"></a>ENV 命令</h1><p>用于设置环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure></p>
<p>设置了后，后续的RUN命令都可以使用</p>
<p>使用此dockerfile生成的image新建container，可以通过 docker inspect 看到这个环境变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@tankywoo-docker:~# docker inspect 49bfc7a9817f</span><br><span class="line">    ...</span><br><span class="line">    &quot;Env&quot;: [</span><br><span class="line">        &quot;name=tanky&quot;,</span><br><span class="line">        &quot;HOME=/&quot;,</span><br><span class="line">        &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">```    </span><br><span class="line">里面的name=tanky就是设置的。</span><br><span class="line"></span><br><span class="line">也可以通过在docker run时设置或修改环境变量:</span><br></pre></td></tr></table></figure></p>
<p>docker run -i -t –env name=”tanky” ubuntu:newtest /bin/bash<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux sed 批量替换字符串]]></title>
      <url>http://elickzhao.github.io/2016/04/linux%20sed%20%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>Linux下批量替换多个文件中的字符串的简单方法。用sed命令可以批量替换多个文件中的字符串。<br>命令如下：sed -i “s/原字符串/新字符串/g” <code>grep 原字符串 -rl 所在目录</code><br>例如：我要把 charset=gb2312 替换为 charset=UTF-8，执行命令：sed -i “s/charset=gb2312/charset=UTF-8/g” ‘grep charset=gb2312 -rl /www’ 即可。</p>
<p>解释一下：<br>    -i 表示inplace edit，就地修改文件<br>    -r 表示搜索子目录<br>    -l 表示输出匹配的文件名<br>    这个命令组合很强大，要注意备份文件。<br><a id="more"></a></p>
<p>#关于 sed 的更多说明：<br><strong>sed ‘y/1234567890/ABCDEFGHIJ/’ test_sed</strong><br>    test_sed的内容是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1234567890</span><br><span class="line">2345678901</span><br><span class="line">3456789012</span><br><span class="line"> 4567890123</span><br></pre></td></tr></table></figure></p>
<p>执行后，test_sed的内容是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJ</span><br><span class="line">BCDEFGHIJA</span><br><span class="line">CDEFGHIJAB</span><br><span class="line">DEFGHIJABC</span><br></pre></td></tr></table></figure></p>
<p>注意变换关系是按两个list的位置对应变换</p>
<p>替换每行所有匹配 <strong>sed ‘s/01/Ab/g’ test_sed</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1234567890</span><br><span class="line">23456789Ab</span><br><span class="line">3456789Ab2</span><br><span class="line">456789Ab23</span><br></pre></td></tr></table></figure></p>
<p>注意：第一行的0，1没有分别替换为A,b<br>删除：d命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sed ‘2d’ example—–删除example文件的第二行。</span><br><span class="line">$ sed ‘2,$d’ example—–删除example文件的第二行到末尾所有行。</span><br><span class="line">$ sed ‘$d’ example—–删除example文件的最后一行。</span><br><span class="line">$ sed ‘/test/’d example—–删除example文件所有包含test的行。</span><br></pre></td></tr></table></figure></p>
<p>替换：s命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sed ‘s/test/mytest/g’ example—–在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。</span><br><span class="line">$ sed -n ‘s/^test/mytest/p’ example—–(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。</span><br><span class="line">$ sed ‘s/^192.168.0.1/&amp;localhost/’example—–&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加localhost，变成192.168.0.1localhost。</span><br><span class="line">$ sed -n ‘s/\(love\)able/\1rs/p’ example—–love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。</span><br><span class="line">$ sed ‘s#10#100#g’ example—–不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。</span><br><span class="line">选定行的范围：逗号</span><br><span class="line">$ sed -n ‘/test/,/check/p’ example—–所有在模板test和check所确定的范围内的行都被打印。</span><br><span class="line">$ sed -n ‘5,/^test/p’ example—–打印从第五行开始到第一个包含以test开始的行之间的所有行。</span><br><span class="line">$ sed ‘/test/,/check/s/$/sed test/’ example—–对于模板test和west之间的行，每行的末尾用字符串sed test替换。</span><br></pre></td></tr></table></figure></p>
<p>多点编辑：e命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e ‘1,5d’ -e ‘s/test/check/’example—–(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</span><br><span class="line">$ sed –expression=’s/test/check/’ –expression=’/love/d’ example—–一个比-e更好的命令是–expression。它能给sed表达式赋值。</span><br></pre></td></tr></table></figure></p>
<p>从文件读入：r命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed ‘/test/r file’ example—–file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。</span><br><span class="line">写入文件：w命令</span><br><span class="line">$ sed -n ‘/test/w file’ example—–在example中所有包含test的行都被写入file里。</span><br></pre></td></tr></table></figure></p>
<p>追加命令：a命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed ‘/^test/a\\—&gt;this is a example’ example&lt;—–‘this is a example’被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。</span><br></pre></td></tr></table></figure></p>
<p>插入：i命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sed ‘/test/i\\</span><br><span class="line">new line</span><br><span class="line">————————-‘ example</span><br><span class="line">如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。</span><br></pre></td></tr></table></figure></p>
<p>下一个：n命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed ‘/test/&#123; n; s/aa/bb/; &#125;’ example—–如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。</span><br></pre></td></tr></table></figure></p>
<p>变形：y命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed ‘1,10y/abcde/ABCDE/’ example—–把1–10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。</span><br></pre></td></tr></table></figure></p>
<p>退出：q命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed ’10q’ example—–打印完第10行后，退出sed。</span><br></pre></td></tr></table></figure></p>
<p>保持和获取：h命令和G命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -e ‘/test/h’ -e ‘$Gexample—–在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。</span><br><span class="line">保持和互换：h命令和x命令</span><br><span class="line">$ sed -e ‘/test/h’ -e ‘/check/x’ example —–互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.frostsky.com/2014/01/linux-sed-command/" target="_blank" rel="external">原文地址: http://www.frostsky.com/2014/01/linux-sed-command/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu 国内源列表]]></title>
      <url>http://elickzhao.github.io/2016/04/ubuntu%20%E5%9B%BD%E5%86%85%E6%BA%90%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>详细地址都在下面连接 ubuntu国内官网<br><a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="external">源列表</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用docker搭建laravel环境 (Docker for the Laravel framework)]]></title>
      <url>http://elickzhao.github.io/2016/04/%E7%94%A8docker%E6%90%AD%E5%BB%BAlaravel%E7%8E%AF%E5%A2%83%20(Docker%20for%20the%20Laravel%20framework)/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>最近一直想搭建个自己的docker开发环境,找了不少资料.在docker-hub上发现这个,虽然内容老一点,不过思路还是很好的.而且发现用docker搭建原来是如此的so easy! 好吧,让我们开始吧.</p>
</blockquote>
<h1 id="首先来看看布局结构"><a href="#首先来看看布局结构" class="headerlink" title="首先来看看布局结构"></a>首先来看看布局结构</h1><p><img src="/image/16-4/4.png" alt="布局图"></p>
<p>简单说明下.每一个服务用了一个容器.所有容器的数据都指向数据容器.这样统一管理的同时,也方便修改和报错.这里原作者把artisan和composer也放在一个容器里,但是我个人感觉这样不是太好.当然为了保持宿主主机的纯净度来讲,这是个正确的选择,就是操作起来太费事了.</p>
<a id="more"></a>
<h1 id="下载所有镜像"><a href="#下载所有镜像" class="headerlink" title="下载所有镜像"></a>下载所有镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull dylanlindgren/docker-laravel-data &amp;&amp; \</span><br><span class="line">  docker pull dylanlindgren/docker-laravel-composer &amp;&amp; \</span><br><span class="line">  docker pull dylanlindgren/docker-laravel-artisan &amp;&amp; \</span><br><span class="line">  docker pull dylanlindgren/docker-laravel-phpfpm &amp;&amp; \</span><br><span class="line">  docker pull dylanlindgren/docker-laravel-nginx</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/dylanlindgren/docker-laravel-nginx" target="_blank" rel="external">Nginx这个镜像的Github地址</a>,其他的我就不放了,因为这个仓库的首页上都有.所以如果你想去详细了解文件内容可以去看看.</p>
<h1 id="下载虚拟机并建立共享目录"><a href="#下载虚拟机并建立共享目录" class="headerlink" title="下载虚拟机并建立共享目录"></a>下载虚拟机并建立共享目录</h1><blockquote>
<p>要说明一点我用的是windows,所以下面的操作讲的都是windows下的操作经过.OS X 大致类似,linux是最简单的完全不需要虚拟机的,只要建立共享目录就可以了.</p>
</blockquote>
<ul>
<li>下载docker toolbox并安装 (原文是boot2docker 但是貌似不更新了 而且用不了docker composer 所以用新的吧)</li>
<li>建立共享目录并与虚拟机设置共享</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先进入 virtualbox的目录 使用命令创建共享目录</span></span><br><span class="line">VBoxManage sharedfolder add boot2docker-vm --name myapp --hostpath C:\Users\dylan\myapp</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建转发端口</span></span><br><span class="line">VBoxManage modifyvm boot2docker-vm --natpf1 <span class="string">"web,tcp,,80,,80"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当然你还可以直接在virtualbox设置里直接设置这些不用命令</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#进入linux挂载刚才的共享目录</span><br><span class="line">$ boot2docker ssh &apos;sudo mkdir /data&apos;</span><br><span class="line">$ boot2docker ssh &apos;sudo mount -t vboxsf -o &quot;defaults,uid=33,gid=33,rw&quot; myapp /data&apos;</span><br><span class="line"></span><br><span class="line">#共享目录我个人感觉没用,因为每次都得进入linux挂载一次可用,而且只用启动容器时 使用 -v 直接挂载目录就可以了 也不需要这个.当然你可以按着步骤一步一步做 这样肯定能成功!</span><br></pre></td></tr></table></figure>
<h1 id="万事俱备-启动容器"><a href="#万事俱备-启动容器" class="headerlink" title="万事俱备 启动容器"></a>万事俱备 启动容器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动数据容器 原本好像有点问题 必须这么写要不启动不起来 至于原因嘛 可能跟 bash有关 比较懒没仔细查</span></span><br><span class="line">`docker run --name myapp-data -v /Users/dylan/myapp:/data:rw -id dylanlindgren/docker-laravel-data /bin/bash ` </span><br><span class="line"></span><br><span class="line"><span class="comment">#启动php容器 --privileged=true 这个必须要不无法创建目录</span></span><br><span class="line">docker run --privileged=<span class="literal">true</span> --name myapp-php --volumes-from myapp-data <span class="_">-d</span> dylanlindgren/docker-laravel-phpfpm </span><br><span class="line"></span><br><span class="line"><span class="comment">#启动Nginx</span></span><br><span class="line">docker run --privileged=<span class="literal">true</span> --name myapp-web --volumes-from myapp-data -p 80:80 --link myapp-php:fpm <span class="_">-d</span> dylanlindgren/docker-laravel-nginx  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#剩下两个 不想写了 因为感觉没用 如果你想用可以看下面 有原文链接 到那里看一下就会了 跟上面大同小异</span></span><br></pre></td></tr></table></figure>
<h1 id="检查浏览器成功与否"><a href="#检查浏览器成功与否" class="headerlink" title="检查浏览器成功与否"></a>检查浏览器成功与否</h1><p>进入<code>http://localhost</code>查看是否有你想要的内容.这里提个醒因为是laravel环境,所以做了地址改写,把根目录指向了public下,我第一次也是找半天,后来看Github源代码才搞懂. 所以你只要把代码放到你的共享目录,也就是上面C:\Users\dylan\myapp\www\public下就ok了.</p>
<h1 id="打完收工"><a href="#打完收工" class="headerlink" title="打完收工"></a>打完收工</h1><p>到此为止你有了个全新的laravel环境了.不过这还不是我想要的,毕竟版本都很低了,而且有些设置不太合我的心意,所以会自己弄一个环境出来的.</p>
<p><a href="http://dylanlindgren.com/docker-for-the-laravel-framework/" target="_blank" rel="external">想看原文的点这里……</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux mount命令的用法详细解析]]></title>
      <url>http://elickzhao.github.io/2016/04/linux%20mount%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="挂接命令-mount"><a href="#挂接命令-mount" class="headerlink" title="挂接命令(mount)"></a>挂接命令(mount)</h1><p>首先，介绍一下挂接(mount)命令的使用方法，mount命令参数非常多，这里主要讲一下今天我们要用到的。<br>命令格式：mount [-t vfstype] [-o options] device dir<br>其中：</p>
<ol>
<li>-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：<br>光盘或光盘镜像：iso9660<br>DOS fat16文件系统：msdos<br>Windows 9x fat32文件系统：vfat<br>Windows NT ntfs文件系统：ntfs<br>Mount Windows文件网络共享：smbfs<br>UNIX(LINUX) 文件网络共享：nfs<br>VirtualBox 文件网络共享: vboxsf</li>
<li>-o options 主要用来描述设备或档案的挂接方式。常用的参数有：<br>loop：用来把一个文件当成硬盘分区挂接上系统<br>ro：采用只读方式挂接设备<br>rw：采用读写方式挂接设备<br>iocharset：指定访问文件系统所用字符集</li>
<li>device 要挂接(mount)的设备。</li>
<li>dir设备在系统上的挂接点(mount point)。<a id="more"></a>
</li>
</ol>
<h1 id="挂接光盘镜像文件"><a href="#挂接光盘镜像文件" class="headerlink" title="挂接光盘镜像文件"></a>挂接光盘镜像文件</h1><ol>
<li><p>从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp /dev/cdrom /home/sunky/mydisk.iso 或</span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/cdrom of=/home/sunky/mydisk.iso</span><br><span class="line"><span class="comment"># 注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/sunky/mydisk.iso</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将文件和目录制作成光盘镜像文件，执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkisofs -r -J -V mydisk -o /home/sunky/mydisk.iso /home/sunky/ mydir</span><br><span class="line"><span class="comment"># 注：这条命令将/home/sunky/mydir目录下所有的目录和文件制作成光盘镜像文件/home/sunky/mydisk.iso，光盘卷标为：mydisk</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>光盘镜像文件的挂接(mount)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /mnt/vcdrom</span><br><span class="line"><span class="comment"># 注：建立一个目录用来作挂接点(mount point)</span></span><br><span class="line"></span><br><span class="line">$ mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom</span><br><span class="line"><span class="comment"># 注：使用/mnt/vcdrom就可以访问盘镜像文件mydisk.iso里的所有文件了。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="挂接移动硬盘"><a href="#挂接移动硬盘" class="headerlink" title="挂接移动硬盘"></a>挂接移动硬盘</h1><p>对linux系统而言，USB接口的移动硬盘是当作SCSI设备对待的。插入移动硬盘之前，应先用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root at pldyrouter /]#  fdisk -l</span><br></pre></td></tr></table></figure></p>
<p>接好移动硬盘后，再用fdisk –l 或 more<br>/proc/partitions查看系统的硬盘和硬盘分区情况.应该可以发现多了一个SCSI硬盘/dev/sdc和它的两个磁盘分区/dev/sdc1?、/dev/sdc2,其中/dev/sdc5是/dev/sdc2分区的逻辑分区。我们可以使用下面的命令挂接/dev/sdc1和/dev/sdc5。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> -p /mnt/usbhd1</span><br><span class="line"><span class="variable">$mkdir</span> -p /mnt/usbhd2</span><br><span class="line"><span class="comment"># 注：建立目录用来作挂接点(mount point)</span></span><br><span class="line"></span><br><span class="line">$ mount -t ntfs /dev/sdc1 /mnt/usbhd1</span><br><span class="line">$ mount -t vfat /dev/sdc5 /mnt/usbhd2</span><br><span class="line"><span class="comment"># 注：对ntfs格式的磁盘分区应使用-t ntfs 参数，对fat32格式的磁盘分区应使用-t vfat参数。若汉字文件名显示为乱码或不显示，可以使用下面的命令格式。</span></span><br><span class="line"></span><br><span class="line">$ mount -t ntfs -o iocharset=cp936 /dev/sdc1 /mnt/usbhd1</span><br><span class="line">$ mount -t vfat -o iocharset=cp936 /dev/sdc5 /mnt/usbhd2</span><br><span class="line"><span class="comment"># linux系统下使用fdisk分区命令和mkfs文件系统创建命令可以将移动硬盘的分区制作成linux系统所特有的ext2、ext3格式。这样，在linux下使用就更方便了。使用下面的命令直接挂接即可。</span></span><br><span class="line"></span><br><span class="line">$ mount /dev/sdc1 /mnt/usbhd1</span><br></pre></td></tr></table></figure>
<h1 id="挂接U盘"><a href="#挂接U盘" class="headerlink" title="挂接U盘"></a>挂接U盘</h1><p>和USB接口的移动硬盘一样对linux系统而言U盘也是当作SCSI设备对待的。使用方法和移动硬盘完全一样。插入U盘之前，应先用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root at pldyrouter root]<span class="comment">#  fdisk -l</span></span><br></pre></td></tr></table></figure></p>
<p>插入U盘后，再用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root at pldyrouter root]<span class="comment">#  fdisk -l</span></span><br></pre></td></tr></table></figure></p>
<p>系统多了一个SCSI硬盘/dev/sdd和一个磁盘分区/dev/sdd1,/dev/sdd1就是我们要挂接的U盘。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /mnt/usb</span><br><span class="line"><span class="comment"># 注：建立一个目录用来作挂接点(mount point)</span></span><br><span class="line">$ mount -t vfat /dev/sdd1 /mnt/usb</span><br><span class="line"><span class="comment"># 注：现在可以通过/mnt/usb来访问U盘了, 若汉字文件名显示为乱码或不显示，可以使用下面的命令。</span></span><br><span class="line">$ mount -t vfat -o iocharset=cp936 /dev/sdd1 /mnt/usb</span><br></pre></td></tr></table></figure></p>
<h1 id="挂接Windows文件共享"><a href="#挂接Windows文件共享" class="headerlink" title="挂接Windows文件共享"></a>挂接Windows文件共享</h1><p>Windows网络共享的核心是SMB/CIFS，在linux下要挂接(mount)windows的磁盘共享，就必须安装和使用samba 软件包。现在流行的linux发行版绝大多数已经包含了samba软件包，如果安装linux系统时未安装samba请首先安装samba。当然也可以到 www.samba.org网站下载……新的版本是3.0.10版。<br>当windows系统共享设置好以后，就可以在linux客户端挂接(mount)了，具体操作如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir –p /mnt/samba</span><br><span class="line"><span class="comment"># 注：建立一个目录用来作挂接点(mount point)</span></span><br><span class="line">$ mount -t smbfs -o username=administrator,password=pldy123 //10.140.133.23/c$ /mnt/samba</span><br><span class="line"><span class="comment"># 注：administrator 和 pldy123 是ip地址为10.140.133.23</span></span><br></pre></td></tr></table></figure></p>
<p>windows计算机的一个用户名和密码，c$是这台计算机的一个磁盘共享<br>如此就可以在linux系统上通过/mnt/samba来访问windows系统磁盘上的文件了。以上操作在redhat as server 3、redflag server 4.1、suse server 9以及windows NT 4.0、windows 2000、windows xp、windows 2003环境下测试通过。</p>
<h1 id="挂接UNIX系统NFS文件共享"><a href="#挂接UNIX系统NFS文件共享" class="headerlink" title="挂接UNIX系统NFS文件共享"></a>挂接UNIX系统NFS文件共享</h1><p>类似于windows的网络共享，UNIX(Linux)系统也有自己的网络共享，那就是NFS(网络文件系统)，下面我们就以SUN Solaris2.8和REDHAT as server 3 为例简单介绍一下在linux下如何mount nfs网络共享。<br>在linux客户端挂接(mount)NFS磁盘共享之前，必须先配置好NFS服务端。</p>
<ol>
<li><p>Solaris系统NFS服务端配置方法如下：</p>
<ul>
<li><p>修改 /etc/dfs/dfstab, 增加共享目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">share -F nfs -o rw /<span class="built_in">export</span>/home/sunky</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动nfs服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/nfs.server start</span><br></pre></td></tr></table></figure>
</li>
<li><p>NFS服务启动以后，也可以使用下面的命令增加新的共享</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ share /<span class="built_in">export</span>/home/sunky1</span><br><span class="line">$ share /<span class="built_in">export</span>/home/sunky2</span><br><span class="line"><span class="comment"># 注：/export/home/sunky和/export/home/sunky1是准备共享的目录</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>linux系统NFS服务端配置方法如下：</p>
<ul>
<li><p>修改 /etc/exports,增加共享目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/<span class="built_in">export</span>/home/sunky 10.140.133.23(rw)</span><br><span class="line">/<span class="built_in">export</span>/home/sunky1 *(rw)</span><br><span class="line">/<span class="built_in">export</span>/home/sunky2 linux-client(rw)</span><br><span class="line"><span class="comment"># 注：/export/home/目录下的sunky、sunky1、sunky2是准备共享的目录，10.140.133.23、*、 linux-client是被允许挂接此共享linux客户机的IP地址或主机名。如果要使用主机名linux-client必须在服务端主机 /etc/hosts文件里增加linux-client主机ip定义。格式如下：</span></span><br><span class="line">10.140.133.23 linux-client</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动与停止NFS服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/init.d/portmap start (在REDHAT中PORTMAP是默认启动的)</span><br><span class="line">/etc/rc.d/init.d/nfs start 启动NFS服务</span><br><span class="line">/etc/rc.d/init.d/nfs stop 停止NFS服务</span><br><span class="line"><span class="comment"># 注：若修改/etc/export文件增加新的共享，应先停止NFS服务，再启动NFS服务方能使新增加的共享起作用。使用命令exportfs -rv也可以达到同样的效果。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>linux客户端挂接(mount)其他linux系统或UNIX系统的NFS共享</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir –p /mnt/nfs</span><br><span class="line"><span class="comment"># 注：建立一个目录用来作挂接点(mount point)</span></span><br><span class="line">$ mount -t nfs -o rw 10.140.133.9:/<span class="built_in">export</span>/home/sunky /mnt/nfs</span><br><span class="line"><span class="comment"># 注：这里我们假设10.140.133.9是NFS服务端的主机IP地址，当然这里也可以使用主机名，但必须在本机/etc/hosts文件里增加服务端ip定义。/export/home/sunky为服务端共享的目录。</span></span><br><span class="line">如此就可以在linux客户端通过/mnt/nfs来访问其它linux系统或UNIX系统以NFS方式共享出来的文件了。以上操作在 redhat as server</span><br></pre></td></tr></table></figure>
</li>
<li><p>redflag server4.1、suse server 9以及Solaris 7、Solaris 8、Solaris 9 for x86&amp;sparc环境下测试通过</p>
</li>
</ol>
<h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p>linux加载光驱<br>（1）使用光驱前，要先mount一下：＃mount /dev/cdrom /mnt/cdrom，然后您就可以进入/mnt/cdrom目录下读取光盘内容了；</p>
<p>（2）当您想退出光盘时，须使用umout命令，否则光驱就会一直处于死锁状态：＃umount /mnt/cdrom。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dockerfile VOLUME 和 -v 的区别]]></title>
      <url>http://elickzhao.github.io/2016/04/Dockerfile%20VOLUME%20%E5%92%8C%20-v%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>elick     发布    新文稿         </p>
<p>Dockerfile VOLUME 和 -v 的区别</p>
<p>docker 服务器相关技术</p>
<p>找到了官方的userguide： <a href="https://docs.docker.com/engine/userguide" target="_blank" rel="external">https://docs.docker.com/engine/userguide</a>…</p>
<p>从中了解了一点：VOLUME并非只是声明，它会把指定路径重新加载一遍，我通过inspect容器也发现了这一点。</p>
<p>这是在Dockerfile指定了VOLUME，并没有指定-v，查看容器的Mounts信息：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"Mounts":</span> [</span><br><span class="line">        &#123;</span><br><span class="line"><span class="attr">            "Name":</span> <span class="string">"b3e2dcacd3f9f40b43ccd5773d45ca74f0f49b02d3da17749cb378ff9f59bb67"</span>,</span><br><span class="line"><span class="attr">            "Source":</span> <span class="string">"/var/lib/docker/volumes/b3e2dcacd3f9f40b43ccd5773d45ca74f0f49b02d3da17749cb378ff9f59bb67/_data"</span>,</span><br><span class="line"><span class="attr">            "Destination":</span> <span class="string">"/etc"</span>,</span><br><span class="line"><span class="attr">            "Driver":</span> <span class="string">"local"</span>,</span><br><span class="line"><span class="attr">            "Mode":</span> <span class="string">""</span>,</span><br><span class="line"><span class="attr">            "RW":</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure></p>
<p>这是在上一个的基础上，指定了-v，查看容器的Mounts信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"Mounts":</span> [</span><br><span class="line">       &#123;</span><br><span class="line"><span class="attr">           "Source":</span> <span class="string">"/etc"</span>,</span><br><span class="line"><span class="attr">           "Destination":</span> <span class="string">"/etc"</span>,</span><br><span class="line"><span class="attr">           "Mode":</span> <span class="string">""</span>,</span><br><span class="line"><span class="attr">           "RW":</span> <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure>
<p>然后你去<code>/var/lib/docker/volumes/b3e2dcacd3f9f40b43ccd5773d45ca74f0f49b02d3da17749cb378ff9f59bb67/_data</code>目录下看一下，大致就清楚了。当Dockerfile里设置的VOLUME目录存在文件,那么在这个目录里就会出现 如用用了-v再指向这个VOLUME目录,又会被host目录覆盖掉</p>
<p>你可以把VOLUME理解为，从镜像中复制指定卷的文件夹到本地/var/lib/docker/volumes/xxxxxxxxx/文件夹，然后把本地的该文件夹挂载到容器里面去。</p>
<p>本质上还是相当于一个本地文件夹挂载而已。</p>
<p>继续补充，因为VOLUME实际上就是在本地新建了一个文件夹挂载了，那么实际上容器内部的文件夹有三种情况：<br>1、没有指定VOLUME也没有指定-v，这种是普通文件夹。<br>2、指定了VOLUME没有指定-v，这种文件夹可以在不同容器之间共享，但是无法在本地修改。<br>3、指定了-v的文件夹，这种文件夹可以在不同容器之间共享，且可以在本地修改。</p>
<p>那就列举一种需要在不同容器之间共享且不需要在本地修改的情况。</p>
<p>首先，我们先了解容器中获取动态数据的方式：<br>1、本地提供，挂载到容器<br>2、远程提供，从远程下载<br>3、生成提供，在容器内部生成</p>
<p>后面两种命令都不需要在本地修改，但是他们生成的动态数据却可能需要共享。<br>下载命令，比如git clone直接从git服务器拉取代码，不需要挂载本地文件夹。<br>生成命令，比如jekyll（静态网站生成器），你可能挂载一个代码文件夹，然后build目录里生成的静态网页文件需要提供给Apache服务器，那么你需要指定build目录为VOLUME。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用的vagrant命令]]></title>
      <url>http://elickzhao.github.io/2016/04/%E5%B8%B8%E7%94%A8%E7%9A%84vagrant%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>常用的vagrant命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box add NAME URL    #添加一个box</span><br><span class="line">$ vagrant box list            #查看本地已添加的box</span><br><span class="line">$ vagrant box remove NAME virtualbox #删除本地已添加的box，如若是版本1.0.x，执行$ vagrant box remove  NAME</span><br><span class="line">$ vagrant init NAME          #初始化，实质应是创建Vagrantfile文件</span><br><span class="line">$ vagrant up                   #启动虚拟机</span><br><span class="line">$ vagrant halt                 #关闭虚拟机</span><br><span class="line">$ vagrant destroy            #销毁虚拟机</span><br><span class="line">$ vagrant reload             #重启虚拟机</span><br><span class="line">$ vagrant package            #当前正在运行的VirtualBox虚拟环境打包成一个可重复使用的box</span><br><span class="line">$ vagrant ssh                 #进入虚拟环境</span><br><span class="line"></span><br><span class="line">$ vagrant init laravel/homestead #初始化并下载box</span><br><span class="line">$ vagrant box add base precise64.box #base 表示指定默认的box，也可以为box指定名称，使用base时，之后可以直接使用 vagrant init 进行初始化，如果自行指定名称，则初始化的时候需要指定box的名称。</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[应用TortoiseGit为github账号添加SSH keys]]></title>
      <url>http://elickzhao.github.io/2016/04/%E5%BA%94%E7%94%A8TortoiseGit%E4%B8%BAgithub%E8%B4%A6%E5%8F%B7%E6%B7%BB%E5%8A%A0SSH%20keys/</url>
      <content type="html"><![CDATA[<p><strong>呵呵 我算是比较懒的 不过避免重复造轮子这种降低效率的事 还是直接引入别人写得详细的文章吧</strong></p>
<p><a href="http://jingyan.baidu.com/article/63f236280f7e750209ab3d60.html" target="_blank" rel="external">文章地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[composer 一些使用记录]]></title>
      <url>http://elickzhao.github.io/2016/04/%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">composer selfupdate                      </span><br><span class="line">composer require &quot;foo/bar:1.0.0&quot;                    安装一个库</span><br><span class="line">composer update foo/bar                             更新单个库</span><br><span class="line">composer create-project laravel/laravel myapp --prefer-dist 创建laravel项目</span><br><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com 配置仓库镜像</span><br><span class="line">composer global require &quot;laravel/installer=~1.1&quot;    全局安装laravel安装器</span><br><span class="line"></span><br><span class="line">composer install update --prefer-dist               后面这个参数是强制使用压缩包</span><br><span class="line">composer install --profile                          后面这个参数是显示安装时间</span><br><span class="line">composer dump-autoload --optimize                   生产环境优化</span><br><span class="line">composer update symfony/yaml --prefer-source        强制克隆代码 用于修改库文件</span><br><span class="line"></span><br><span class="line">当你更新一个修改的库的时候 会提示你是否放弃修改</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">$ composer update</span><br><span class="line">Loading composer repositories with package information  </span><br><span class="line">Updating dependencies  </span><br><span class="line">  - Updating symfony/symfony v2.2.0 (v2.2.0- =&gt; v2.2.0)</span><br><span class="line">    The package has modified files:</span><br><span class="line">    M Dumper.php</span><br><span class="line">    Discard changes [y,n,v,s,?]?</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p><strong>全局配置目录</strong><br>C:\Users\elick\AppData\Roaming\Composer</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker常用命令]]></title>
      <url>http://elickzhao.github.io/2016/04/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="查看docker信息（version、info）"><a href="#查看docker信息（version、info）" class="headerlink" title="查看docker信息（version、info）"></a>查看docker信息（version、info）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker版本  </span></span><br><span class="line"><span class="variable">$docker</span> version  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示docker系统的信息  </span></span><br><span class="line"><span class="variable">$docker</span> info</span><br></pre></td></tr></table></figure>
<h1 id="对image的操作（search、pull、images、rmi、history）"><a href="#对image的操作（search、pull、images、rmi、history）" class="headerlink" title="对image的操作（search、pull、images、rmi、history）"></a>对image的操作（search、pull、images、rmi、history）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检索image  </span></span><br><span class="line"><span class="variable">$docker</span> search image_name  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 下载image  </span></span><br><span class="line"><span class="variable">$docker</span> pull image_name  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  </span></span><br><span class="line"><span class="variable">$docker</span> images  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents  </span></span><br><span class="line"><span class="variable">$docker</span> rmi image_name  </span><br><span class="line"></span><br><span class="line"><span class="comment">#删除所有镜像</span></span><br><span class="line">docker rmi $(docker images | grep none | awk <span class="string">'&#123;print $3&#125;'</span> | sort -r)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  </span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">history</span> image_name </span><br><span class="line"></span><br><span class="line"><span class="comment">#导出容器到本地镜像库：</span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">export</span> container_id &gt; centos.tar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入容器快照为镜像(docker import)：</span></span><br><span class="line"><span class="comment">#(1)容器在本地：</span></span><br><span class="line">cat centos.tar | docker import - registry.intra.weibo.com/yushuang3/centos:v2.0</span><br><span class="line"></span><br><span class="line"><span class="comment">#(2)容器在网络上：</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz registry.intra.weibo.com/yushuang3/centos:v2.0</span><br><span class="line"></span><br><span class="line">Note：</span><br><span class="line">用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，</span><br><span class="line">也可以使用 docker import 来导入一个容器快照到本地镜像库。</span><br><span class="line">这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），</span><br><span class="line">而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure>
<h1 id="启动容器（run）"><a href="#启动容器（run）" class="headerlink" title="启动容器（run）"></a>启动容器（run）</h1><p>docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器中运行"echo"命令，输出"hello word"  </span></span><br><span class="line"><span class="variable">$docker</span> run image_name <span class="built_in">echo</span> <span class="string">"hello word"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">#命名容器</span></span><br><span class="line"><span class="variable">$docker</span> run --name <span class="built_in">test</span> image_name</span><br><span class="line">Note: 这个很有用 这样删除容器等一些操作直接用名称就可以 不用去看ID了</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 交互式进入容器中  </span></span><br><span class="line"><span class="variable">$docker</span> run -i -t image_name /bin/bash  </span><br><span class="line">Note: 如果镜像有tag，需要在image后加:tag名 （-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开）</span><br><span class="line"></span><br><span class="line"><span class="comment">#后台执行容器</span></span><br><span class="line"><span class="variable">$docker</span> run <span class="_">-d</span> image_name </span><br><span class="line"></span><br><span class="line"><span class="comment">#转发端口</span></span><br><span class="line"><span class="variable">$docker</span> run -p 8080:8080 image_name  </span><br><span class="line">Note:  主机端口(host port) : 容器端口(container post)</span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载指定的主机目录</span></span><br><span class="line">$ docker run -v /c/Users/elick/www:/var/www</span><br><span class="line">Note: 主机目录 : 容器目录 挂载指定主机目录 这个是Dockerfile VOLUME没法办到的 因为考虑的Dockerfile的迁移问题 主机目录是不确定的,所这个指定目录只能用命令行来执行 而Dockerfile VOLUME 只是挂载了容器内一个目录 还有个问题是 这个挂载是吧主机目录完全复制到容器目录 但不是双向的 会把容器目录内容删除 **两个地址都必须是绝对地址 还有容器内的目录可以没有 会自动添加的**</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在容器中安装新的程序  </span></span><br><span class="line"><span class="variable">$docker</span> run image_name apt-get install -y app_name  </span><br><span class="line"></span><br><span class="line">Note：  在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。</span><br><span class="line"></span><br><span class="line"><span class="comment"># container内的root拥有真正的root权限。</span></span><br><span class="line">docker run --privileged=<span class="literal">false</span>         </span><br><span class="line"></span><br><span class="line">Note: 使用该参数，container内的root拥有真正的root权限。</span><br><span class="line">否则，container内的root只是外部的一个普通用户权限。</span><br><span class="line">否则，container内的root只是外部的一个普通用户权限。</span><br><span class="line">privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。</span><br><span class="line">甚至允许你在docker容器中启动docker容器。</span><br></pre></td></tr></table></figure>
<h1 id="查看容器（ps）"><a href="#查看容器（ps）" class="headerlink" title="查看容器（ps）"></a>查看容器（ps）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前所有正在运行的container  </span></span><br><span class="line"><span class="variable">$docker</span> ps  </span><br><span class="line"><span class="comment"># 列出所有的container  </span></span><br><span class="line"><span class="variable">$docker</span> ps <span class="_">-a</span>  </span><br><span class="line"><span class="comment"># 列出最近一次启动的container  </span></span><br><span class="line"><span class="variable">$docker</span> ps <span class="_">-l</span></span><br></pre></td></tr></table></figure>
<h1 id="保存对容器的修改（commit）"><a href="#保存对容器的修改（commit）" class="headerlink" title="保存对容器的修改（commit）"></a>保存对容器的修改（commit）</h1><p>当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存对容器的修改; -a, --author="" Author; -m, --message="" Commit message  </span></span><br><span class="line"><span class="variable">$docker</span> commit <span class="_">-a</span> <span class="string">'author'</span> ID new_image_name  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Note：  image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。</span><br></pre></td></tr></table></figure>
<h1 id="对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）"><a href="#对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）" class="headerlink" title="对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）"></a>对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有容器  </span></span><br><span class="line"><span class="variable">$docker</span> rm `docker ps <span class="_">-a</span> -q`  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container  </span></span><br><span class="line"><span class="variable">$docker</span> rm Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 停止、启动、杀死一个容器  </span></span><br><span class="line"><span class="variable">$docker</span> stop Name/ID  </span><br><span class="line"><span class="variable">$docker</span> start Name/ID  </span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">kill</span> Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps  </span></span><br><span class="line"><span class="variable">$docker</span> logs Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的  </span></span><br><span class="line"><span class="variable">$docker</span> diff Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示一个运行的容器里面的进程信息  </span></span><br><span class="line"><span class="variable">$docker</span> top Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从容器里面拷贝文件/目录到本地一个路径  </span></span><br><span class="line"><span class="variable">$docker</span> cp Name:/container_path to_path  </span><br><span class="line"><span class="variable">$docker</span> cp ID:/container_path to_path  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10  </span></span><br><span class="line"><span class="variable">$docker</span> restart Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  </span></span><br><span class="line"><span class="variable">$docker</span> attach ID  </span><br><span class="line"></span><br><span class="line">Note： attach命令允许你查看或者影响一个运行的容器。你可以在同一时间attach同一个容器。你也可以从一个容器中脱离出来，是从CTRL-C。但是脱离出来后 容器也就停止了</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -it container_name /bin/bash</span><br><span class="line">Note: <span class="built_in">exec</span> 使用-it时，和我们平常操作console界面类似。而且也不会像attach方式因为退出，导致 </span><br><span class="line">整个容器退出。（-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开） 和run -it 一样后面必须接上要执行的命令 比如 /bin/bash 否则会报错</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改容器名</span></span><br><span class="line"><span class="variable">$docker</span> rename old容器名  new容器名</span><br><span class="line"></span><br><span class="line"><span class="comment">#要获取容器的输出信息:</span></span><br><span class="line"><span class="variable">$docker</span> logs <span class="_">-f</span> &lt;容器名orID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器的root用户密码</span></span><br><span class="line"><span class="variable">$docker</span> logs &lt;容器名orID&gt; 2&gt;&amp;1 | grep <span class="string">'^User: '</span> | tail -n1</span><br><span class="line"></span><br><span class="line"><span class="comment">#一个容器连接到另一个容器</span></span><br><span class="line"><span class="variable">$docker</span> run -i -t --name sonar <span class="_">-d</span> -link mmysql:db   tpires/sonar-server</span><br><span class="line">Note: sonar容器连接到mmysql容器，并将mmysql容器重命名为db。这样，sonar容器就可以使用db的相关的环境变量了。如下查看环境变量就可以看到mmysql相关环境变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@665f1bdc5913:/<span class="comment"># env</span></span><br><span class="line">HOSTNAME=665f1bdc5913</span><br><span class="line">DB_NAME=/compassionate_pasteur/db</span><br><span class="line">TERM=xterm</span><br><span class="line">DB_PORT=tcp://172.17.0.2:11211</span><br><span class="line">DB_PORT_3306_TCP_PROTO=tcp</span><br><span class="line">DB_PORT_3306_TCP_ADDR=172.17.0.2</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">PWD=/</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/</span><br><span class="line">DB_PORT_3306_TCP_PORT=3306</span><br><span class="line">DB_PORT_3306_TCP=tcp://172.17.0.2:3306</span><br><span class="line">container=lxc</span><br><span class="line">_=/usr/bin/env</span><br></pre></td></tr></table></figure>
<h1 id="保存和加载镜像（save、load）"><a href="#保存和加载镜像（save、load）" class="headerlink" title="保存和加载镜像（save、load）"></a>保存和加载镜像（save、load）</h1><p>当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存镜像到一个tar包; -o, --output="" Write to an file  </span></span><br><span class="line"><span class="variable">$docker</span> save image_name -o file_path  </span><br><span class="line"><span class="comment"># 加载一个tar包格式的镜像; -i, --input="" Read from a tar archive file  </span></span><br><span class="line"><span class="variable">$docker</span> load -i file_path  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 机器a  </span></span><br><span class="line"><span class="variable">$docker</span> save image_name &gt; /home/save.tar  </span><br><span class="line"><span class="comment"># 使用scp将save.tar拷到机器b上，然后：  </span></span><br><span class="line"><span class="variable">$docker</span> load &lt; /home/save.tar</span><br></pre></td></tr></table></figure></p>
<h1 id="登录registry-server（login）"><a href="#登录registry-server（login）" class="headerlink" title="登录registry server（login）"></a>登录registry server（login）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登陆registry server; -e, --email="" Email; -p, --password="" Password; -u, --username="" Username  </span></span><br><span class="line"><span class="variable">$docker</span> login</span><br></pre></td></tr></table></figure>
<h1 id="发布image（push）"><a href="#发布image（push）" class="headerlink" title="发布image（push）"></a>发布image（push）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布docker镜像  </span></span><br><span class="line"><span class="variable">$docker</span> push new_image_name</span><br></pre></td></tr></table></figure>
<h1 id="根据Dockerfile-构建出一个容器"><a href="#根据Dockerfile-构建出一个容器" class="headerlink" title="根据Dockerfile 构建出一个容器"></a>根据Dockerfile 构建出一个容器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build  </span></span><br><span class="line">      --no-cache=<span class="literal">false</span> Do not use cache when building the image  </span><br><span class="line">      -q, --quiet=<span class="literal">false</span> Suppress the verbose output generated by the containers  </span><br><span class="line">      --rm=<span class="literal">true</span> Remove intermediate containers after a successful build  </span><br><span class="line">      -t, --tag=<span class="string">""</span> Repository name (and optionally a tag) to be applied to the resulting image <span class="keyword">in</span> <span class="keyword">case</span> of success  </span><br><span class="line"><span class="variable">$docker</span> build -t image_name Dockerfile_path</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.tankywoo.com/docker/2014/05/08/docker-2-dockerfile.html" target="_blank" rel="external">Docker 2 – 关于Dockerfile</a><br><a href="http://blog.tankywoo.com/docker/2014/05/08/docker-4-summary.html" target="_blank" rel="external">Docker 4 – 总结</a><br><a href="http://www.tuicool.com/articles/uYzeAnz" target="_blank" rel="external">深入理解 Docker Volume（一）</a><br><a href="http://blog.csdn.net/qinyushuang/article/details/43342091" target="_blank" rel="external">docker 容器相关命令</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker及boot2docker相关研究]]></title>
      <url>http://elickzhao.github.io/2016/04/docker%E5%8F%8Aboot2docker%E7%9B%B8%E5%85%B3%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="boot2docker转发端口问题"><a href="#boot2docker转发端口问题" class="headerlink" title="boot2docker转发端口问题"></a>boot2docker转发端口问题</h1><p>  这是个很恶心的问题 因为boot2docker还是依赖与virtualbox 所以虽然使用命令 <code>docker run -dp 8080:8080 php</code>进行转发 但是还需要修改虚拟机的端口转发才可以 </p>
<blockquote>
<p>命令解析:<br>  docker -d 后台执行 -p 转发端口</p>
</blockquote>
<p>  <img src="/image/16-4/2.png" alt="虚拟机转发端口"></p>
<a id="more"></a>
<h1 id="boot2docker数据卷问题"><a href="#boot2docker数据卷问题" class="headerlink" title="boot2docker数据卷问题"></a>boot2docker数据卷问题</h1><p>  这个就更恶心了,使用在windows下的boot2docker命令行就会报错,只有进入virtualbox 使用命令 <code>docker run -dp 8080:8080 --name test1 -v /c/Users/elick/www:/var/www elick/php</code>才可以 真是醉了<br>  <strong>需要注意的一点:</strong> boot2docker建立的虚拟机有个自启动共享目录 <code>c/Users C:\Users</code> 在虚拟机里的根目录下能看到这个目录 所以windows上的目录的根目录是/c/开始的<br><img src="/image/16-4/3.png" alt="共享目录"></p>
<h1 id="boot2docker使用总结"><a href="#boot2docker使用总结" class="headerlink" title="boot2docker使用总结"></a>boot2docker使用总结</h1><p>  从上面两点来看,虽然省略了配置vagrantfile的麻烦,但是还得去弄虚拟机从这点看,貌似还不如使用vagrant来的简单些</p>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="http://avnpc.com/pages/build-php-develop-env-by-docker" target="_blank" rel="external">Docker在PHP项目开发环境中的应用</a><br><a href="http://www.tuicool.com/articles/uYzeAnz" target="_blank" rel="external">{译} 深入理解 Docker Volume（一）</a><br><a href="http://my.oschina.net/mfk123/blog/292425" target="_blank" rel="external">Dockers 快速学习（四）Docker 容器的使用</a><br><a href="http://www.linuxdown.net/install/soft/2016/0303/4906.html" target="_blank" rel="external">Docker安装_Ubuntu 15.10 &amp; 14.04 LTS上安装和管理Docker</a><br><a href="http://blog.csdn.net/halcyonbaby/article/details/46884605" target="_blank" rel="external">Docker exec与Docker attach</a><br><a href="http://blog.chinaunix.net/uid-10915175-id-4443127.html" target="_blank" rel="external">Docker之常用命令</a><br><a href="http://www.tuicool.com/articles/7V7vYn" target="_blank" rel="external">Docker学习笔记(2)–Docker常用命令</a><br><a href="http://tech.uc.cn/?p=2726" target="_blank" rel="external">利用Docker构建开发环境</a><br><a href="http://snoopyxdy.blog.163.com/blog/static/6011744020147187542090" target="_blank" rel="external">利用docker快速部署应用</a><br><a href="http://blog.csdn.net/junjun16818/article/details/30655543" target="_blank" rel="external">Docker volume使用</a><br><a href="http://my.oschina.net/piorcn/blog/324202" target="_blank" rel="external">Docker学习—挂载本地目录</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决ln -s 软链接产生Too many levels of symbolic links错误]]></title>
      <url>http://elickzhao.github.io/2016/04/%E8%A7%A3%E5%86%B3ln%20-s%20%E8%BD%AF%E9%93%BE%E6%8E%A5%E4%BA%A7%E7%94%9FToo%20many%20levels%20of%20symbolic%20links%E9%94%99%E8%AF%AF/</url>
      <content type="html"><![CDATA[<p>今天生成软连接发生这个报错,查了一下,原来是因为使用了相对路径,改成绝对路径就没有问题了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ln</span> <span class="_">-s</span> /cygdrive/f/Vagrant /home/elick/vagrant</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>命令解析:<br>ln -s 源目录 目标目录</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在VirtualBox和Vagrant中安装Docker]]></title>
      <url>http://elickzhao.github.io/2016/04/%E5%9C%A8VirtualBox%E5%92%8CVagrant%E4%B8%AD%E5%AE%89%E8%A3%85Docker/</url>
      <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.jdon.com/artichect/docker-install.html" target="_blank" rel="external">在VirtualBox和Vagrant中安装Docker</a><br><a href="http://www.tuicool.com/articles/V36R3y" target="_blank" rel="external">OSX下使用vagrant和docker管理创建虚拟环境</a><br><a href="http://rmingwang.com/vagrant-commands-and-config.html" target="_blank" rel="external">Vagrant简介和安装配置</a><br><a href="http://ninghao.net/blog/1566" target="_blank" rel="external">使用 Vagrant 搭建本地开发环境的教程</a><br><a href="http://www.oschina.net/translate/unsuck-your-vagrant-developing-in-one-vm-with-vagrant-and-docker" target="_blank" rel="external">使用 Vagrant 和 Docker 在一个 VM 中进行开发</a><br><a href="http://cloud.51cto.com/art/201503/470256_all.htm" target="_blank" rel="external">1+1&gt;2:用Docker和Vagrant构建简洁高效开发环境</a><br><a href="http://blog.sina.com.cn/s/blog_72ef7bea0102vucz.html" target="_blank" rel="external">Vagrant运行Docker的几种方法</a><br><a href="http://www.cnblogs.com/ac1985482/p/4029315.html" target="_blank" rel="external">vagrant在windows下的使用</a><br><a href="http://www.blogjava.net/yongboy/archive/2013/08/26/403325.html" target="_blank" rel="external">服务器操作系统CoreOS初体验</a><br><a href="http://betacz.com/series/%E5%BD%93%E6%B5%81%E6%B5%AA%E8%80%85%28Vagrant%29%E9%81%87%E8%A7%81%E7%A0%81%E5%A4%B4%E5%B7%A5%E4%BA%BA%28Docker%29/" target="_blank" rel="external">‘当流浪者(Vagrant)遇见码头工人(Docker)’系列</a></p>
<a id="more"></a>
<h1 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h1><p>用boot2docker启动docker 容器一直会卡在 <code>default: Syncing folders to the host VM...</code> 看了下<a href="https://www.vagrantup.com/docs/docker/basics.html" target="_blank" rel="external">官方文档</a></p>
<blockquote>
<p>Synced folder note: Vagrant will attempt to use the “best” synced folder implementation it can. For boot2docker, this is often rsync. In this case, make sure you have rsync installed on your host machine. Vagrant will give you a human-friendly error message if it is not.</p>
</blockquote>
<p><del>这尿性是要安装一个rsync的同步软件 这鸟东西安装起来蛮麻烦的 而且基本用不到 所以不装了  毕竟就算是生产环境肯定用不到这个 linux版本 所以开发的时候还得装别的版本 以达到和生产环境同步 所以算了<br>直接搞个 CoreOS 这个试试吧 这个挺新的比较有趣</del><br>最后还是测试了rsync这个软件,因为使用CoreOS加载docker镜像 也会出现卡在同步文件夹那 所以看来问题不在boot2docker </p>
<h1 id="得到升华"><a href="#得到升华" class="headerlink" title="得到升华"></a>得到升华</h1><p><strong>我找到个方法 可以解决这个问题 但是并不是十全十美的方法</strong><br>就是屏蔽同步文件夹<br><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="number">2</span>) <span class="keyword">do</span> |config|</span><br><span class="line">  config.vm.synced_folder <span class="string">"."</span>, <span class="string">"/vagrant"</span>, disabled: <span class="literal">true</span>  <span class="meta">#这一句就是</span></span><br><span class="line">  config.vm.provider <span class="string">"docker"</span> <span class="keyword">do</span> |d|</span><br><span class="line">    d.image = <span class="string">"tknerr/baseimage-ubuntu:14.04"</span></span><br><span class="line">    d.has_ssh = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#这句是新加的</span></span><br><span class="line">    <span class="meta">#d.vagrant_machine = "dockerhost" </span></span><br><span class="line">   	<span class="meta">#d.vagrant_vagrantfile = "../coreos/Vagrantfile"</span></span><br><span class="line">    <span class="meta">#config.vm.box = "coreos-stable" </span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  config.vm.provision <span class="string">"shell"</span>, inline: <span class="string">"echo 'hello docker!'"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h2 id="惊喜发现"><a href="#惊喜发现" class="headerlink" title="惊喜发现"></a>惊喜发现</h2><p><strong>这个简直太省地方了:</strong> 利用boot2docker 加载 tknerr/baseimage-ubuntu:14.04 这个基础镜像 最后生成的虚拟机才有400M coreOS是900M多  而Homestead 已经是2.67G了<br><img src="/image/16-4/1.png" alt="hello"></p>
<p>而且使用的box也非常省 boot2docker只有20M而已</p>
<h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><p><strong>C:\Users\elick.vagrant.d</strong> 这是vagrant的根目录 最主要有两个目录</p>
<ul>
<li>boxes<br> 这个是存放box的目录,所有你下载的各种box都在这里 </li>
<li>data<br> 这个是存放host的一些信息的地方<ul>
<li>docker-host<br>  这个就是用docker,而没有加载box的时候 自动下载的boot2docker</li>
<li>machine-index<br>  存着建立多少个host和host状态的信息 就是那个index 如果在virtualbox删除了host 这里还显示可以在这里手动删了</li>
</ul>
</li>
</ul>
<p><strong>C:\Users\elick\VirtualBox VMs</strong> 就是virtualbox存放虚拟机的位置</p>
]]></content>
    </entry>
    
  
  
</search>

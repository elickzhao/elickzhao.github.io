<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[应用TortoiseGit为github账号添加SSH keys]]></title>
      <url>http://elickzhao.github.io/2016/04/%E5%BA%94%E7%94%A8TortoiseGit%E4%B8%BAgithub%E8%B4%A6%E5%8F%B7%E6%B7%BB%E5%8A%A0SSH%20keys/</url>
      <content type="html"><![CDATA[<p><strong>呵呵 我算是比较懒的 不过避免重复造轮子这种降低效率的事 还是直接引入别人写得详细的文章吧</strong></p>
<p><a href="http://jingyan.baidu.com/article/63f236280f7e750209ab3d60.html" target="_blank" rel="external">文章地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[composer 一些使用记录]]></title>
      <url>http://elickzhao.github.io/2016/04/%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">composer selfupdate                      </span><br><span class="line">composer require "foo/bar:1.0.0"                    安装一个库</span><br><span class="line">composer <span class="keyword">update</span> foo/bar                             更新单个库</span><br><span class="line">composer <span class="keyword">create</span>-<span class="keyword">project</span> laravel/laravel myapp <span class="comment">--prefer-dist 创建laravel项目</span></span><br><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com 配置仓库镜像</span><br><span class="line">composer <span class="keyword">global</span> require <span class="string">"laravel/installer=~1.1"</span>    全局安装laravel安装器</span><br><span class="line"></span><br><span class="line">composer <span class="keyword">install</span> <span class="keyword">update</span> <span class="comment">--prefer-dist               后面这个参数是强制使用压缩包</span></span><br><span class="line">composer <span class="keyword">install</span> <span class="comment">--profile                          后面这个参数是显示安装时间</span></span><br><span class="line">composer dump-autoload <span class="comment">--optimize                   生产环境优化</span></span><br><span class="line">composer <span class="keyword">update</span> symfony/yaml <span class="comment">--prefer-source        强制克隆代码 用于修改库文件</span></span><br><span class="line"></span><br><span class="line">当你更新一个修改的库的时候 会提示你是否放弃修改</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br><span class="line">$ composer <span class="keyword">update</span></span><br><span class="line">Loading composer repositories <span class="keyword">with</span> <span class="keyword">package</span> information  </span><br><span class="line">Updating dependencies  </span><br><span class="line">  - Updating symfony/symfony v2<span class="number">.2</span><span class="number">.0</span> (v2<span class="number">.2</span><span class="number">.0</span>- =&gt; v2<span class="number">.2</span><span class="number">.0</span>)</span><br><span class="line">    The <span class="keyword">package</span> has modified files:</span><br><span class="line">    M Dumper.php</span><br><span class="line">    Discard changes [y,n,v,s,?]?</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>
<p><strong>全局配置目录</strong><br>C:\Users\elick\AppData\Roaming\Composer</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker常用命令]]></title>
      <url>http://elickzhao.github.io/2016/04/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="查看docker信息（version、info）"><a href="#查看docker信息（version、info）" class="headerlink" title="查看docker信息（version、info）"></a>查看docker信息（version、info）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker版本  </span></span><br><span class="line"><span class="variable">$docker</span> version  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示docker系统的信息  </span></span><br><span class="line"><span class="variable">$docker</span> info</span><br></pre></td></tr></table></figure>
<h1 id="对image的操作（search、pull、images、rmi、history）"><a href="#对image的操作（search、pull、images、rmi、history）" class="headerlink" title="对image的操作（search、pull、images、rmi、history）"></a>对image的操作（search、pull、images、rmi、history）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检索image  </span></span><br><span class="line"><span class="variable">$docker</span> search image_name  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 下载image  </span></span><br><span class="line"><span class="variable">$docker</span> pull image_name  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  </span></span><br><span class="line"><span class="variable">$docker</span> images  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents  </span></span><br><span class="line"><span class="variable">$docker</span> rmi image_name  </span><br><span class="line"></span><br><span class="line"><span class="comment">#删除所有镜像</span></span><br><span class="line">docker rmi $(docker images | grep none | awk <span class="string">'&#123;print $3&#125;'</span> | sort -r)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  </span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">history</span> image_name </span><br><span class="line"></span><br><span class="line"><span class="comment">#导出容器到本地镜像库：</span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">export</span> container_id &gt; centos.tar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入容器快照为镜像(docker import)：</span></span><br><span class="line"><span class="comment">#(1)容器在本地：</span></span><br><span class="line">cat centos.tar | docker import - registry.intra.weibo.com/yushuang3/centos:v2.0</span><br><span class="line"></span><br><span class="line"><span class="comment">#(2)容器在网络上：</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz registry.intra.weibo.com/yushuang3/centos:v2.0</span><br><span class="line"></span><br><span class="line">Note：</span><br><span class="line">用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，</span><br><span class="line">也可以使用 docker import 来导入一个容器快照到本地镜像库。</span><br><span class="line">这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），</span><br><span class="line">而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure>
<h1 id="启动容器（run）"><a href="#启动容器（run）" class="headerlink" title="启动容器（run）"></a>启动容器（run）</h1><p>docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器中运行"echo"命令，输出"hello word"  </span></span><br><span class="line"><span class="variable">$docker</span> run image_name <span class="built_in">echo</span> <span class="string">"hello word"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">#命名容器</span></span><br><span class="line"><span class="variable">$docker</span> run --name <span class="built_in">test</span> image_name</span><br><span class="line">Note: 这个很有用 这样删除容器等一些操作直接用名称就可以 不用去看ID了</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 交互式进入容器中  </span></span><br><span class="line"><span class="variable">$docker</span> run -i -t image_name /bin/bash  </span><br><span class="line">Note: 如果镜像有tag，需要在image后加:tag名 （-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开）</span><br><span class="line"></span><br><span class="line"><span class="comment">#后台执行容器</span></span><br><span class="line"><span class="variable">$docker</span> run <span class="_">-d</span> image_name </span><br><span class="line"></span><br><span class="line"><span class="comment">#转发端口</span></span><br><span class="line"><span class="variable">$docker</span> run -p 8080:8080 image_name  </span><br><span class="line">Note:  主机端口(host port) : 容器端口(container post)</span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载指定的主机目录</span></span><br><span class="line">$ docker run -v /c/Users/elick/www:/var/www</span><br><span class="line">Note: 主机目录 : 容器目录 挂载指定主机目录 这个是Dockerfile VOLUME没法办到的 因为考虑的Dockerfile的迁移问题 主机目录是不确定的,所这个指定目录只能用命令行来执行 而Dockerfile VOLUME 只是挂载了容器内一个目录</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在容器中安装新的程序  </span></span><br><span class="line"><span class="variable">$docker</span> run image_name apt-get install -y app_name  </span><br><span class="line"></span><br><span class="line">Note：  在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。</span><br></pre></td></tr></table></figure>
<h1 id="查看容器（ps）"><a href="#查看容器（ps）" class="headerlink" title="查看容器（ps）"></a>查看容器（ps）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前所有正在运行的container  </span></span><br><span class="line"><span class="variable">$docker</span> ps  </span><br><span class="line"><span class="comment"># 列出所有的container  </span></span><br><span class="line"><span class="variable">$docker</span> ps <span class="_">-a</span>  </span><br><span class="line"><span class="comment"># 列出最近一次启动的container  </span></span><br><span class="line"><span class="variable">$docker</span> ps <span class="_">-l</span></span><br></pre></td></tr></table></figure>
<h1 id="保存对容器的修改（commit）"><a href="#保存对容器的修改（commit）" class="headerlink" title="保存对容器的修改（commit）"></a>保存对容器的修改（commit）</h1><p>当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存对容器的修改; -a, --author="" Author; -m, --message="" Commit message  </span></span><br><span class="line"><span class="variable">$docker</span> commit ID new_image_name  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Note：  image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。</span><br></pre></td></tr></table></figure>
<h1 id="对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）"><a href="#对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）" class="headerlink" title="对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）"></a>对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有容器  </span></span><br><span class="line"><span class="variable">$docker</span> rm `docker ps <span class="_">-a</span> -q`  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container  </span></span><br><span class="line"><span class="variable">$docker</span> rm Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 停止、启动、杀死一个容器  </span></span><br><span class="line"><span class="variable">$docker</span> stop Name/ID  </span><br><span class="line"><span class="variable">$docker</span> start Name/ID  </span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">kill</span> Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps  </span></span><br><span class="line"><span class="variable">$docker</span> logs Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的  </span></span><br><span class="line"><span class="variable">$docker</span> diff Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示一个运行的容器里面的进程信息  </span></span><br><span class="line"><span class="variable">$docker</span> top Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从容器里面拷贝文件/目录到本地一个路径  </span></span><br><span class="line"><span class="variable">$docker</span> cp Name:/container_path to_path  </span><br><span class="line"><span class="variable">$docker</span> cp ID:/container_path to_path  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10  </span></span><br><span class="line"><span class="variable">$docker</span> restart Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  </span></span><br><span class="line"><span class="variable">$docker</span> attach ID  </span><br><span class="line"></span><br><span class="line">Note： attach命令允许你查看或者影响一个运行的容器。你可以在同一时间attach同一个容器。你也可以从一个容器中脱离出来，是从CTRL-C。但是脱离出来后 容器也就停止了</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -it container_name /bin/bash</span><br><span class="line">Note: <span class="built_in">exec</span> 使用-it时，和我们平常操作console界面类似。而且也不会像attach方式因为退出，导致 </span><br><span class="line">整个容器退出。（-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开） 和run -it 一样后面必须接上要执行的命令 比如 /bin/bash 否则会报错</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改容器名</span></span><br><span class="line"><span class="variable">$docker</span> rename old容器名  new容器名</span><br><span class="line"></span><br><span class="line"><span class="comment">#要获取容器的输出信息:</span></span><br><span class="line"><span class="variable">$docker</span> logs <span class="_">-f</span> &lt;容器名orID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器的root用户密码</span></span><br><span class="line"><span class="variable">$docker</span> logs &lt;容器名orID&gt; 2&gt;&amp;1 | grep <span class="string">'^User: '</span> | tail -n1</span><br><span class="line"></span><br><span class="line"><span class="comment">#一个容器连接到另一个容器</span></span><br><span class="line"><span class="variable">$docker</span> run -i -t --name sonar <span class="_">-d</span> -link mmysql:db   tpires/sonar-server</span><br><span class="line">Note: sonar容器连接到mmysql容器，并将mmysql容器重命名为db。这样，sonar容器就可以使用db的相关的环境变量了。</span><br></pre></td></tr></table></figure>
<h1 id="保存和加载镜像（save、load）"><a href="#保存和加载镜像（save、load）" class="headerlink" title="保存和加载镜像（save、load）"></a>保存和加载镜像（save、load）</h1><p>当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存镜像到一个tar包; -o, --output="" Write to an file  </span></span><br><span class="line"><span class="variable">$docker</span> save image_name -o file_path  </span><br><span class="line"><span class="comment"># 加载一个tar包格式的镜像; -i, --input="" Read from a tar archive file  </span></span><br><span class="line"><span class="variable">$docker</span> load -i file_path  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 机器a  </span></span><br><span class="line"><span class="variable">$docker</span> save image_name &gt; /home/save.tar  </span><br><span class="line"><span class="comment"># 使用scp将save.tar拷到机器b上，然后：  </span></span><br><span class="line"><span class="variable">$docker</span> load &lt; /home/save.tar</span><br></pre></td></tr></table></figure></p>
<h1 id="登录registry-server（login）"><a href="#登录registry-server（login）" class="headerlink" title="登录registry server（login）"></a>登录registry server（login）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登陆registry server; -e, --email="" Email; -p, --password="" Password; -u, --username="" Username  </span></span><br><span class="line"><span class="variable">$docker</span> login</span><br></pre></td></tr></table></figure>
<h1 id="发布image（push）"><a href="#发布image（push）" class="headerlink" title="发布image（push）"></a>发布image（push）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布docker镜像  </span></span><br><span class="line"><span class="variable">$docker</span> push new_image_name</span><br></pre></td></tr></table></figure>
<h1 id="根据Dockerfile-构建出一个容器"><a href="#根据Dockerfile-构建出一个容器" class="headerlink" title="根据Dockerfile 构建出一个容器"></a>根据Dockerfile 构建出一个容器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build  </span></span><br><span class="line">      --no-cache=<span class="literal">false</span> Do not use cache when building the image  </span><br><span class="line">      -q, --quiet=<span class="literal">false</span> Suppress the verbose output generated by the containers  </span><br><span class="line">      --rm=<span class="literal">true</span> Remove intermediate containers after a successful build  </span><br><span class="line">      -t, --tag=<span class="string">""</span> Repository name (and optionally a tag) to be applied to the resulting image <span class="keyword">in</span> <span class="keyword">case</span> of success  </span><br><span class="line"><span class="variable">$docker</span> build -t image_name Dockerfile_path</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.tankywoo.com/docker/2014/05/08/docker-2-dockerfile.html" target="_blank" rel="external">Docker 2 – 关于Dockerfile</a><br><a href="http://blog.tankywoo.com/docker/2014/05/08/docker-4-summary.html" target="_blank" rel="external">Docker 4 – 总结</a><br><a href="http://www.tuicool.com/articles/uYzeAnz" target="_blank" rel="external">深入理解 Docker Volume（一）</a><br><a href="http://blog.csdn.net/qinyushuang/article/details/43342091" target="_blank" rel="external">docker 容器相关命令</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker及boot2docker相关研究]]></title>
      <url>http://elickzhao.github.io/2016/04/docker%E5%8F%8Aboot2docker%E7%9B%B8%E5%85%B3%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="boot2docker转发端口问题"><a href="#boot2docker转发端口问题" class="headerlink" title="boot2docker转发端口问题"></a>boot2docker转发端口问题</h1><p>  这是个很恶心的问题 因为boot2docker还是依赖与virtualbox 所以虽然使用命令 <code>docker run -dp 8080:8080 php</code>进行转发 但是还需要修改虚拟机的端口转发才可以 </p>
<blockquote>
<p>命令解析:<br>  docker -d 后台执行 -p 转发端口</p>
</blockquote>
<p>  <img src="/image/16-4/2.png" alt="虚拟机转发端口"></p>
<a id="more"></a>
<h1 id="boot2docker数据卷问题"><a href="#boot2docker数据卷问题" class="headerlink" title="boot2docker数据卷问题"></a>boot2docker数据卷问题</h1><p>  这个就更恶心了,使用在windows下的boot2docker命令行就会报错,只有进入virtualbox 使用命令 <code>docker run -dp 8080:8080 --name test1 -v /c/Users/elick/www:/var/www elick/php</code>才可以 真是醉了<br>  <strong>需要注意的一点:</strong> boot2docker建立的虚拟机有个自启动共享目录 <code>c/Users C:\Users</code> 在虚拟机里的根目录下能看到这个目录 所以windows上的目录的根目录是/c/开始的<br><img src="/image/16-4/3.png" alt="共享目录"></p>
<h1 id="boot2docker使用总结"><a href="#boot2docker使用总结" class="headerlink" title="boot2docker使用总结"></a>boot2docker使用总结</h1><p>  从上面两点来看,虽然省略了配置vagrantfile的麻烦,但是还得去弄虚拟机从这点看,貌似还不如使用vagrant来的简单些</p>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="http://avnpc.com/pages/build-php-develop-env-by-docker" target="_blank" rel="external">Docker在PHP项目开发环境中的应用</a><br><a href="http://www.tuicool.com/articles/uYzeAnz" target="_blank" rel="external">{译} 深入理解 Docker Volume（一）</a><br><a href="http://my.oschina.net/mfk123/blog/292425" target="_blank" rel="external">Dockers 快速学习（四）Docker 容器的使用</a><br><a href="http://www.linuxdown.net/install/soft/2016/0303/4906.html" target="_blank" rel="external">Docker安装_Ubuntu 15.10 &amp; 14.04 LTS上安装和管理Docker</a><br><a href="http://blog.csdn.net/halcyonbaby/article/details/46884605" target="_blank" rel="external">Docker exec与Docker attach</a><br><a href="http://blog.chinaunix.net/uid-10915175-id-4443127.html" target="_blank" rel="external">Docker之常用命令</a><br><a href="http://www.tuicool.com/articles/7V7vYn" target="_blank" rel="external">Docker学习笔记(2)–Docker常用命令</a><br><a href="http://tech.uc.cn/?p=2726" target="_blank" rel="external">利用Docker构建开发环境</a><br><a href="http://snoopyxdy.blog.163.com/blog/static/6011744020147187542090" target="_blank" rel="external">利用docker快速部署应用</a><br><a href="http://blog.csdn.net/junjun16818/article/details/30655543" target="_blank" rel="external">Docker volume使用</a><br><a href="http://my.oschina.net/piorcn/blog/324202" target="_blank" rel="external">Docker学习—挂载本地目录</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决ln -s 软链接产生Too many levels of symbolic links错误]]></title>
      <url>http://elickzhao.github.io/2016/04/%E8%A7%A3%E5%86%B3ln%20-s%20%E8%BD%AF%E9%93%BE%E6%8E%A5%E4%BA%A7%E7%94%9FToo%20many%20levels%20of%20symbolic%20links%E9%94%99%E8%AF%AF/</url>
      <content type="html"><![CDATA[<p>今天生成软连接发生这个报错,查了一下,原来是因为使用了相对路径,改成绝对路径就没有问题了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ln</span> <span class="_">-s</span> /cygdrive/f/Vagrant /home/elick/vagrant</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>命令解析:<br>ln -s 源目录 目标目录</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在VirtualBox和Vagrant中安装Docker]]></title>
      <url>http://elickzhao.github.io/2016/04/%E5%9C%A8VirtualBox%E5%92%8CVagrant%E4%B8%AD%E5%AE%89%E8%A3%85Docker/</url>
      <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.jdon.com/artichect/docker-install.html" target="_blank" rel="external">在VirtualBox和Vagrant中安装Docker</a><br><a href="http://www.tuicool.com/articles/V36R3y" target="_blank" rel="external">OSX下使用vagrant和docker管理创建虚拟环境</a><br><a href="http://rmingwang.com/vagrant-commands-and-config.html" target="_blank" rel="external">Vagrant简介和安装配置</a><br><a href="http://ninghao.net/blog/1566" target="_blank" rel="external">使用 Vagrant 搭建本地开发环境的教程</a><br><a href="http://www.oschina.net/translate/unsuck-your-vagrant-developing-in-one-vm-with-vagrant-and-docker" target="_blank" rel="external">使用 Vagrant 和 Docker 在一个 VM 中进行开发</a><br><a href="http://cloud.51cto.com/art/201503/470256_all.htm" target="_blank" rel="external">1+1&gt;2:用Docker和Vagrant构建简洁高效开发环境</a><br><a href="http://blog.sina.com.cn/s/blog_72ef7bea0102vucz.html" target="_blank" rel="external">Vagrant运行Docker的几种方法</a><br><a href="http://www.cnblogs.com/ac1985482/p/4029315.html" target="_blank" rel="external">vagrant在windows下的使用</a><br><a href="http://www.blogjava.net/yongboy/archive/2013/08/26/403325.html" target="_blank" rel="external">服务器操作系统CoreOS初体验</a><br><a href="http://betacz.com/series/%E5%BD%93%E6%B5%81%E6%B5%AA%E8%80%85(Vagrant" target="_blank" rel="external">‘当流浪者(Vagrant)遇见码头工人(Docker)’ 系列</a>%E9%81%87%E8%A7%81%E7%A0%81%E5%A4%B4%E5%B7%A5%E4%BA%BA(Docker)/)</p>
<a id="more"></a>
<h1 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h1><p>用boot2docker启动docker 容器一直会卡在 <code>default: Syncing folders to the host VM...</code> 看了下<a href="https://www.vagrantup.com/docs/docker/basics.html" target="_blank" rel="external">官方文档</a></p>
<blockquote>
<p>Synced folder note: Vagrant will attempt to use the “best” synced folder implementation it can. For boot2docker, this is often rsync. In this case, make sure you have rsync installed on your host machine. Vagrant will give you a human-friendly error message if it is not.</p>
</blockquote>
<p><del>这尿性是要安装一个rsync的同步软件 这鸟东西安装起来蛮麻烦的 而且基本用不到 所以不装了  毕竟就算是生产环境肯定用不到这个 linux版本 所以开发的时候还得装别的版本 以达到和生产环境同步 所以算了<br>直接搞个 CoreOS 这个试试吧 这个挺新的比较有趣</del><br>最后还是测试了rsync这个软件,因为使用CoreOS加载docker镜像 也会出现卡在同步文件夹那 所以看来问题不在boot2docker </p>
<h1 id="得到升华"><a href="#得到升华" class="headerlink" title="得到升华"></a>得到升华</h1><p><strong>我找到个方法 可以解决这个问题 但是并不是十全十美的方法</strong><br>就是屏蔽同步文件夹<br><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="number">2</span>) <span class="keyword">do</span> |config|</span><br><span class="line">  config.vm.synced_folder <span class="string">"."</span>, <span class="string">"/vagrant"</span>, disabled: <span class="literal">true</span>  <span class="meta">#这一句就是</span></span><br><span class="line">  config.vm.provider <span class="string">"docker"</span> <span class="keyword">do</span> |d|</span><br><span class="line">    d.image = <span class="string">"tknerr/baseimage-ubuntu:14.04"</span></span><br><span class="line">    d.has_ssh = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#这句是新加的</span></span><br><span class="line">    <span class="meta">#d.vagrant_machine = "dockerhost" </span></span><br><span class="line">   	<span class="meta">#d.vagrant_vagrantfile = "../coreos/Vagrantfile"</span></span><br><span class="line">    <span class="meta">#config.vm.box = "coreos-stable" </span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  config.vm.provision <span class="string">"shell"</span>, inline: <span class="string">"echo 'hello docker!'"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h2 id="惊喜发现"><a href="#惊喜发现" class="headerlink" title="惊喜发现"></a>惊喜发现</h2><p><strong>这个简直太省地方了:</strong> 利用boot2docker 加载 tknerr/baseimage-ubuntu:14.04 这个基础镜像 最后生成的虚拟机才有400M coreOS是900M多  而Homestead 已经是2.67G了<br><img src="/image/16-4/1.png" alt="hello"></p>
<p>而且使用的box也非常省 boot2docker只有20M而已</p>
<h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><p><strong>C:\Users\elick.vagrant.d</strong> 这是vagrant的根目录 最主要有两个目录</p>
<ul>
<li>boxes<br> 这个是存放box的目录,所有你下载的各种box都在这里 </li>
<li>data<br> 这个是存放host的一些信息的地方<ul>
<li>docker-host<br>  这个就是用docker,而没有加载box的时候 自动下载的boot2docker</li>
<li>machine-index<br>  存着建立多少个host和host状态的信息 就是那个index 如果在virtualbox删除了host 这里还显示可以在这里手动删了</li>
</ul>
</li>
</ul>
<p><strong>C:\Users\elick\VirtualBox VMs</strong> 就是virtualbox存放虚拟机的位置</p>
]]></content>
    </entry>
    
  
  
</search>

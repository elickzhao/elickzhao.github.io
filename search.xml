<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[linux mount命令的用法详细解析]]></title>
      <url>http://elickzhao.github.io/2016/04/linux%20mount%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="挂接命令-mount"><a href="#挂接命令-mount" class="headerlink" title="挂接命令(mount)"></a>挂接命令(mount)</h1><p>首先，介绍一下挂接(mount)命令的使用方法，mount命令参数非常多，这里主要讲一下今天我们要用到的。<br>命令格式：mount [-t vfstype] [-o options] device dir<br>其中：</p>
<ol>
<li>-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：<br>光盘或光盘镜像：iso9660<br>DOS fat16文件系统：msdos<br>Windows 9x fat32文件系统：vfat<br>Windows NT ntfs文件系统：ntfs<br>Mount Windows文件网络共享：smbfs<br>UNIX(LINUX) 文件网络共享：nfs</li>
<li>-o options 主要用来描述设备或档案的挂接方式。常用的参数有：<br>loop：用来把一个文件当成硬盘分区挂接上系统<br>ro：采用只读方式挂接设备<br>rw：采用读写方式挂接设备<br>iocharset：指定访问文件系统所用字符集</li>
<li>device 要挂接(mount)的设备。</li>
<li>dir设备在系统上的挂接点(mount point)。<a id="more"></a>
</li>
</ol>
<h1 id="挂接光盘镜像文件"><a href="#挂接光盘镜像文件" class="headerlink" title="挂接光盘镜像文件"></a>挂接光盘镜像文件</h1><ol>
<li><p>从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp /dev/cdrom /home/sunky/mydisk.iso 或</span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/cdrom of=/home/sunky/mydisk.iso</span><br><span class="line"><span class="comment"># 注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/sunky/mydisk.iso</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将文件和目录制作成光盘镜像文件，执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkisofs -r -J -V mydisk -o /home/sunky/mydisk.iso /home/sunky/ mydir</span><br><span class="line"><span class="comment"># 注：这条命令将/home/sunky/mydir目录下所有的目录和文件制作成光盘镜像文件/home/sunky/mydisk.iso，光盘卷标为：mydisk</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>光盘镜像文件的挂接(mount)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /mnt/vcdrom</span><br><span class="line"><span class="comment"># 注：建立一个目录用来作挂接点(mount point)</span></span><br><span class="line"></span><br><span class="line">$ mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom</span><br><span class="line"><span class="comment"># 注：使用/mnt/vcdrom就可以访问盘镜像文件mydisk.iso里的所有文件了。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="挂接移动硬盘"><a href="#挂接移动硬盘" class="headerlink" title="挂接移动硬盘"></a>挂接移动硬盘</h1><p>对linux系统而言，USB接口的移动硬盘是当作SCSI设备对待的。插入移动硬盘之前，应先用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root at pldyrouter /]#  fdisk -l</span><br></pre></td></tr></table></figure></p>
<p>接好移动硬盘后，再用fdisk –l 或 more<br>/proc/partitions查看系统的硬盘和硬盘分区情况.应该可以发现多了一个SCSI硬盘/dev/sdc和它的两个磁盘分区/dev/sdc1?、/dev/sdc2,其中/dev/sdc5是/dev/sdc2分区的逻辑分区。我们可以使用下面的命令挂接/dev/sdc1和/dev/sdc5。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> -p /mnt/usbhd1</span><br><span class="line"><span class="variable">$mkdir</span> -p /mnt/usbhd2</span><br><span class="line"><span class="comment"># 注：建立目录用来作挂接点(mount point)</span></span><br><span class="line"></span><br><span class="line">$ mount -t ntfs /dev/sdc1 /mnt/usbhd1</span><br><span class="line">$ mount -t vfat /dev/sdc5 /mnt/usbhd2</span><br><span class="line"><span class="comment"># 注：对ntfs格式的磁盘分区应使用-t ntfs 参数，对fat32格式的磁盘分区应使用-t vfat参数。若汉字文件名显示为乱码或不显示，可以使用下面的命令格式。</span></span><br><span class="line"></span><br><span class="line">$ mount -t ntfs -o iocharset=cp936 /dev/sdc1 /mnt/usbhd1</span><br><span class="line">$ mount -t vfat -o iocharset=cp936 /dev/sdc5 /mnt/usbhd2</span><br><span class="line"><span class="comment"># linux系统下使用fdisk分区命令和mkfs文件系统创建命令可以将移动硬盘的分区制作成linux系统所特有的ext2、ext3格式。这样，在linux下使用就更方便了。使用下面的命令直接挂接即可。</span></span><br><span class="line"></span><br><span class="line">$ mount /dev/sdc1 /mnt/usbhd1</span><br></pre></td></tr></table></figure>
<h1 id="挂接U盘"><a href="#挂接U盘" class="headerlink" title="挂接U盘"></a>挂接U盘</h1><p>和USB接口的移动硬盘一样对linux系统而言U盘也是当作SCSI设备对待的。使用方法和移动硬盘完全一样。插入U盘之前，应先用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root at pldyrouter root]<span class="comment">#  fdisk -l</span></span><br></pre></td></tr></table></figure></p>
<p>插入U盘后，再用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root at pldyrouter root]<span class="comment">#  fdisk -l</span></span><br></pre></td></tr></table></figure></p>
<p>系统多了一个SCSI硬盘/dev/sdd和一个磁盘分区/dev/sdd1,/dev/sdd1就是我们要挂接的U盘。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /mnt/usb</span><br><span class="line"><span class="comment"># 注：建立一个目录用来作挂接点(mount point)</span></span><br><span class="line">$ mount -t vfat /dev/sdd1 /mnt/usb</span><br><span class="line"><span class="comment"># 注：现在可以通过/mnt/usb来访问U盘了, 若汉字文件名显示为乱码或不显示，可以使用下面的命令。</span></span><br><span class="line">$ mount -t vfat -o iocharset=cp936 /dev/sdd1 /mnt/usb</span><br></pre></td></tr></table></figure></p>
<h1 id="挂接Windows文件共享"><a href="#挂接Windows文件共享" class="headerlink" title="挂接Windows文件共享"></a>挂接Windows文件共享</h1><p>Windows网络共享的核心是SMB/CIFS，在linux下要挂接(mount)windows的磁盘共享，就必须安装和使用samba 软件包。现在流行的linux发行版绝大多数已经包含了samba软件包，如果安装linux系统时未安装samba请首先安装samba。当然也可以到 www.samba.org网站下载……新的版本是3.0.10版。<br>当windows系统共享设置好以后，就可以在linux客户端挂接(mount)了，具体操作如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir –p /mnt/samba</span><br><span class="line"><span class="comment"># 注：建立一个目录用来作挂接点(mount point)</span></span><br><span class="line">$ mount -t smbfs -o username=administrator,password=pldy123 //10.140.133.23/c$ /mnt/samba</span><br><span class="line"><span class="comment"># 注：administrator 和 pldy123 是ip地址为10.140.133.23</span></span><br></pre></td></tr></table></figure></p>
<p>windows计算机的一个用户名和密码，c$是这台计算机的一个磁盘共享<br>如此就可以在linux系统上通过/mnt/samba来访问windows系统磁盘上的文件了。以上操作在redhat as server 3、redflag server 4.1、suse server 9以及windows NT 4.0、windows 2000、windows xp、windows 2003环境下测试通过。</p>
<h1 id="挂接UNIX系统NFS文件共享"><a href="#挂接UNIX系统NFS文件共享" class="headerlink" title="挂接UNIX系统NFS文件共享"></a>挂接UNIX系统NFS文件共享</h1><p>类似于windows的网络共享，UNIX(Linux)系统也有自己的网络共享，那就是NFS(网络文件系统)，下面我们就以SUN Solaris2.8和REDHAT as server 3 为例简单介绍一下在linux下如何mount nfs网络共享。<br>在linux客户端挂接(mount)NFS磁盘共享之前，必须先配置好NFS服务端。</p>
<ol>
<li><p>Solaris系统NFS服务端配置方法如下：</p>
<ul>
<li><p>修改 /etc/dfs/dfstab, 增加共享目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">share -F nfs -o rw /<span class="built_in">export</span>/home/sunky</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动nfs服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/nfs.server start</span><br></pre></td></tr></table></figure>
</li>
<li><p>NFS服务启动以后，也可以使用下面的命令增加新的共享</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ share /<span class="built_in">export</span>/home/sunky1</span><br><span class="line">$ share /<span class="built_in">export</span>/home/sunky2</span><br><span class="line"><span class="comment"># 注：/export/home/sunky和/export/home/sunky1是准备共享的目录</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>linux系统NFS服务端配置方法如下：</p>
<ul>
<li><p>修改 /etc/exports,增加共享目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/<span class="built_in">export</span>/home/sunky 10.140.133.23(rw)</span><br><span class="line">/<span class="built_in">export</span>/home/sunky1 *(rw)</span><br><span class="line">/<span class="built_in">export</span>/home/sunky2 linux-client(rw)</span><br><span class="line"><span class="comment"># 注：/export/home/目录下的sunky、sunky1、sunky2是准备共享的目录，10.140.133.23、*、 linux-client是被允许挂接此共享linux客户机的IP地址或主机名。如果要使用主机名linux-client必须在服务端主机 /etc/hosts文件里增加linux-client主机ip定义。格式如下：</span></span><br><span class="line">10.140.133.23 linux-client</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动与停止NFS服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/init.d/portmap start (在REDHAT中PORTMAP是默认启动的)</span><br><span class="line">/etc/rc.d/init.d/nfs start 启动NFS服务</span><br><span class="line">/etc/rc.d/init.d/nfs stop 停止NFS服务</span><br><span class="line"><span class="comment"># 注：若修改/etc/export文件增加新的共享，应先停止NFS服务，再启动NFS服务方能使新增加的共享起作用。使用命令exportfs -rv也可以达到同样的效果。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>linux客户端挂接(mount)其他linux系统或UNIX系统的NFS共享</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir –p /mnt/nfs</span><br><span class="line"><span class="comment"># 注：建立一个目录用来作挂接点(mount point)</span></span><br><span class="line">$ mount -t nfs -o rw 10.140.133.9:/<span class="built_in">export</span>/home/sunky /mnt/nfs</span><br><span class="line"><span class="comment"># 注：这里我们假设10.140.133.9是NFS服务端的主机IP地址，当然这里也可以使用主机名，但必须在本机/etc/hosts文件里增加服务端ip定义。/export/home/sunky为服务端共享的目录。</span></span><br><span class="line">如此就可以在linux客户端通过/mnt/nfs来访问其它linux系统或UNIX系统以NFS方式共享出来的文件了。以上操作在 redhat as server</span><br></pre></td></tr></table></figure>
</li>
<li><p>redflag server4.1、suse server 9以及Solaris 7、Solaris 8、Solaris 9 for x86&amp;sparc环境下测试通过</p>
</li>
</ol>
<h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p>linux加载光驱<br>（1）使用光驱前，要先mount一下：＃mount /dev/cdrom /mnt/cdrom，然后您就可以进入/mnt/cdrom目录下读取光盘内容了；</p>
<p>（2）当您想退出光盘时，须使用umout命令，否则光驱就会一直处于死锁状态：＃umount /mnt/cdrom。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dockerfile VOLUME 和 -v 的区别]]></title>
      <url>http://elickzhao.github.io/2016/04/Dockerfile%20VOLUME%20%E5%92%8C%20-v%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>elick     发布    新文稿         </p>
<p>Dockerfile VOLUME 和 -v 的区别</p>
<p>docker 服务器相关技术</p>
<p>找到了官方的userguide： <a href="https://docs.docker.com/engine/userguide" target="_blank" rel="external">https://docs.docker.com/engine/userguide</a>…</p>
<p>从中了解了一点：VOLUME并非只是声明，它会把指定路径重新加载一遍，我通过inspect容器也发现了这一点。</p>
<p>这是在Dockerfile指定了VOLUME，并没有指定-v，查看容器的Mounts信息：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"Mounts":</span> [</span><br><span class="line">        &#123;</span><br><span class="line"><span class="attr">            "Name":</span> <span class="string">"b3e2dcacd3f9f40b43ccd5773d45ca74f0f49b02d3da17749cb378ff9f59bb67"</span>,</span><br><span class="line"><span class="attr">            "Source":</span> <span class="string">"/var/lib/docker/volumes/b3e2dcacd3f9f40b43ccd5773d45ca74f0f49b02d3da17749cb378ff9f59bb67/_data"</span>,</span><br><span class="line"><span class="attr">            "Destination":</span> <span class="string">"/etc"</span>,</span><br><span class="line"><span class="attr">            "Driver":</span> <span class="string">"local"</span>,</span><br><span class="line"><span class="attr">            "Mode":</span> <span class="string">""</span>,</span><br><span class="line"><span class="attr">            "RW":</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure></p>
<p>这是在上一个的基础上，指定了-v，查看容器的Mounts信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"Mounts":</span> [</span><br><span class="line">       &#123;</span><br><span class="line"><span class="attr">           "Source":</span> <span class="string">"/etc"</span>,</span><br><span class="line"><span class="attr">           "Destination":</span> <span class="string">"/etc"</span>,</span><br><span class="line"><span class="attr">           "Mode":</span> <span class="string">""</span>,</span><br><span class="line"><span class="attr">           "RW":</span> <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure>
<p>然后你去<code>/var/lib/docker/volumes/b3e2dcacd3f9f40b43ccd5773d45ca74f0f49b02d3da17749cb378ff9f59bb67/_data</code>目录下看一下，大致就清楚了。当Dockerfile里设置的VOLUME目录存在文件,那么在这个目录里就会出现 如用用了-v再指向这个VOLUME目录,又会被host目录覆盖掉</p>
<p>你可以把VOLUME理解为，从镜像中复制指定卷的文件夹到本地/var/lib/docker/volumes/xxxxxxxxx/文件夹，然后把本地的该文件夹挂载到容器里面去。</p>
<p>本质上还是相当于一个本地文件夹挂载而已。</p>
<p>继续补充，因为VOLUME实际上就是在本地新建了一个文件夹挂载了，那么实际上容器内部的文件夹有三种情况：<br>1、没有指定VOLUME也没有指定-v，这种是普通文件夹。<br>2、指定了VOLUME没有指定-v，这种文件夹可以在不同容器之间共享，但是无法在本地修改。<br>3、指定了-v的文件夹，这种文件夹可以在不同容器之间共享，且可以在本地修改。</p>
<p>那就列举一种需要在不同容器之间共享且不需要在本地修改的情况。</p>
<p>首先，我们先了解容器中获取动态数据的方式：<br>1、本地提供，挂载到容器<br>2、远程提供，从远程下载<br>3、生成提供，在容器内部生成</p>
<p>后面两种命令都不需要在本地修改，但是他们生成的动态数据却可能需要共享。<br>下载命令，比如git clone直接从git服务器拉取代码，不需要挂载本地文件夹。<br>生成命令，比如jekyll（静态网站生成器），你可能挂载一个代码文件夹，然后build目录里生成的静态网页文件需要提供给Apache服务器，那么你需要指定build目录为VOLUME。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ ubuntu 国内源列表]]></title>
      <url>http://elickzhao.github.io/2016/04/ubuntu-%E5%9B%BD%E5%86%85%E6%BA%90%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>详细地址都在下面连接 ubuntu国内官网<br><a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="external">源列表</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用的vagrant命令]]></title>
      <url>http://elickzhao.github.io/2016/04/%E5%B8%B8%E7%94%A8%E7%9A%84vagrant%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>常用的vagrant命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box add NAME URL    #添加一个box</span><br><span class="line">$ vagrant box list            #查看本地已添加的box</span><br><span class="line">$ vagrant box remove NAME virtualbox #删除本地已添加的box，如若是版本1.0.x，执行$ vagrant box remove  NAME</span><br><span class="line">$ vagrant init NAME          #初始化，实质应是创建Vagrantfile文件</span><br><span class="line">$ vagrant up                   #启动虚拟机</span><br><span class="line">$ vagrant halt                 #关闭虚拟机</span><br><span class="line">$ vagrant destroy            #销毁虚拟机</span><br><span class="line">$ vagrant reload             #重启虚拟机</span><br><span class="line">$ vagrant package            #当前正在运行的VirtualBox虚拟环境打包成一个可重复使用的box</span><br><span class="line">$ vagrant ssh                 #进入虚拟环境</span><br><span class="line"></span><br><span class="line">$ vagrant init laravel/homestead #初始化并下载box</span><br><span class="line">$ vagrant box add base precise64.box #base 表示指定默认的box，也可以为box指定名称，使用base时，之后可以直接使用 vagrant init 进行初始化，如果自行指定名称，则初始化的时候需要指定box的名称。</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[应用TortoiseGit为github账号添加SSH keys]]></title>
      <url>http://elickzhao.github.io/2016/04/%E5%BA%94%E7%94%A8TortoiseGit%E4%B8%BAgithub%E8%B4%A6%E5%8F%B7%E6%B7%BB%E5%8A%A0SSH%20keys/</url>
      <content type="html"><![CDATA[<p><strong>呵呵 我算是比较懒的 不过避免重复造轮子这种降低效率的事 还是直接引入别人写得详细的文章吧</strong></p>
<p><a href="http://jingyan.baidu.com/article/63f236280f7e750209ab3d60.html" target="_blank" rel="external">文章地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[composer 一些使用记录]]></title>
      <url>http://elickzhao.github.io/2016/04/%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">composer selfupdate                      </span><br><span class="line">composer require &quot;foo/bar:1.0.0&quot;                    安装一个库</span><br><span class="line">composer update foo/bar                             更新单个库</span><br><span class="line">composer create-project laravel/laravel myapp --prefer-dist 创建laravel项目</span><br><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com 配置仓库镜像</span><br><span class="line">composer global require &quot;laravel/installer=~1.1&quot;    全局安装laravel安装器</span><br><span class="line"></span><br><span class="line">composer install update --prefer-dist               后面这个参数是强制使用压缩包</span><br><span class="line">composer install --profile                          后面这个参数是显示安装时间</span><br><span class="line">composer dump-autoload --optimize                   生产环境优化</span><br><span class="line">composer update symfony/yaml --prefer-source        强制克隆代码 用于修改库文件</span><br><span class="line"></span><br><span class="line">当你更新一个修改的库的时候 会提示你是否放弃修改</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">$ composer update</span><br><span class="line">Loading composer repositories with package information  </span><br><span class="line">Updating dependencies  </span><br><span class="line">  - Updating symfony/symfony v2.2.0 (v2.2.0- =&gt; v2.2.0)</span><br><span class="line">    The package has modified files:</span><br><span class="line">    M Dumper.php</span><br><span class="line">    Discard changes [y,n,v,s,?]?</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p><strong>全局配置目录</strong><br>C:\Users\elick\AppData\Roaming\Composer</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker常用命令]]></title>
      <url>http://elickzhao.github.io/2016/04/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>title: Docker常用命令<br>date: 2016-04-19 00:42:12<br>tags: [docker,服务器相关技术]</p>
<h2 id="categories-服务器端"><a href="#categories-服务器端" class="headerlink" title="categories: 服务器端"></a>categories: 服务器端</h2><h1 id="查看docker信息（version、info）"><a href="#查看docker信息（version、info）" class="headerlink" title="查看docker信息（version、info）"></a>查看docker信息（version、info）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker版本  </span></span><br><span class="line"><span class="variable">$docker</span> version  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示docker系统的信息  </span></span><br><span class="line"><span class="variable">$docker</span> info</span><br></pre></td></tr></table></figure>
<h1 id="对image的操作（search、pull、images、rmi、history）"><a href="#对image的操作（search、pull、images、rmi、history）" class="headerlink" title="对image的操作（search、pull、images、rmi、history）"></a>对image的操作（search、pull、images、rmi、history）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检索image  </span></span><br><span class="line"><span class="variable">$docker</span> search image_name  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 下载image  </span></span><br><span class="line"><span class="variable">$docker</span> pull image_name  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  </span></span><br><span class="line"><span class="variable">$docker</span> images  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents  </span></span><br><span class="line"><span class="variable">$docker</span> rmi image_name  </span><br><span class="line"></span><br><span class="line"><span class="comment">#删除所有镜像</span></span><br><span class="line">docker rmi $(docker images | grep none | awk <span class="string">'&#123;print $3&#125;'</span> | sort -r)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  </span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">history</span> image_name </span><br><span class="line"></span><br><span class="line"><span class="comment">#导出容器到本地镜像库：</span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">export</span> container_id &gt; centos.tar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入容器快照为镜像(docker import)：</span></span><br><span class="line"><span class="comment">#(1)容器在本地：</span></span><br><span class="line">cat centos.tar | docker import - registry.intra.weibo.com/yushuang3/centos:v2.0</span><br><span class="line"></span><br><span class="line"><span class="comment">#(2)容器在网络上：</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz registry.intra.weibo.com/yushuang3/centos:v2.0</span><br><span class="line"></span><br><span class="line">Note：</span><br><span class="line">用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，</span><br><span class="line">也可以使用 docker import 来导入一个容器快照到本地镜像库。</span><br><span class="line">这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），</span><br><span class="line">而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure>
<h1 id="启动容器（run）"><a href="#启动容器（run）" class="headerlink" title="启动容器（run）"></a>启动容器（run）</h1><p>docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器中运行"echo"命令，输出"hello word"  </span></span><br><span class="line"><span class="variable">$docker</span> run image_name <span class="built_in">echo</span> <span class="string">"hello word"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">#命名容器</span></span><br><span class="line"><span class="variable">$docker</span> run --name <span class="built_in">test</span> image_name</span><br><span class="line">Note: 这个很有用 这样删除容器等一些操作直接用名称就可以 不用去看ID了</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 交互式进入容器中  </span></span><br><span class="line"><span class="variable">$docker</span> run -i -t image_name /bin/bash  </span><br><span class="line">Note: 如果镜像有tag，需要在image后加:tag名 （-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开）</span><br><span class="line"></span><br><span class="line"><span class="comment">#后台执行容器</span></span><br><span class="line"><span class="variable">$docker</span> run <span class="_">-d</span> image_name </span><br><span class="line"></span><br><span class="line"><span class="comment">#转发端口</span></span><br><span class="line"><span class="variable">$docker</span> run -p 8080:8080 image_name  </span><br><span class="line">Note:  主机端口(host port) : 容器端口(container post)</span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载指定的主机目录</span></span><br><span class="line">$ docker run -v /c/Users/elick/www:/var/www</span><br><span class="line">Note: 主机目录 : 容器目录 挂载指定主机目录 这个是Dockerfile VOLUME没法办到的 因为考虑的Dockerfile的迁移问题 主机目录是不确定的,所这个指定目录只能用命令行来执行 而Dockerfile VOLUME 只是挂载了容器内一个目录 还有个问题是 这个挂载是吧主机目录完全复制到容器目录 但不是双向的 会把容器目录内容删除 **两个地址都必须是绝对地址 还有容器内的目录可以没有 会自动添加的**</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在容器中安装新的程序  </span></span><br><span class="line"><span class="variable">$docker</span> run image_name apt-get install -y app_name  </span><br><span class="line"></span><br><span class="line">Note：  在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。</span><br></pre></td></tr></table></figure>
<h1 id="查看容器（ps）"><a href="#查看容器（ps）" class="headerlink" title="查看容器（ps）"></a>查看容器（ps）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前所有正在运行的container  </span></span><br><span class="line"><span class="variable">$docker</span> ps  </span><br><span class="line"><span class="comment"># 列出所有的container  </span></span><br><span class="line"><span class="variable">$docker</span> ps <span class="_">-a</span>  </span><br><span class="line"><span class="comment"># 列出最近一次启动的container  </span></span><br><span class="line"><span class="variable">$docker</span> ps <span class="_">-l</span></span><br></pre></td></tr></table></figure>
<h1 id="保存对容器的修改（commit）"><a href="#保存对容器的修改（commit）" class="headerlink" title="保存对容器的修改（commit）"></a>保存对容器的修改（commit）</h1><p>当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存对容器的修改; -a, --author="" Author; -m, --message="" Commit message  </span></span><br><span class="line"><span class="variable">$docker</span> commit <span class="_">-a</span> <span class="string">'author'</span> ID new_image_name  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Note：  image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。</span><br></pre></td></tr></table></figure>
<h1 id="对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）"><a href="#对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）" class="headerlink" title="对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）"></a>对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有容器  </span></span><br><span class="line"><span class="variable">$docker</span> rm `docker ps <span class="_">-a</span> -q`  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container  </span></span><br><span class="line"><span class="variable">$docker</span> rm Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 停止、启动、杀死一个容器  </span></span><br><span class="line"><span class="variable">$docker</span> stop Name/ID  </span><br><span class="line"><span class="variable">$docker</span> start Name/ID  </span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">kill</span> Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps  </span></span><br><span class="line"><span class="variable">$docker</span> logs Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的  </span></span><br><span class="line"><span class="variable">$docker</span> diff Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示一个运行的容器里面的进程信息  </span></span><br><span class="line"><span class="variable">$docker</span> top Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从容器里面拷贝文件/目录到本地一个路径  </span></span><br><span class="line"><span class="variable">$docker</span> cp Name:/container_path to_path  </span><br><span class="line"><span class="variable">$docker</span> cp ID:/container_path to_path  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10  </span></span><br><span class="line"><span class="variable">$docker</span> restart Name/ID  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  </span></span><br><span class="line"><span class="variable">$docker</span> attach ID  </span><br><span class="line"></span><br><span class="line">Note： attach命令允许你查看或者影响一个运行的容器。你可以在同一时间attach同一个容器。你也可以从一个容器中脱离出来，是从CTRL-C。但是脱离出来后 容器也就停止了</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -it container_name /bin/bash</span><br><span class="line">Note: <span class="built_in">exec</span> 使用-it时，和我们平常操作console界面类似。而且也不会像attach方式因为退出，导致 </span><br><span class="line">整个容器退出。（-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开） 和run -it 一样后面必须接上要执行的命令 比如 /bin/bash 否则会报错</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改容器名</span></span><br><span class="line"><span class="variable">$docker</span> rename old容器名  new容器名</span><br><span class="line"></span><br><span class="line"><span class="comment">#要获取容器的输出信息:</span></span><br><span class="line"><span class="variable">$docker</span> logs <span class="_">-f</span> &lt;容器名orID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器的root用户密码</span></span><br><span class="line"><span class="variable">$docker</span> logs &lt;容器名orID&gt; 2&gt;&amp;1 | grep <span class="string">'^User: '</span> | tail -n1</span><br><span class="line"></span><br><span class="line"><span class="comment">#一个容器连接到另一个容器</span></span><br><span class="line"><span class="variable">$docker</span> run -i -t --name sonar <span class="_">-d</span> -link mmysql:db   tpires/sonar-server</span><br><span class="line">Note: sonar容器连接到mmysql容器，并将mmysql容器重命名为db。这样，sonar容器就可以使用db的相关的环境变量了。</span><br></pre></td></tr></table></figure>
<h1 id="保存和加载镜像（save、load）"><a href="#保存和加载镜像（save、load）" class="headerlink" title="保存和加载镜像（save、load）"></a>保存和加载镜像（save、load）</h1><p>当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存镜像到一个tar包; -o, --output="" Write to an file  </span></span><br><span class="line"><span class="variable">$docker</span> save image_name -o file_path  </span><br><span class="line"><span class="comment"># 加载一个tar包格式的镜像; -i, --input="" Read from a tar archive file  </span></span><br><span class="line"><span class="variable">$docker</span> load -i file_path  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 机器a  </span></span><br><span class="line"><span class="variable">$docker</span> save image_name &gt; /home/save.tar  </span><br><span class="line"><span class="comment"># 使用scp将save.tar拷到机器b上，然后：  </span></span><br><span class="line"><span class="variable">$docker</span> load &lt; /home/save.tar</span><br></pre></td></tr></table></figure></p>
<h1 id="登录registry-server（login）"><a href="#登录registry-server（login）" class="headerlink" title="登录registry server（login）"></a>登录registry server（login）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登陆registry server; -e, --email="" Email; -p, --password="" Password; -u, --username="" Username  </span></span><br><span class="line"><span class="variable">$docker</span> login</span><br></pre></td></tr></table></figure>
<h1 id="发布image（push）"><a href="#发布image（push）" class="headerlink" title="发布image（push）"></a>发布image（push）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布docker镜像  </span></span><br><span class="line"><span class="variable">$docker</span> push new_image_name</span><br></pre></td></tr></table></figure>
<h1 id="根据Dockerfile-构建出一个容器"><a href="#根据Dockerfile-构建出一个容器" class="headerlink" title="根据Dockerfile 构建出一个容器"></a>根据Dockerfile 构建出一个容器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build  </span></span><br><span class="line">      --no-cache=<span class="literal">false</span> Do not use cache when building the image  </span><br><span class="line">      -q, --quiet=<span class="literal">false</span> Suppress the verbose output generated by the containers  </span><br><span class="line">      --rm=<span class="literal">true</span> Remove intermediate containers after a successful build  </span><br><span class="line">      -t, --tag=<span class="string">""</span> Repository name (and optionally a tag) to be applied to the resulting image <span class="keyword">in</span> <span class="keyword">case</span> of success  </span><br><span class="line"><span class="variable">$docker</span> build -t image_name Dockerfile_path</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.tankywoo.com/docker/2014/05/08/docker-2-dockerfile.html" target="_blank" rel="external">Docker 2 – 关于Dockerfile</a><br><a href="http://blog.tankywoo.com/docker/2014/05/08/docker-4-summary.html" target="_blank" rel="external">Docker 4 – 总结</a><br><a href="http://www.tuicool.com/articles/uYzeAnz" target="_blank" rel="external">深入理解 Docker Volume（一）</a><br><a href="http://blog.csdn.net/qinyushuang/article/details/43342091" target="_blank" rel="external">docker 容器相关命令</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker及boot2docker相关研究]]></title>
      <url>http://elickzhao.github.io/2016/04/docker%E5%8F%8Aboot2docker%E7%9B%B8%E5%85%B3%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="boot2docker转发端口问题"><a href="#boot2docker转发端口问题" class="headerlink" title="boot2docker转发端口问题"></a>boot2docker转发端口问题</h1><p>  这是个很恶心的问题 因为boot2docker还是依赖与virtualbox 所以虽然使用命令 <code>docker run -dp 8080:8080 php</code>进行转发 但是还需要修改虚拟机的端口转发才可以 </p>
<blockquote>
<p>命令解析:<br>  docker -d 后台执行 -p 转发端口</p>
</blockquote>
<p>  <img src="/image/16-4/2.png" alt="虚拟机转发端口"></p>
<a id="more"></a>
<h1 id="boot2docker数据卷问题"><a href="#boot2docker数据卷问题" class="headerlink" title="boot2docker数据卷问题"></a>boot2docker数据卷问题</h1><p>  这个就更恶心了,使用在windows下的boot2docker命令行就会报错,只有进入virtualbox 使用命令 <code>docker run -dp 8080:8080 --name test1 -v /c/Users/elick/www:/var/www elick/php</code>才可以 真是醉了<br>  <strong>需要注意的一点:</strong> boot2docker建立的虚拟机有个自启动共享目录 <code>c/Users C:\Users</code> 在虚拟机里的根目录下能看到这个目录 所以windows上的目录的根目录是/c/开始的<br><img src="/image/16-4/3.png" alt="共享目录"></p>
<h1 id="boot2docker使用总结"><a href="#boot2docker使用总结" class="headerlink" title="boot2docker使用总结"></a>boot2docker使用总结</h1><p>  从上面两点来看,虽然省略了配置vagrantfile的麻烦,但是还得去弄虚拟机从这点看,貌似还不如使用vagrant来的简单些</p>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="http://avnpc.com/pages/build-php-develop-env-by-docker" target="_blank" rel="external">Docker在PHP项目开发环境中的应用</a><br><a href="http://www.tuicool.com/articles/uYzeAnz" target="_blank" rel="external">{译} 深入理解 Docker Volume（一）</a><br><a href="http://my.oschina.net/mfk123/blog/292425" target="_blank" rel="external">Dockers 快速学习（四）Docker 容器的使用</a><br><a href="http://www.linuxdown.net/install/soft/2016/0303/4906.html" target="_blank" rel="external">Docker安装_Ubuntu 15.10 &amp; 14.04 LTS上安装和管理Docker</a><br><a href="http://blog.csdn.net/halcyonbaby/article/details/46884605" target="_blank" rel="external">Docker exec与Docker attach</a><br><a href="http://blog.chinaunix.net/uid-10915175-id-4443127.html" target="_blank" rel="external">Docker之常用命令</a><br><a href="http://www.tuicool.com/articles/7V7vYn" target="_blank" rel="external">Docker学习笔记(2)–Docker常用命令</a><br><a href="http://tech.uc.cn/?p=2726" target="_blank" rel="external">利用Docker构建开发环境</a><br><a href="http://snoopyxdy.blog.163.com/blog/static/6011744020147187542090" target="_blank" rel="external">利用docker快速部署应用</a><br><a href="http://blog.csdn.net/junjun16818/article/details/30655543" target="_blank" rel="external">Docker volume使用</a><br><a href="http://my.oschina.net/piorcn/blog/324202" target="_blank" rel="external">Docker学习—挂载本地目录</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决ln -s 软链接产生Too many levels of symbolic links错误]]></title>
      <url>http://elickzhao.github.io/2016/04/%E8%A7%A3%E5%86%B3ln%20-s%20%E8%BD%AF%E9%93%BE%E6%8E%A5%E4%BA%A7%E7%94%9FToo%20many%20levels%20of%20symbolic%20links%E9%94%99%E8%AF%AF/</url>
      <content type="html"><![CDATA[<p>今天生成软连接发生这个报错,查了一下,原来是因为使用了相对路径,改成绝对路径就没有问题了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ln</span> <span class="_">-s</span> /cygdrive/f/Vagrant /home/elick/vagrant</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>命令解析:<br>ln -s 源目录 目标目录</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在VirtualBox和Vagrant中安装Docker]]></title>
      <url>http://elickzhao.github.io/2016/04/%E5%9C%A8VirtualBox%E5%92%8CVagrant%E4%B8%AD%E5%AE%89%E8%A3%85Docker/</url>
      <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.jdon.com/artichect/docker-install.html" target="_blank" rel="external">在VirtualBox和Vagrant中安装Docker</a><br><a href="http://www.tuicool.com/articles/V36R3y" target="_blank" rel="external">OSX下使用vagrant和docker管理创建虚拟环境</a><br><a href="http://rmingwang.com/vagrant-commands-and-config.html" target="_blank" rel="external">Vagrant简介和安装配置</a><br><a href="http://ninghao.net/blog/1566" target="_blank" rel="external">使用 Vagrant 搭建本地开发环境的教程</a><br><a href="http://www.oschina.net/translate/unsuck-your-vagrant-developing-in-one-vm-with-vagrant-and-docker" target="_blank" rel="external">使用 Vagrant 和 Docker 在一个 VM 中进行开发</a><br><a href="http://cloud.51cto.com/art/201503/470256_all.htm" target="_blank" rel="external">1+1&gt;2:用Docker和Vagrant构建简洁高效开发环境</a><br><a href="http://blog.sina.com.cn/s/blog_72ef7bea0102vucz.html" target="_blank" rel="external">Vagrant运行Docker的几种方法</a><br><a href="http://www.cnblogs.com/ac1985482/p/4029315.html" target="_blank" rel="external">vagrant在windows下的使用</a><br><a href="http://www.blogjava.net/yongboy/archive/2013/08/26/403325.html" target="_blank" rel="external">服务器操作系统CoreOS初体验</a><br><a href="http://betacz.com/series/%E5%BD%93%E6%B5%81%E6%B5%AA%E8%80%85%28Vagrant%29%E9%81%87%E8%A7%81%E7%A0%81%E5%A4%B4%E5%B7%A5%E4%BA%BA%28Docker%29/" target="_blank" rel="external">‘当流浪者(Vagrant)遇见码头工人(Docker)’系列</a></p>
<a id="more"></a>
<h1 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h1><p>用boot2docker启动docker 容器一直会卡在 <code>default: Syncing folders to the host VM...</code> 看了下<a href="https://www.vagrantup.com/docs/docker/basics.html" target="_blank" rel="external">官方文档</a></p>
<blockquote>
<p>Synced folder note: Vagrant will attempt to use the “best” synced folder implementation it can. For boot2docker, this is often rsync. In this case, make sure you have rsync installed on your host machine. Vagrant will give you a human-friendly error message if it is not.</p>
</blockquote>
<p><del>这尿性是要安装一个rsync的同步软件 这鸟东西安装起来蛮麻烦的 而且基本用不到 所以不装了  毕竟就算是生产环境肯定用不到这个 linux版本 所以开发的时候还得装别的版本 以达到和生产环境同步 所以算了<br>直接搞个 CoreOS 这个试试吧 这个挺新的比较有趣</del><br>最后还是测试了rsync这个软件,因为使用CoreOS加载docker镜像 也会出现卡在同步文件夹那 所以看来问题不在boot2docker </p>
<h1 id="得到升华"><a href="#得到升华" class="headerlink" title="得到升华"></a>得到升华</h1><p><strong>我找到个方法 可以解决这个问题 但是并不是十全十美的方法</strong><br>就是屏蔽同步文件夹<br><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="number">2</span>) <span class="keyword">do</span> |config|</span><br><span class="line">  config.vm.synced_folder <span class="string">"."</span>, <span class="string">"/vagrant"</span>, disabled: <span class="literal">true</span>  <span class="meta">#这一句就是</span></span><br><span class="line">  config.vm.provider <span class="string">"docker"</span> <span class="keyword">do</span> |d|</span><br><span class="line">    d.image = <span class="string">"tknerr/baseimage-ubuntu:14.04"</span></span><br><span class="line">    d.has_ssh = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#这句是新加的</span></span><br><span class="line">    <span class="meta">#d.vagrant_machine = "dockerhost" </span></span><br><span class="line">   	<span class="meta">#d.vagrant_vagrantfile = "../coreos/Vagrantfile"</span></span><br><span class="line">    <span class="meta">#config.vm.box = "coreos-stable" </span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  config.vm.provision <span class="string">"shell"</span>, inline: <span class="string">"echo 'hello docker!'"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h2 id="惊喜发现"><a href="#惊喜发现" class="headerlink" title="惊喜发现"></a>惊喜发现</h2><p><strong>这个简直太省地方了:</strong> 利用boot2docker 加载 tknerr/baseimage-ubuntu:14.04 这个基础镜像 最后生成的虚拟机才有400M coreOS是900M多  而Homestead 已经是2.67G了<br><img src="/image/16-4/1.png" alt="hello"></p>
<p>而且使用的box也非常省 boot2docker只有20M而已</p>
<h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><p><strong>C:\Users\elick.vagrant.d</strong> 这是vagrant的根目录 最主要有两个目录</p>
<ul>
<li>boxes<br> 这个是存放box的目录,所有你下载的各种box都在这里 </li>
<li>data<br> 这个是存放host的一些信息的地方<ul>
<li>docker-host<br>  这个就是用docker,而没有加载box的时候 自动下载的boot2docker</li>
<li>machine-index<br>  存着建立多少个host和host状态的信息 就是那个index 如果在virtualbox删除了host 这里还显示可以在这里手动删了</li>
</ul>
</li>
</ul>
<p><strong>C:\Users\elick\VirtualBox VMs</strong> 就是virtualbox存放虚拟机的位置</p>
]]></content>
    </entry>
    
  
  
</search>

{"meta":{"title":"elickzhao's Blog","subtitle":"与其临渊羡鱼 不如退而结网!","description":null,"author":"elickzhao","url":"http://elickzhao.github.io","root":"/"},"pages":[{"title":"","date":"2018-02-05T14:25:04.528Z","updated":"2018-02-04T07:05:37.000Z","comments":true,"path":"404.html","permalink":"http://elickzhao.github.io/404.html","excerpt":"","text":"404 | HelloDog"},{"title":"关于老夫","date":"2016-04-15T07:57:49.000Z","updated":"2018-02-04T07:05:37.000Z","comments":false,"path":"about/index.html","permalink":"http://elickzhao.github.io/about/index.html","excerpt":"","text":"我就是我,不一样的烟火!"},{"title":"所有分类","date":"2021-09-11T16:10:04.780Z","updated":"2021-09-11T16:10:04.780Z","comments":true,"path":"categories/index.html","permalink":"http://elickzhao.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-09-11T16:15:38.056Z","updated":"2021-09-11T16:15:38.056Z","comments":true,"path":"tags/index.html","permalink":"http://elickzhao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello Hexo","slug":"Hello-Hexo","date":"2021-09-06T16:14:37.000Z","updated":"2021-09-09T16:34:44.924Z","comments":true,"path":"2021/09/Hello-Hexo/","link":"","permalink":"http://elickzhao.github.io/2021/09/Hello-Hexo/","excerpt":"","text":"你好 hexo","categories":[{"name":"测试","slug":"测试","permalink":"http://elickzhao.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://elickzhao.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"thinphp 循环嵌套if 不输出的问题","slug":"thinphp 循环嵌套if 不输出的问题","date":"2018-02-08T14:16:17.000Z","updated":"2021-09-09T16:34:45.408Z","comments":true,"path":"2018/02/thinphp 循环嵌套if 不输出的问题/","link":"","permalink":"http://elickzhao.github.io/2018/02/thinphp%20%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97if%20%E4%B8%8D%E8%BE%93%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"这个以前应该是遇到过,不过很久不用都忘记了.这次就记录下吧.免得以后没处查去. 原因很简单 当双重循环 volist 的时候, 如果做两重循环的判断.这是就不能用简写的 $vo.id 这种形式了 必须用数组的形式 $vo[&#39;id&#39;]这样就ok了 12345678910111213141516&lt;select class=&quot;lay-search&quot; name=&quot;cateid&quot; id=&quot;cateid&quot; lay-filter=&quot;cid_1&quot; lay-search lay-verify=&quot;cateid&quot;&gt; &lt;option value&gt;所有分类&lt;/option&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;volist name=&quot;cate_list&quot; id=&quot;v&quot;&gt; &lt;if condition=&quot;$v.tid eq 1&quot;&gt; &lt;optgroup label=&quot;&#123;$v.name&#125;&quot;&gt; &lt;volist name=&quot;cate_list&quot; id=&quot;vo&quot;&gt; &lt;!-- 注意这里 这里用的是数组形式 --&gt; &lt;if condition=&quot;$vo[&#x27;tid&#x27;] == $v[&#x27;id&#x27;]&quot;&gt; &lt;option value=&quot;&#123;$vo.id&#125;&quot;&gt;&#123;$vo.name&#125;&lt;/option&gt; &lt;/if&gt; &lt;/volist&gt; &lt;/optgroup&gt; &lt;/if&gt; &lt;/volist&gt;&lt;/select&gt;","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"各个浏览器隐藏滚动条","slug":"各个浏览器隐藏滚动条 ","date":"2018-02-05T15:31:03.000Z","updated":"2021-09-09T16:34:45.579Z","comments":true,"path":"2018/02/各个浏览器隐藏滚动条 /","link":"","permalink":"http://elickzhao.github.io/2018/02/%E5%90%84%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9A%90%E8%97%8F%E6%BB%9A%E5%8A%A8%E6%9D%A1%20/","excerpt":"","text":"注意:html是可以替换成别的任何类名的还有就是 火狐是只能隐藏 却不能滚动 剩下两个都可以有的说这么写 ::-webkit-scrollbar&#123;display:none&#125; 但是完全不好使至于火狐滚动的问题 以后再想办法吧 123456789101112&lt;style&gt; html &#123; /*隐藏滚动条，当IE下溢出，仍然可以滚动*/ -ms-overflow-style:none; /*火狐下隐藏滚动条*/ overflow:-moz-scrollbars-none; &#125; /*Chrome下隐藏滚动条，溢出可以透明滚动*/ html::-webkit-scrollbar&#123;width:0px&#125; //也可以这么写 ::-webkit-scrollbar&#123;width:0px&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"php格式化插件 phpcs php-cs-fixer phpmd","slug":"php格式化插件 phpcs php-cs-fixer phpmd","date":"2018-02-05T15:28:53.000Z","updated":"2021-09-09T16:34:45.386Z","comments":true,"path":"2018/02/php格式化插件 phpcs php-cs-fixer phpmd/","link":"","permalink":"http://elickzhao.github.io/2018/02/php%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%8F%92%E4%BB%B6%20phpcs%20php-cs-fixer%20phpmd/","excerpt":"使用在用IDE开发的时候,验证php代码的错误和标准格式化. 这是遇到了几个插件.在用VSCode的时候安装了 php-cs-fixer composer global require friendsofphp/php-cs-fixer这个配置很简单只要用 composer 安装 php-cs-fixer 然后配置 php.exe 的位置就可以使用了 在使用 sublime 的时候 安装了 phpcs 和 phpmd 安装也是用 composercomposer global require &quot;squizlabs/php_codesniffer=*&quot; 这个配置(php code sniffer)就繁琐点了 配置如下","text":"使用在用IDE开发的时候,验证php代码的错误和标准格式化. 这是遇到了几个插件.在用VSCode的时候安装了 php-cs-fixer composer global require friendsofphp/php-cs-fixer这个配置很简单只要用 composer 安装 php-cs-fixer 然后配置 php.exe 的位置就可以使用了 在使用 sublime 的时候 安装了 phpcs 和 phpmd 安装也是用 composercomposer global require &quot;squizlabs/php_codesniffer=*&quot; 这个配置(php code sniffer)就繁琐点了 配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186&#123; // Plugin settings // Turn the debug output on/off &quot;show_debug&quot;: false, // Which file types (file extensions), do you want the plugin to // execute for &quot;extensions_to_execute&quot;: [&quot;php&quot;], // Do we need to blacklist any sub extensions from extensions_to_execute // An example would be [&quot;twig.php&quot;] &quot;extensions_to_blacklist&quot;: [], // Execute the sniffer on file save &quot;phpcs_execute_on_save&quot;: true, // Show the error list after save. &quot;phpcs_show_errors_on_save&quot;: true, // Show the errors in the gutter &quot;phpcs_show_gutter_marks&quot;: true, // Show outline for errors &quot;phpcs_outline_for_errors&quot;: true, // Show the errors in the status bar &quot;phpcs_show_errors_in_status&quot;: true, // Show the errors in the quick panel so you can then goto line &quot;phpcs_show_quick_panel&quot;: true, // The path to the php executable. // Needed for windows, or anyone who doesn&#x27;t/can&#x27;t make phars // executable. Avoid setting this if at all possible &quot;phpcs_php_prefix_path&quot;: &quot;F:\\\\phpStudy\\\\php\\\\php-7.1.12-nts\\\\php.exe&quot;, // Options include: // - Sniffer // - Fixer // - MessDetector // - CodeBeautifier // // This will prepend the application with the path to php // Needed for windows, or anyone who doesn&#x27;t/can&#x27;t make phars // executable. Avoid setting this if at all possible &quot;phpcs_commands_to_php_prefix&quot;: [], // What color to stylise the icon // https://www.sublimetext.com/docs/3/api_reference.html#sublime.View // add_regions &quot;phpcs_icon_scope_color&quot;: &quot;comment&quot;, // PHP_CodeSniffer settings // Do you want to run the phpcs checker? &quot;phpcs_sniffer_run&quot;: true, // Execute the sniffer on file save &quot;phpcs_command_on_save&quot;: true, // It seems python/sublime cannot always find the phpcs application // If empty, then use PATH version of phpcs, else use the set value &quot;phpcs_executable_path&quot;: &quot;C:\\\\Users\\\\elick\\\\AppData\\\\Roaming\\\\Composer\\\\vendor\\\\bin\\\\phpcs.bat&quot;, // Additional arguments you can specify into the application // // Example: // &#123; // &quot;--standard&quot;: &quot;PEAR&quot;, // &quot;-n&quot; // &#125; &quot;phpcs_additional_args&quot;: &#123; &quot;--standard&quot;: &quot;PSR2&quot;, &quot;-n&quot;: &quot;&quot; &#125;, // PHP-CS-Fixer settings // Fix the issues on save &quot;php_cs_fixer_on_save&quot;: false, // Show the quick panel &quot;php_cs_fixer_show_quick_panel&quot;: false, // Path to where you have the php-cs-fixer installed &quot;php_cs_fixer_executable_path&quot;: &quot;C:\\\\Users\\\\elick\\\\AppData\\\\Roaming\\\\Composer\\\\vendor\\\\bin\\\\php-cs-fixer.bat&quot;, // Additional arguments you can specify into the application &quot;php_cs_fixer_additional_args&quot;: &#123; &#125;, // phpcbf settings // Fix the issues on save &quot;phpcbf_on_save&quot;: false, // Show the quick panel &quot;phpcbf_show_quick_panel&quot;: false, // Path to where you have the phpcbf installed &quot;phpcbf_executable_path&quot;: &quot;&quot;phpcbf_executable_path&quot;: &quot;C:\\\\Users\\\\elick\\\\AppData\\\\Roaming\\\\Composer\\\\vendor\\\\bin\\phpcbf.bat&quot;, // Additional arguments you can specify into the application // // Example: // &#123; // &quot;--level&quot;: &quot;all&quot; // &#125; &quot;phpcbf_additional_args&quot;: &#123; &quot;--standard&quot;: &quot;PSR2&quot;, &quot;-n&quot;: &quot;&quot; &#125;, // PHP Linter settings // Are we going to run php -l over the file? &quot;phpcs_linter_run&quot;: true, // Execute the linter on file save &quot;phpcs_linter_command_on_save&quot;: true, // It seems python/sublime cannot always find the php application // If empty, then use PATH version of php, else use the set value &quot;phpcs_php_path&quot;: &quot;F:\\\\phpStudy\\\\php\\\\php-7.1.12-nts\\\\php.exe&quot;, // What is the regex for the linter? Has to provide a named match for &#x27;message&#x27; and &#x27;line&#x27; &quot;phpcs_linter_regex&quot;: &quot;(?P&lt;message&gt;.*) on line (?P&lt;line&gt;\\\\d+)&quot;, // PHP Mess Detector settings // Execute phpmd &quot;phpmd_run&quot;: false, // Execute the phpmd on file save &quot;phpmd_command_on_save&quot;: true, // It seems python/sublime cannot always find the phpmd application // If empty, then use PATH version of phpmd, else use the set value &quot;phpmd_executable_path&quot;: &quot;C:\\\\Users\\\\elick\\\\AppData\\\\Roaming\\\\Composer\\\\vendor\\\\bin\\\\phpmd.bat&quot;, // Additional arguments you can specify into the application // // Example: // &#123; // &quot;codesize,unusedcode&quot; // &#125; &quot;phpmd_additional_args&quot;: &#123; &quot;codesize,unusedcode,naming&quot;: &quot;&quot; &#125;, // PHP Scheck settings // Execute scheck &quot;scheck_run&quot;: false, // Execute the scheck on file save &quot;scheck_command_on_save&quot;: false, // It seems python/sublime cannot always find the scheck application // If empty, then use PATH version of scheck, else use the set value &quot;scheck_executable_path&quot;: &quot;&quot;, // Additional arguments you can specify into the application // //Example: //&#123; // &quot;-php_stdlib&quot; : &quot;/path/to/pfff&quot;, // &quot;-strict&quot; : &quot;&quot; //&#125; &quot;scheck_additional_args&quot;: &#123; &quot;-strict&quot; : &quot;&quot; &#125;&#125; 说明说一下 phpcs php-cs-fixer phpmd 都是干什么用的 **phpcs :**该包的作用是用指定的代码规范（默认使用PEAR规范，可指定使用PSR1，PSR2或自己制定的规范）来检查代码是否符合规范 phpcbf : phpcs自带了PHP Code Beautifier（phpcbf）用来修复不规范的代码 等同于 php-cs-fixer php-cs-fixer : 修复不规范代码 作用等同于 phpcbf 只不过规则好像稍有区别 phpmd : 提示潜在的BUG, 有待改进的代码（比如过短变量名长度等）, 过于复杂的表达式, 定义但未使用的变量、方法、属性）, 使用未定义的变量 sublime-phpcs : sublime-phpcs 插件中各种功能（错误提示，代码格式化) 提供了把这些功能包在sublime中使用的界面。 参考文档PHP代码规范与质量检查工具PHPCS,PHPMD的安装与配置sublime安装PHPcs（PHPcodesniffer）代码规范提示插件MacOS Sublime Text 3 安装使用 sublime-phpcs 插件指南","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"}]},{"title":"layui表单验证 自定义验证 select验证方法","slug":"layui表单验证 自定义验证 select验证方法","date":"2018-02-04T06:28:43.000Z","updated":"2021-09-09T16:34:45.282Z","comments":true,"path":"2018/02/layui表单验证 自定义验证 select验证方法/","link":"","permalink":"http://elickzhao.github.io/2018/02/layui%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%20select%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95/","excerpt":"这个东西还真是浪费了不少时间,网上一些文章写的吧 不知道是原来版本那么做 还是以讹传讹 反正都不太好用只能大致参考下 好了 进入整体 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 注意这里 lay-filter 是监听时 或者其他操作时用的 选取用的字段 类似jq的 $(&#x27;#id&#x27;)--&gt;&lt;!-- 注意这里 lay-verify 是你自定义的验证规则名称 这个是必须 如果是简单验证 就写上预设值 就好了 --&gt;&lt;select name=&quot;city&quot; lay-filter=&quot;city&quot; lay-verify=&quot;city-verify&quot;&gt; &lt;option value=&quot;010&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;021&quot; disabled&gt;上海（禁用效果）&lt;/option&gt; &lt;option value=&quot;0571&quot; selected&gt;杭州&lt;/option&gt;&lt;/select&gt; &lt;!-- 可以是submit提交按钮 也可以是普通按钮 但是呢 必须加上 lay-submit lay-filter=&quot;*&quot; 其中 lay-submit 也是不可少的 要不就检测不到提交事件--&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; lay-submit lay-filter=&quot;*&quot; value=&quot;提交&quot;&gt;&lt;script&gt;//第一步 写自定义规则form.verify(&#123; cateid: function (value) &#123; if (value == &quot;&quot;) &#123; return &quot;必须选择一级栏目&quot;; &#125; &#125;, contact: function (value) &#123; if (value.length &lt; 4) &#123; return &#x27;内容请输入至少4个字符&#x27;; &#125; &#125;, phone: [/^1[3|4|5|7|8]\\d&#123;9&#125;$/, &#x27;手机必须11位，只能是数字！&#x27;], email: [/^[a-z0-9._%-]+@([a-z0-9-]+\\.)+[a-z]&#123;2,4&#125;$|^1[3|4|5|7|8]\\d&#123;9&#125;$/, &#x27;邮箱格式不对&#x27;]&#125;);//第二部 提交监听事件//只有这样 验证才会执行 submit(*) 就是提交按钮的 lay-filter=&quot;*&quot; 这个可以自行更改//其实回调函数 只是有其他操作要做的时候用的 如果只是验证的话 第二个参数可以不写form.on(&#x27;submit(*)&#x27;, function (data) &#123; params = data.field; //alert(JSON.stringify(params)) submit($, params); //这个是提交按钮 当验证通过后就提交 return false;&#125;)//其实可以直接这么用//form.on(&#x27;submit(*)&#x27;);&lt;/script&gt;","text":"这个东西还真是浪费了不少时间,网上一些文章写的吧 不知道是原来版本那么做 还是以讹传讹 反正都不太好用只能大致参考下 好了 进入整体 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 注意这里 lay-filter 是监听时 或者其他操作时用的 选取用的字段 类似jq的 $(&#x27;#id&#x27;)--&gt;&lt;!-- 注意这里 lay-verify 是你自定义的验证规则名称 这个是必须 如果是简单验证 就写上预设值 就好了 --&gt;&lt;select name=&quot;city&quot; lay-filter=&quot;city&quot; lay-verify=&quot;city-verify&quot;&gt; &lt;option value=&quot;010&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;021&quot; disabled&gt;上海（禁用效果）&lt;/option&gt; &lt;option value=&quot;0571&quot; selected&gt;杭州&lt;/option&gt;&lt;/select&gt; &lt;!-- 可以是submit提交按钮 也可以是普通按钮 但是呢 必须加上 lay-submit lay-filter=&quot;*&quot; 其中 lay-submit 也是不可少的 要不就检测不到提交事件--&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; lay-submit lay-filter=&quot;*&quot; value=&quot;提交&quot;&gt;&lt;script&gt;//第一步 写自定义规则form.verify(&#123; cateid: function (value) &#123; if (value == &quot;&quot;) &#123; return &quot;必须选择一级栏目&quot;; &#125; &#125;, contact: function (value) &#123; if (value.length &lt; 4) &#123; return &#x27;内容请输入至少4个字符&#x27;; &#125; &#125;, phone: [/^1[3|4|5|7|8]\\d&#123;9&#125;$/, &#x27;手机必须11位，只能是数字！&#x27;], email: [/^[a-z0-9._%-]+@([a-z0-9-]+\\.)+[a-z]&#123;2,4&#125;$|^1[3|4|5|7|8]\\d&#123;9&#125;$/, &#x27;邮箱格式不对&#x27;]&#125;);//第二部 提交监听事件//只有这样 验证才会执行 submit(*) 就是提交按钮的 lay-filter=&quot;*&quot; 这个可以自行更改//其实回调函数 只是有其他操作要做的时候用的 如果只是验证的话 第二个参数可以不写form.on(&#x27;submit(*)&#x27;, function (data) &#123; params = data.field; //alert(JSON.stringify(params)) submit($, params); //这个是提交按钮 当验证通过后就提交 return false;&#125;)//其实可以直接这么用//form.on(&#x27;submit(*)&#x27;);&lt;/script&gt; 唠叨几句 原本没打算用 layui 的验证,原本是用 jquery.validate ,可是因为 layui 改变了select外观所以根本检测不到. 这里顺便把 jquery.validate 也简单说一下吧 123456789101112131415161718$(function () &#123; $(&quot;#commentForm&quot;).validate(&#123; rules: &#123; //这一定不要忘记 有个 rules 对象 而不是把验证规则直接放里 name: &#123; minlength: &quot;2&quot;, required: true &#125;, cateid: &#123; required: true &#125;, cid: &#123; required: true, &#125; &#125;, onkeyup: false, //focusCleanup:true //当错误元素,获得焦点时,就把错误提示去掉.这个不太好,应该是失去焦点在去掉 &#125;);&#125;); 参考文档文本框，手机，邮箱，textarea等格式的验证","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"SyntaxError-> Unexpected token \"{\" 注意chrome插件","slug":"SyntaxError Unexpected token 注意chrome插件","date":"2018-02-03T12:02:20.000Z","updated":"2021-09-09T16:34:45.042Z","comments":true,"path":"2018/02/SyntaxError Unexpected token 注意chrome插件/","link":"","permalink":"http://elickzhao.github.io/2018/02/SyntaxError%20Unexpected%20token%20%E6%B3%A8%E6%84%8Fchrome%E6%8F%92%E4%BB%B6/","excerpt":"","text":"今天遇到个奇葩问题,有个js报错 结果出现位置居然在 &lt;!DOCTYPE HTML&gt; 这里. 真是凌乱了.找了半天,把整个页面都删除了,还是报错了. 感觉可能并不是自己的问题. 拿出火狐再看页面就没有错了. 后来发现居然是chrome的错 而且莫名的今天就坏了 前两天都没问题啊 可能他们这个插件更新 然后浏览器 自己就更新吧 总之就是插件的问题 把文件名扔到百度 根本查不出是啥 幸好眼尖发现了 logo 一看知道是啥插件 删掉后问题解决 其实就是没经验 英语差 chrome-extension 一看就应该知道是 插件的问题 lcbgjpbhnnjajgjlpdemhadfceacidme 这就是那个插件名 就是该死的 夜间模式 当然这次是这个出问题了 下次有可能是别的 因为在论坛里看到 有人说 有道词典 有这个问题. 所以注意下 以后遇到就看看是那个插件吧 12345678Error in event handler for (unknown): SyntaxError: Unexpected token &#123; at eval (eval at Updater.check (chrome-extension://lcbgjpbhnnjajgjlpdemhadfceacidme/js/gmWrapper.js:4:3244), &lt;anonymous&gt;:1:327) at Updater.check (chrome-extension://lcbgjpbhnnjajgjlpdemhadfceacidme/js/gmWrapper.js:4:3244) at init (chrome-extension://lcbgjpbhnnjajgjlpdemhadfceacidme/js/jquery-1.7.2.js:1:3311) at onReadyGM (chrome-extension://lcbgjpbhnnjajgjlpdemhadfceacidme/js/jquery-1.7.2.js:1:76) at Object.onInitializedGM (chrome-extension://lcbgjpbhnnjajgjlpdemhadfceacidme/js/gmWrapper.js:4:636) at Object.callbackResponse (chrome-extension://lcbgjpbhnnjajgjlpdemhadfceacidme/js/gmWrapper.js:4:331) at chrome-extension://lcbgjpbhnnjajgjlpdemhadfceacidme/js/gmWrapper.js:4:3378","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"jquery 滚动到指定元素位置","slug":"jquery 滚动到指定元素位置","date":"2018-02-02T12:56:58.000Z","updated":"2021-09-09T16:34:45.174Z","comments":true,"path":"2018/02/jquery 滚动到指定元素位置/","link":"","permalink":"http://elickzhao.github.io/2018/02/jquery%20%E6%BB%9A%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"今天做表单验证,验证后想要跳到错误位置.原本打算用 focus() 可是用了 layui 根本定位不到这也是 layui 一个很大的弊端. 于是想到根据元素来跳转. 1234567$(&#x27;html, body&#x27;).scrollTop(100); //跳到指定位置 前面的参数也可以是id//动画跳转$(&#x27;html, body&#x27;).animate(&#123; scrollTop: $(&quot;#comment2&quot;).offset().top&#125;, 1000); 但是我这个用不了动画跳转,可能是因为 iframe 的原因,高度总是不对.所以直接用了指定位置.而不是根据元素来跳转.","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"layui的 select组件二级联动","slug":"layui的 select组件二级联动","date":"2018-02-01T03:52:10.000Z","updated":"2021-09-09T16:34:45.279Z","comments":true,"path":"2018/02/layui的 select组件二级联动/","link":"","permalink":"http://elickzhao.github.io/2018/02/layui%E7%9A%84%20select%E7%BB%84%E4%BB%B6%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/","excerpt":"","text":"我自己的 因为和h-ui合用 所以有点问题 一些网上的写法不奏效 12345678910111213141516171819202122232425var form = layui.form;form.on(&#x27;select(cid_1)&#x27;, function (data) &#123; var cateid = $(&#x27;#cateid&#x27;).val(); $(&quot;cid&quot;).val(cateid); $.post(&#x27;&#123;:U(&quot;getcid&quot;)&#125;&#x27;, &#123; cateid: cateid, async :false, &#125;, function (data) &#123; if (data.catelist != &#x27;&#x27;) &#123; var htmls = &#x27;&lt;option value=&quot;&quot;&gt;二级分类&lt;/option&gt;&#x27;; var cate = data.catelist; for (var i = 0; i &lt; cate.length; i++) &#123; htmls += &#x27;&lt;option value=&quot;&#x27; + cate[i].id + &#x27;&quot;&gt;-- &#x27; + cate[i].name + &#x27;&lt;/option&gt;&#x27;; &#125; $(&#x27;#cid&#x27;).html(htmls); $(&#x27;#catedesc&#x27;).html(&#x27;&amp;nbsp;&amp;nbsp; * 必选项&#x27;); form.render(); //这里只有这么写才可以 看来某些东西冲突了 //form.render();// form.render(&#x27;select&#x27;, &#x27;cid_2&#x27;); //其他渲染方式都无法渲染出内容来 虽然 select 里已经有东西了 &#125; else &#123; $(&#x27;#cid&#x27;).html(&#x27;&lt;option value=&quot;&quot;&gt;二级分类&lt;/option&gt;&#x27;); $(&#x27;#catedesc&#x27;).html(&#x27;&amp;nbsp;&amp;nbsp; * 该分类下还没有二级分类，请先添加&#x27;); form.render(); &#125; &#125;, &quot;json&quot;); 这是别人比较简洁的写法 123456789101112131415161718192021222324//下拉框 var form = layui.form(); //lay-filter=&quot;mch_id&quot; 的值。 select()里的参数就是这个 lay-filter是放在select里的一个属性form.on(&#x27;select(mch_id)&#x27;, function(data) &#123; var mch_id = data.value; $.ajax(&#123; type:&quot;POST&quot;, url:&quot;&#123;:url(&#x27;get_store&#x27;)&#125;&quot;, dataType:&quot;json&quot;, data:&#123;&#x27;mch_id&#x27;:mch_id&#125;, success:function(e)&#123; //empty() 方法从被选元素移除所有内容 $(&quot;select[name=&#x27;store_id&#x27;]&quot;).empty(); var html = &quot;&lt;option value=&#x27;0&#x27;&gt;请选择所属门店&lt;/option&gt;&quot;; $(e).each(function (v, k) &#123; html += &quot;&lt;option value=&#x27;&quot; + k.id + &quot;&#x27;&gt;&quot; + k.username + &quot;&lt;/option&gt;&quot;; &#125;); //把遍历的数据放到select表里面 $(&quot;select[name=&#x27;store_id&#x27;]&quot;).append(html); //从新刷新了一下下拉框 form.render(&#x27;select&#x27;); //重新渲染 &#125; &#125;) &#125;) 参考文档基于 Layui form 组件的省市区级联的实现tp5与layui框架实现二级联动加分页效果","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://elickzhao.github.io/tags/JavaScript/"}]},{"title":"css文件报错Uncaught SyntaxError Unexpected token","slug":"css文件报错Uncaught SyntaxError","date":"2018-01-31T10:47:50.000Z","updated":"2021-09-09T16:34:45.140Z","comments":true,"path":"2018/01/css文件报错Uncaught SyntaxError/","link":"","permalink":"http://elickzhao.github.io/2018/01/css%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99Uncaught%20SyntaxError/","excerpt":"","text":"有时图省事 直接复制改写就会出现这个问题 所以要注意 错误原因：错误代码改成 复制粘贴害人不浅啊T_T 参考文档css文件报错Uncaught SyntaxError: Unexpected token .","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"Echarts 多表根据窗口大小自动缩放","slug":"Echarts 多表根据窗口大小自动缩放","date":"2018-01-30T14:54:50.000Z","updated":"2021-09-09T16:34:44.899Z","comments":true,"path":"2018/01/Echarts 多表根据窗口大小自动缩放/","link":"","permalink":"http://elickzhao.github.io/2018/01/Echarts%20%E5%A4%9A%E8%A1%A8%E6%A0%B9%E6%8D%AE%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E8%87%AA%E5%8A%A8%E7%BC%A9%E6%94%BE/","excerpt":"","text":"当只有一个图表的时候很简单只要这么写就搞定了 1window.onresize = orderCharts.myChart.resize; 当多个图表的时候,就会出现只有一个图表能自动缩放,这时就要这么写了. 123456window.onresize = function () &#123; orderCharts.myChart.resize(); //图表自适应窗口大小 userCharts.myChart.resize(); //图表自适应窗口大小&#125; 这样写就ok了 下面这个写法也是等效的. 12345window.addEventListener(&quot;resize&quot;, function () &#123; console.log(orderCharts); orderCharts.myChart.resize(); //图表自适应窗口大小 userCharts.myChart.resize(); //图表自适应窗口大小&#125;); 注意当一个图标的时候 resize是没有括号的, 而多个图标的时候是有括号的. 这个要小心,他们不能互换着用.用时一定要仔细.","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"Echarts","slug":"Echarts","permalink":"http://elickzhao.github.io/tags/Echarts/"}]},{"title":"jquery 获取onclick() 当前点击对象","slug":"jquery 获取onclick() 当前点击对象","date":"2018-01-29T06:41:31.000Z","updated":"2021-09-09T16:34:45.182Z","comments":true,"path":"2018/01/jquery 获取onclick() 当前点击对象/","link":"","permalink":"http://elickzhao.github.io/2018/01/jquery%20%E8%8E%B7%E5%8F%96onclick()%20%E5%BD%93%E5%89%8D%E7%82%B9%E5%87%BB%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"必须传入this. 而且在方法内使用时 记住不能用this这样就可以使用$获取当前对象了 ```js今日 function t(obj) { changeGroupBtn(obj); option.xAxis.data = dayArray; option.series[0].data = getDate(getUrl, ‘today’); myChart.setOption(option);} /============================================== 按钮组切换按钮 ==============================================/function changeGroupBtn(obj) { $(obj).siblings().removeClass(“btn-primary”).addClass(“btn-default”); //同胞元素 $(obj).removeClass(“btn-default”).addClass(“btn-primary”);}/===== End of 按钮组切换按钮 ======/ 参考文档onclick中，获取不了$(this)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"通过ajax给js成员变量赋值问题","slug":"通过ajax给js成员变量赋值问题","date":"2018-01-28T14:57:37.000Z","updated":"2021-09-09T16:34:45.752Z","comments":true,"path":"2018/01/通过ajax给js成员变量赋值问题/","link":"","permalink":"http://elickzhao.github.io/2018/01/%E9%80%9A%E8%BF%87ajax%E7%BB%99js%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98/","excerpt":"","text":"12345678910111213141516function getDate(url) &#123; var result; $.ajax(&#123; type: &#x27;GET&#x27;, async :false,//取消异步 否则result赋值失败 url: &#x27;/index.php/Admin/Page/orderChartsData.html&#x27;, success: function (res) &#123; //console.log(res); result = res; &#125;, error: function (e) &#123; console.log(e); &#125; &#125;); return result;&#125; 参考文档通过ajax给js成员变量赋值问题","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"THINKPHP 清空数据缓存方法","slug":"THINKPHP 清空数据缓存方法","date":"2018-01-26T14:37:48.000Z","updated":"2021-09-09T16:34:45.048Z","comments":true,"path":"2018/01/THINKPHP 清空数据缓存方法/","link":"","permalink":"http://elickzhao.github.io/2018/01/THINKPHP%20%E6%B8%85%E7%A9%BA%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95/","excerpt":"","text":"12345$cache = new \\Think\\Cache;//第一个参数为 缓存类型 这里是从配置里读取 第二个参数为清理的文件夹 因为默认清理的是 Temp 这里修改成Cacheecho $cache-&gt;getInstance(C(&#x27;DATA_CACHE_TYPE&#x27;), [&#x27;temp&#x27;=&gt;CACHE_PATH])-&gt;clear();//如果是清理Temp 直接不用参数就可以用了 不用这么麻烦//$cache-&gt;getInstance()-&gt;clear(); 参考文档THINKPHP 清空数据缓存方法","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"momentjs 自己使用例子","slug":"momentjs 自己使用例子","date":"2018-01-21T15:32:00.000Z","updated":"2021-09-09T16:34:45.306Z","comments":true,"path":"2018/01/momentjs 自己使用例子/","link":"","permalink":"http://elickzhao.github.io/2018/01/momentjs%20%E8%87%AA%E5%B7%B1%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90/","excerpt":"","text":"下面例子是我用到的一些方法,其他的看文档吧 全的很这里主要说下怎么使用中文显示按下面引入 而且顺序不能变 还有就是注意moment引入的js 不是原版那个 12https://cdn.bootcss.com/moment.js/2.20.1/moment-with-locales.min.jshttps://cdn.bootcss.com/moment.js/2.20.1/locale/zh-cn.js //这是例子 momentjs中文网","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"关于微信退款出现错误代码 52的解决方法","slug":"关于微信退款出现错误代码 52的解决方法","date":"2018-01-19T14:08:42.000Z","updated":"2021-09-09T16:34:45.542Z","comments":true,"path":"2018/01/关于微信退款出现错误代码 52的解决方法/","link":"","permalink":"http://elickzhao.github.io/2018/01/%E5%85%B3%E4%BA%8E%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BE%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%2052%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"在做微信支付的过程中，微信支付可以实现，然后微信退款总是出现错误代码:52。最后发现证书路径为相对路径。 解决方法：扎到文件Wxpay.api.php。在该文件中找到 “postXmlCurl”这个方法，然后将证书路径修改为绝对路径即可。 下面说明修改内容：将证书路径替换为绝对路径： 123//使用证书：cert 与 key 分别属于两个.pem文件 curl_setopt($ch, CURLOPT_SSLCERT, WxPayConfig::SSLCERT_PATH); curl_setopt($ch, CURLOPT_SSLKEY, WxPayConfig::SSLKEY_PATH); 修改为(这里的代码指的是PHP代码，如果是其他语言请进行相应的修改)： 123curl_setopt($ch,CURLOPT_SSLCERT, dirname(__FILE__).&#x27;/&#x27;.WxPayConfig::SSLCERT_PATH); curl_setopt($ch,CURLOPT_SSLKEY, dirname(__FILE__).&#x27;/&#x27;.WxPayConfig::SSLKEY_PATH); 用的是 WeiXinpay 这个插件 修改的文件是 lib/WxPay.Api.php","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"}]},{"title":"小程序地图API使用","slug":"小程序地图API使用","date":"2018-01-17T14:47:46.000Z","updated":"2021-09-09T16:34:45.622Z","comments":true,"path":"2018/01/小程序地图API使用/","link":"","permalink":"http://elickzhao.github.io/2018/01/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9C%B0%E5%9B%BEAPI%E4%BD%BF%E7%94%A8/","excerpt":"","text":"这次用的比较简单,因为企业名片的项目.需要地图显示标点.这里只用到了 wx.openLocation 其他几个API也比较简单这里这个会直接打开坐标点,并会标注名车和地址 还会有导航去这里. 12345678910getlocation: function () &#123; var that = this; wx.openLocation(&#123; latitude: that.data.latitude, //经度 longitude: that.data.longitude, //纬度 name: that.data.name, address: that.data.address, scale: 28 &#125;)&#125; 参考文档微信小程序开发之真机测试 地图定位 map API 无法获取当前位置的问题微信小程序之地图功能百度地图微信小程序JavaScript API v1.0","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"在改写H-UI.admin所用到的插件","slug":"在改写H-UI.admin所用到的插件","date":"2018-01-16T15:19:40.000Z","updated":"2021-09-09T16:34:45.600Z","comments":true,"path":"2018/01/在改写H-UI.admin所用到的插件/","link":"","permalink":"http://elickzhao.github.io/2018/01/%E5%9C%A8%E6%94%B9%E5%86%99H-UI.admin%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E6%8F%92%E4%BB%B6/","excerpt":"","text":"插件名 说明 sweetAlert Alert 美化插件 sweetAlert2 这是2代 效果更华丽些 layer 弹出框 这个和上面的 alert其实效果是差不多的 artDialog 这个是我好久以前就知道的,都忘记了 居然今天又看到了 tipDialog 这个居然不知道 原作者在哪里找到的 网上搜不到 也许自己写的? Simple Switch Simple Switch一个简单的开关 样子很好看适合用在pc端 bootstrapSwitch 另一个开关 样子和bootstrap比较统一 jQuery Timers jquery的一个定时器 这里有个简介事例这个中文的比较清楚","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"mysql查找固定时间端数据 本周 上周...","slug":"mysql查找固定时间端数据 本周 上周","date":"2018-01-15T14:29:06.000Z","updated":"2021-09-09T16:34:45.314Z","comments":true,"path":"2018/01/mysql查找固定时间端数据 本周 上周/","link":"","permalink":"http://elickzhao.github.io/2018/01/mysql%E6%9F%A5%E6%89%BE%E5%9B%BA%E5%AE%9A%E6%97%B6%E9%97%B4%E7%AB%AF%E6%95%B0%E6%8D%AE%20%E6%9C%AC%E5%91%A8%20%E4%B8%8A%E5%91%A8/","excerpt":"","text":"mysql有很多关于时间截取的方法,不过呢数据格式必须date形式的,不过我现在用的int保存时间戳的方式.以前记得好像date形式有什么缺点 现在给忘记了 以后遇到再记录下吧. 函数类似这种 这次是没法测试 以后数据库可以参考下 好像这种更优化一些 1SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 5 DAY) AS SubtractDate FROM Orders MySQL DATE_SUB() 函数mysql获取昨天的时间MySQL查询本周、上周、本月、上个月份数据的sql代码","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"http://elickzhao.github.io/tags/mysql/"}]},{"title":"ECharts x坐标系使用 time 形式","slug":"ECharts x坐标系使用 time 形式","date":"2018-01-14T14:50:28.000Z","updated":"2021-09-09T16:34:44.896Z","comments":true,"path":"2018/01/ECharts x坐标系使用 time 形式/","link":"","permalink":"http://elickzhao.github.io/2018/01/ECharts%20x%E5%9D%90%E6%A0%87%E7%B3%BB%E4%BD%BF%E7%94%A8%20time%20%E5%BD%A2%E5%BC%8F/","excerpt":"","text":"xAxis.type string[ default: ‘category’ ]坐标轴类型。可选：‘value’ 数值轴，适用于连续数据。‘category’ 类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据。‘time’ 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。‘log’ 对数轴。适用于对数数据。 123一般情况都会使用`category` 因为比较简单 直接传入数据就能用**例如这样** option = { title: { text: ‘未来一周气温变化’, subtext: ‘纯属虚构’ }, tooltip: { trigger: ‘axis’ }, toolbox: { show: true, feature: { dataZoom: { yAxisIndex: ‘none’ }, dataView: {readOnly: false}, magicType: {type: [‘line’, ‘bar’]}, restore: {}, saveAsImage: {} } }, xAxis: { type: ‘category’, boundaryGap: false, data: [‘周一’,’周二’,’周三’,’周四’,’周五’,’周六’,’周日’] }, yAxis: { type: ‘value’, axisLabel: { formatter: ‘{value} °C’ } }, series: [ { name:’最高气温’, type:’line’, data:[11, 11, 15, 13, 12, 13, 10], markPoint: { data: [ {type: ‘max’, name: ‘最大值’}, {type: ‘min’, name: ‘最小值’} ] }, markLine: { data: [ {type: ‘average’, name: ‘平均值’} ] } } ]}; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!--more--&gt;但是time呢 他的文档里没有说的特别清楚 这里给出个例子传入的数据必须带一个时间的item 而且好像光是日期还不行 必须是完整的还有就是必须是value字段 好像是这个样子```jsvar data = [ &#123;value:[&#x27;2016/12/18 6:38:08&#x27;, 80]&#125;, &#123;value:[&#x27;2016/12/18 16:18:18&#x27;, 60]&#125;, &#123;value:[&#x27;2016/12/18 19:18:18&#x27;, 90]&#125; ]; option = &#123; title: &#123; text: &#x27;未来一周气温变化&#x27;, subtext: &#x27;纯属虚构&#x27; &#125;, tooltip: &#123; trigger: &#x27;axis&#x27; &#125;, toolbox: &#123; show: true, feature: &#123; dataZoom: &#123; yAxisIndex: &#x27;none&#x27; &#125;, dataView: &#123;readOnly: false&#125;, magicType: &#123;type: [&#x27;line&#x27;, &#x27;bar&#x27;]&#125;, restore: &#123;&#125;, saveAsImage: &#123;&#125; &#125; &#125;, xAxis: &#123; type: &#x27;time&#x27;, boundaryGap: false, &#125;, yAxis: &#123; type: &#x27;value&#x27;, axisLabel: &#123; formatter: &#x27;&#123;value&#125; °C&#x27; &#125; &#125;, series: [ &#123; name:&#x27;最高气温&#x27;, type:&#x27;line&#x27;, data:data, markPoint: &#123; data: [ &#123;type: &#x27;max&#x27;, name: &#x27;最大值&#x27;&#125;, &#123;type: &#x27;min&#x27;, name: &#x27;最小值&#x27;&#125; ] &#125;, markLine: &#123; data: [ &#123;type: &#x27;average&#x27;, name: &#x27;平均值&#x27;&#125; ] &#125; &#125; ]&#125;; 好了更多具体使用看文档 他的文档还是比较详细的 参考文档Echarts文档ECharts显示24小时时间数据的一种办法","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"TP 3.2加载第三方库文件","slug":"TP 3.2加载第三方库文件","date":"2018-01-13T11:10:37.000Z","updated":"2021-09-09T16:34:45.050Z","comments":true,"path":"2018/01/TP 3.2加载第三方库文件/","link":"","permalink":"http://elickzhao.github.io/2018/01/TP%203.2%E5%8A%A0%E8%BD%BD%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%96%87%E4%BB%B6/","excerpt":"","text":"今天用到Carbon这个时间类,不过TP3.2不使用 composer 所以加载起来比较费劲.按官方说法放在 /thinkphp/Library 下的都可以自动加载.其实呢,需要命名空间与目录一致,而且文件名必须是 *.class.php 这大多数第三方库是满足不了的所以只好手动加载了 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Admin\\Controller;use Think\\Controller;//import(&quot;Vendor.Carbon.Carbon&quot;); //这两种加载文件的方法都可以vendor(&quot;Carbon.Carbon&quot;);use Carbon\\Carbon; //使用了 Carbon 命名空间 那么下面使用的时候 就不需要每次都加了class IndexController extends PublicController&#123; //*********************************** // iframe式显示菜单和index页 //********************************** public function index() &#123; //这是另一个第三方库 微信支付 //不过呢 这个库比较早 没有命名空间 //所以使用的时候 必须用\\空间 也就是 \\WxPayUnifiedOrder() 这种形式使用 //这是需要注意的地方 没有命名空间都得这么使用 $b = vendor(&quot;wxpay.wxpay&quot;); $input = new \\WxPayUnifiedOrder(); dump($input); printf(&quot;Now: %s&quot;, Carbon::now()); //这里因为上面使用 use 可以这么简写 //如果头部没有用use的话,在这里使用必须写完整的命名空间才行 vendor(&quot;Carbon.Carbon&quot;); printf(&quot;Now: %s&quot;, \\Carbon\\Carbon::now()); exit(); ..... &#125;&#125;","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"微信小程序使用自定义icon","slug":"微信小程序使用自定义icon","date":"2018-01-12T15:53:39.000Z","updated":"2021-09-09T16:34:45.650Z","comments":true,"path":"2018/01/微信小程序使用自定义icon/","link":"","permalink":"http://elickzhao.github.io/2018/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89icon/","excerpt":"","text":"使用阿里巴巴的iconfont最简单.直接下载下来,把压缩包里的css改成wxss 引用就能用了 wxss 12345678@import &quot;/dist/weui-grid.wxss&quot;;/* 字体加粗 */.font-bold &#123; font-weight: 700;&#125;.... wxml 1&lt;view class=&quot;iconfont icon-map zan-c-gray&quot;&gt;&lt;/view&gt; 参考文档微信小程序如何引用iconfont图标Ionic使用Iconfont-阿里巴巴矢量图标库","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"头部固定的布局","slug":"头部固定的布局","date":"2018-01-09T13:23:03.000Z","updated":"2021-09-09T16:34:45.605Z","comments":true,"path":"2018/01/头部固定的布局/","link":"","permalink":"http://elickzhao.github.io/2018/01/%E5%A4%B4%E9%83%A8%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%B8%83%E5%B1%80/","excerpt":"需要做一个滚动后,头部固定的页面这个用到 css 里的 fixed 就可以实现了 1234567891011.headDiv &#123; position: fixed; /*固定定位*/ top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 60px; border: 1px solid blue;&#125;","text":"需要做一个滚动后,头部固定的页面这个用到 css 里的 fixed 就可以实现了 1234567891011.headDiv &#123; position: fixed; /*固定定位*/ top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 60px; border: 1px solid blue;&#125; 然后监听页面滚动, 当滚动到一定数值时 切换logo 并改变 底的颜色即可这是zanUI 官网的效果 这里拿来代码说明一下滚动前的 1234567891011121314.zanui-nav &#123; z-index: 3; height: 80px; position: fixed; width: 100%; min-width: 1024px; background-repeat: no-repeat; background-position: 20px; background: rgba(0,0,0,.2) url(https://img.yzcdn.cn/v2/image/youzanyun/zanui/pc/pc_shouye_logo1_v2.png) no-repeat 20px/76px 20px; background: #000 url(https://img.yzcdn.cn/v2/image/youzanyun/zanui/pc/pc_shouye_logo1_v2.png) no-repeat 20px/76px 20px\\0; -webkit-transition: all 1.2s; -moz-transition: all 1.2s; transition: all 1.2s;&#125; 滚动后的 12345678910111213141516171819202122232425//这里多加了个类.zanui-nav.scrolled &#123; -webkit-box-shadow: 0 1px 4px rgba(0,0,0,.1); box-shadow: 0 1px 4px rgba(0,0,0,.1); background: #fbfbfb url(https://img.yzcdn.cn/v2/image/youzanyun/zanui/pc/pc_shouye_logo2_v2.png) no-repeat 20px/76px 20px; -webkit-transition: all 1.2s; -moz-transition: all 1.2s; transition: all 1.2s;&#125;.zanui-nav &#123; z-index: 3; height: 80px; position: fixed; width: 100%; min-width: 1024px; background-repeat: no-repeat; background-position: 20px; background: rgba(0,0,0,.2) url(https://img.yzcdn.cn/v2/image/youzanyun/zanui/pc/pc_shouye_logo1_v2.png) no-repeat 20px/76px 20px; background: #000 url(https://img.yzcdn.cn/v2/image/youzanyun/zanui/pc/pc_shouye_logo1_v2.png) no-repeat 20px/76px 20px\\0; -webkit-transition: all 1.2s; -moz-transition: all 1.2s; transition: all 1.2s;&#125; 参考文档web知识-平时工作生活中的总结基于flex弹性布局实现“头尾固定，中间滚动”的页面（纯CSS实现）如何优雅的实现内联滚动条（前端底部固定方法 ）","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"},{"name":"小程序","slug":"小程序","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"js的Object.assign()复制属性详解","slug":"js的Object.assign()复制属性详解","date":"2018-01-08T15:39:33.000Z","updated":"2021-09-09T16:34:45.232Z","comments":true,"path":"2018/01/js的Object.assign()复制属性详解/","link":"","permalink":"http://elickzhao.github.io/2018/01/js%E7%9A%84Object.assign()%E5%A4%8D%E5%88%B6%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/","excerpt":"简单描述Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 1234Object.assign(target, ...sources)//target 目标对象//...sources 源对象//返回 目标对象 描述: 如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 String类型和 Symbol 类型的属性都会被拷贝。 在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。 注意，Object.assign 会跳过那些值为 null 或 undefined 的源对象。","text":"简单描述Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 1234Object.assign(target, ...sources)//target 目标对象//...sources 源对象//返回 目标对象 描述: 如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 String类型和 Symbol 类型的属性都会被拷贝。 在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。 注意，Object.assign 会跳过那些值为 null 或 undefined 的源对象。 实例简单实例 123var obj = &#123; a: 1 &#125;;var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125; 深拷贝问题针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。 12345678910111213141516171819202122232425262728function test() &#123; &#x27;use strict&#x27;; let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj2 = Object.assign(&#123;&#125;, obj1); console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj1.a = 1; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj2.a = 2; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125; obj2.b.c = 3; //主要问题在这里 从这里看出对象是个引用 而不同于其他属性 所以不是深度拷贝 console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125; // Deep Clone obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj3 = JSON.parse(JSON.stringify(obj1)); //这是深度拷贝 也就是个完全复制 建立个新的 obj1.a = 4; obj1.b.c = 4; console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;&#125;test(); 合并对象 123456789var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3); //这样使用的话 是会把第一个参数当成目标对象了console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。console.log(o2); // &#123;b: 2 &#125;, 只是第一个改变了console.log(o3); // &#123;c: 3 &#125;, 只是第一个改变了 合并具有相同属性的对象 123456var o1 = &#123; a: 1, b: 1, c: 1 &#125;;var o2 = &#123; b: 2, c: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(&#123;&#125;, o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125; 更多内容参考下面 MDN文档吧 那里实在是太全了 没必要都复制一遍了 参考文档MDN Object.assign()javascript之Object.assign()痛点","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"小程序转发功能","slug":"小程序转发功能","date":"2018-01-07T11:05:16.000Z","updated":"2021-09-09T16:34:45.628Z","comments":true,"path":"2018/01/小程序转发功能/","link":"","permalink":"http://elickzhao.github.io/2018/01/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD/","excerpt":"","text":"小程序有两种转发形式,一种是右上角点击转发,另一种是通过按钮转发. 右上角形式 1234567891011121314151617181920212223242526272829303132//onload里设置这句 就会接收shareTicket 当然没有也会转发wx.showShareMenu(&#123; withShareTicket: true&#125;)//只要在js定义了 onShareAppMessage 那么页面的右上角就会出现转发按钮 否则是没有转发的onShareAppMessage: function () &#123; return &#123; title: &#x27;自定义转发标题&#x27;, path: &#x27;/page/user?id=123&#x27;, //这个可以不设 不设的话就是当前页面地址 success: function(res) &#123; var shareTickets = res.shareTickets; if (shareTickets.length == 0) &#123; return false; &#125; // 这个是接收分享到所在群的的信息 这个需要解密等一些操作 下面只是简单演示 这个必须配合上面的 withShareTicket: true // 但是这个有啥用现在还没想清楚. wx.getShareInfo(&#123; shareTicket: shareTickets[0]; success: function(res)&#123; var encryptedData = res.encryptedData; var iv = res.iv; &#125; &#125;) &#125;, fail: function(res) &#123; // 转发失败 &#125; &#125; &#125; 按钮形式 123456789//在wxml页面定义button&lt;button open-type=&quot;share&quot;&gt; &quot;转发&quot;&lt;/button&gt;//点击就会触发js的 onShareAppMessage()//就会达到转发的效果onShareAppMessage: function () &#123; ....&#125; 参考文档微信小程序之转发流程详解微信小程序页面内转发 按钮 转发微信小程序 转发功能的实现","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序下拉刷新及上滑加载更多","slug":"小程序下拉刷新及上滑加载更多","date":"2018-01-05T14:57:42.000Z","updated":"2021-09-09T16:34:45.607Z","comments":true,"path":"2018/01/小程序下拉刷新及上滑加载更多/","link":"","permalink":"http://elickzhao.github.io/2018/01/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%8F%8A%E4%B8%8A%E6%BB%91%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A/","excerpt":"参考了下别的文章,很多人都用scroll-view来做.当然这完全可以,而且也是比较简单,但是效果不是那么特别满意.因为是使用的是触及底边才加载,看上去不是那么美.我希望的效果是,距离底边一段距离就开始加载了.仔细研究了小程序的文档,有了方案. 但是这里先讲一下 scroll-view 容易跌入的坑. scroll-view 有几个常用方法 123456789101112131415161718192021bindscrolltoupper //滚动顶边触发bindscrolltolower //滚动到底边触发//这两个比较特殊 因为有滚动方向问题 向下滚动只会触发 距离底边 向上滚动只能触发距离顶边//于是就不是我想要的效果了 我想的是 向下滚动距离多少 就触发一个效果 所以只能用下面的 bindscroll//还有就是他们触发的是 bindscrolltoupper和bindscrolltolower 所绑定的事件 而没有自己的方法upper-threshold //距离顶边触发 参数是数字lower-threshold //距离底边触发 参数是数字//这个比较简单了 实时监听滚动距离bindscroll//wxml中使用中的事例//&lt;scroll-view scroll-y style=&quot;height: 200px;&quot; bindscrolltoupper=&quot;upper&quot; bindscrolltolower=&quot;lower&quot; bindscroll=&quot;scroll&quot; scroll-into-view=&quot;&#123;&#123;toView&#125;&#125;&quot; scroll-top=&quot;&#123;&#123;scrollTop&#125;&#125;&quot; upper-threshold=&quot;1000&quot; lower-threshold=&quot;500&quot;&gt; //其他一些不主要的方法scroll-into-view //滚动到指定id元素的位置scroll-top //滚动到距离头部的指定位置","text":"参考了下别的文章,很多人都用scroll-view来做.当然这完全可以,而且也是比较简单,但是效果不是那么特别满意.因为是使用的是触及底边才加载,看上去不是那么美.我希望的效果是,距离底边一段距离就开始加载了.仔细研究了小程序的文档,有了方案. 但是这里先讲一下 scroll-view 容易跌入的坑. scroll-view 有几个常用方法 123456789101112131415161718192021bindscrolltoupper //滚动顶边触发bindscrolltolower //滚动到底边触发//这两个比较特殊 因为有滚动方向问题 向下滚动只会触发 距离底边 向上滚动只能触发距离顶边//于是就不是我想要的效果了 我想的是 向下滚动距离多少 就触发一个效果 所以只能用下面的 bindscroll//还有就是他们触发的是 bindscrolltoupper和bindscrolltolower 所绑定的事件 而没有自己的方法upper-threshold //距离顶边触发 参数是数字lower-threshold //距离底边触发 参数是数字//这个比较简单了 实时监听滚动距离bindscroll//wxml中使用中的事例//&lt;scroll-view scroll-y style=&quot;height: 200px;&quot; bindscrolltoupper=&quot;upper&quot; bindscrolltolower=&quot;lower&quot; bindscroll=&quot;scroll&quot; scroll-into-view=&quot;&#123;&#123;toView&#125;&#125;&quot; scroll-top=&quot;&#123;&#123;scrollTop&#125;&#125;&quot; upper-threshold=&quot;1000&quot; lower-threshold=&quot;500&quot;&gt; //其他一些不主要的方法scroll-into-view //滚动到指定id元素的位置scroll-top //滚动到距离头部的指定位置 好了说会本体 小程序里有个设置 可以使 view 能监听滚动到底边的距离.但是这里需要在 页面的 json 里设置开启 123456789101112131415//这个可以全局设置 也可以单个页面设置&#123; &quot;enablePullDownRefresh&quot;: true, //开启下拉刷新 &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, //下拉刷新底部也没的颜色 &quot;backgroundTextStyle&quot;: &quot;dark&quot;, //字体样式 只有 dark和light &quot;onReachBottomDistance&quot;: 60 // 就是这个了 监听距离底边多少px 执行方法 onReachBottom&#125;-----------------------------------------------//然后在js里写方法就可以了 onReachBottom: function () &#123; console.log(&quot;触底效果!&quot;) &#125;, 参考文档 微信小程序之加载更多（分页加载）实例 —— 微信小程序实战系列（2） 微信小程序入门五上滑加载下拉刷新","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序使用模块","slug":"小程序使用模块","date":"2017-12-31T14:56:44.000Z","updated":"2021-09-09T16:34:45.618Z","comments":true,"path":"2017/12/小程序使用模块/","link":"","permalink":"http://elickzhao.github.io/2017/12/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97/","excerpt":"模块定义 123456789// common.jsfunction sayHello(name) &#123; console.log(`Hello $&#123;name&#125; !`)&#125;function sayGoodbye(name) &#123; console.log(`Goodbye $&#123;name&#125; !`)&#125;//需要用module.exports暴露出来module.exports.sayHello = sayHello 模块使用 123456789var common = require(&#x27;common.js&#x27;)Page(&#123; helloMINA: function() &#123; common.sayHello(&#x27;MINA&#x27;) &#125;, goodbyeMINA: function() &#123; common.sayGoodbye(&#x27;MINA&#x27;) &#125;&#125;) 以上是最简单的使用方法.这个方法有个好处就是那个函数知道出自那里.下面的方法更现代一些,不过有个问题是,方法出自那里不会那么清晰.所以用的时候看着办吧.","text":"模块定义 123456789// common.jsfunction sayHello(name) &#123; console.log(`Hello $&#123;name&#125; !`)&#125;function sayGoodbye(name) &#123; console.log(`Goodbye $&#123;name&#125; !`)&#125;//需要用module.exports暴露出来module.exports.sayHello = sayHello 模块使用 123456789var common = require(&#x27;common.js&#x27;)Page(&#123; helloMINA: function() &#123; common.sayHello(&#x27;MINA&#x27;) &#125;, goodbyeMINA: function() &#123; common.sayGoodbye(&#x27;MINA&#x27;) &#125;&#125;) 以上是最简单的使用方法.这个方法有个好处就是那个函数知道出自那里.下面的方法更现代一些,不过有个问题是,方法出自那里不会那么清晰.所以用的时候看着办吧. 这个举例是多模块一起引入 a模块 a.js 123456//发现个情况 这里方法没有使用对象, 可能是简单只有一个方法的模块可以这样定义 这个还没验证module.exports = &#123; function_a(content = &#x27;&#x27;)&#123; console.log(&quot;function_a&quot;+content); &#125;&#125;; ** b模块 b.js** 1234567891011121314151617var module_b = &#123; //这里可能存在一个问题,重名的问题,如果以简单引入使用的方法是没问题的, //不过这次的引入是直接引入到参数里使用this直接使用,所以重名可能会出现问题 //这个有待验证 function_a:function(content = &#x27;&#x27;)&#123; console.log(&quot;function_a&quot;+content); &#125;, function_b:function(content = &#x27;&#x27;)&#123; console.log(&quot;function_b&quot;+content); &#125;, function_c:function(content = &#x27;&#x27;)&#123; console.log(&quot;function_c&quot;+content); &#125;,&#125;;module.exports = module_b; 模块工厂 modules.js 123456//这可以多个模块组合使用了,而不用在页面引入一大堆//exports 是 module.exports 的一个引用,但因为存在差异,在这种简单的页面可以使用.//复杂的定义还是使用module.exportsexports.a = require(&#x27;./a.js&#x27;);exports.b = require(&#x27;./b.js&#x27;); 使用模块 1234567891011121314151617var modules = require(&#x27;modules.js&#x27;);//Object.assign(&#123;&#125;,...,...) 使用扩展参数的方式,增加方法Page(Object.assign(&#123;&#125;, modules.a,modules.b, &#123; data: &#123; ... &#125;, onLoad: function () &#123; //因为使用了扩展参数的方式,所以直接用this的方法调用 //不过这里就有上面说道 重名的问题 还有就是从那里引入来的模糊问题 this.function_a(&#x27;我是a模块输出&#x27;); //~~谁输出呢? 会被b模块覆盖么?~~ // 会覆盖通过Object.assign()文档里的说明了这些 参考文档在下面 this.function_b(&#x27;我是b模块输出&#x27;); ... &#125; ...&#125;)); 新心得如果是小程序的自带的监听函数,也可以使用模块写法.也会在页面加载后就持续监听.不过只能用上面第二种写法,就是扩展参数的办法才行,这也是这种方式的优势吧. 123456789101112131415161718192021222324252627282930313233343536373839404142......./** * MD5加密 */function doMD5Encode(toEncode) &#123; return MD5Encode.hexMD5(toEncode);&#125;function onReachBottom () &#123; //如果有更多商品就使用加载功能,否则就不加在 if (this.data.more) &#123; this.getMore(); &#125; else &#123; //console.log(this.data.more); return; &#125; //console.log(&quot;触底效果!&quot;)&#125;module.exports = &#123; isStringEmpty: isStringEmpty, sentHttpRequestToServer: sentHttpRequestToServer, mapToJson: mapToJson, toastSuccess: toastSuccess, doWechatPay: doWechatPay, onReachBottom: onReachBottom&#125;//-------使用var common = require(&#x27;../../utils/common.js&#x27;);Page(Object.assign(&#123;&#125;, common,&#123; .....&#125;)); //这里要注意下,这次不是工厂那样的写法,所以不能 Page(Object.assign(&#123;&#125;, common.onReachBottom ,&#123; 这样写. 参考文档MDN Web Docs Object.assign() Object.assign(target, …sources)参数target: 目标对象。sources: 源对象。 返回值:目标对象 描述:如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小程序","slug":"小程序","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序动画效果使用","slug":"小程序动画效果使用 ","date":"2017-12-28T12:16:40.000Z","updated":"2021-09-09T16:34:45.620Z","comments":true,"path":"2017/12/小程序动画效果使用 /","link":"","permalink":"http://elickzhao.github.io/2017/12/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E4%BD%BF%E7%94%A8%20/","excerpt":"这个动画能实现基本功能.不过还是挺费劲的.但现在还有个问题没有解决.就是循环的时候 每个items加上动画 如何让他单个执行 这个还没想好 js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Page(&#123; data: &#123; markers: [&#123; id: 0, latitude: 28.0369400000, longitude: 120.6492300000, width: 20, height: 20, title: &quot;欧美佳化妆美甲祛斑纹绣店&quot; &#125;], animationData: &#123;&#125; &#125;, onLoad: function () &#123; // 页面渲染完成 //实例化一个动画 this.animation = wx.createAnimation(&#123; // 动画持续时间，单位ms，默认值 400 duration: 1000, /** * http://cubic-bezier.com/#0,0,.58,1 * linear 动画一直较为均匀 * ease 从匀速到加速在到匀速 * ease-in 缓慢到匀速 * ease-in-out 从缓慢到匀速再到缓慢 * * http://www.tuicool.com/articles/neqMVr * step-start 动画一开始就跳到 100% 直到动画持续时间结束 一闪而过 * step-end 保持 0% 的样式直到动画持续时间结束 一闪而过 */ timingFunction: &#x27;ease&#x27;, // 延迟多长时间开始 delay: 100, /** * 以什么为基点做动画 效果自己演示 * left,center right是水平方向取值，对应的百分值为left=0%;center=50%;right=100% * top center bottom是垂直方向的取值，其中top=0%;center=50%;bottom=100% */ transformOrigin: &#x27;center top 0&#x27;, success: function (res) &#123; console.log(res) &#125; &#125;); setTimeout(function () &#123; this.rotate(); &#125;.bind(this), 200) &#125;, /** * 放大显示 */ rotate: function () &#123; //放大显示后并恢复 // //现在唯一的问题是 如果在循环里绑定相同的动画 却是单一执行呢 唉.... // this.animation.rotate(150).step() this.animation.opacity(1).scale(1.5, 1.5).step().scale(1, 1).step(); this.setData(&#123; //输出动画 animation: this.animation.export() &#125;) &#125;&#125;)","text":"这个动画能实现基本功能.不过还是挺费劲的.但现在还有个问题没有解决.就是循环的时候 每个items加上动画 如何让他单个执行 这个还没想好 js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Page(&#123; data: &#123; markers: [&#123; id: 0, latitude: 28.0369400000, longitude: 120.6492300000, width: 20, height: 20, title: &quot;欧美佳化妆美甲祛斑纹绣店&quot; &#125;], animationData: &#123;&#125; &#125;, onLoad: function () &#123; // 页面渲染完成 //实例化一个动画 this.animation = wx.createAnimation(&#123; // 动画持续时间，单位ms，默认值 400 duration: 1000, /** * http://cubic-bezier.com/#0,0,.58,1 * linear 动画一直较为均匀 * ease 从匀速到加速在到匀速 * ease-in 缓慢到匀速 * ease-in-out 从缓慢到匀速再到缓慢 * * http://www.tuicool.com/articles/neqMVr * step-start 动画一开始就跳到 100% 直到动画持续时间结束 一闪而过 * step-end 保持 0% 的样式直到动画持续时间结束 一闪而过 */ timingFunction: &#x27;ease&#x27;, // 延迟多长时间开始 delay: 100, /** * 以什么为基点做动画 效果自己演示 * left,center right是水平方向取值，对应的百分值为left=0%;center=50%;right=100% * top center bottom是垂直方向的取值，其中top=0%;center=50%;bottom=100% */ transformOrigin: &#x27;center top 0&#x27;, success: function (res) &#123; console.log(res) &#125; &#125;); setTimeout(function () &#123; this.rotate(); &#125;.bind(this), 200) &#125;, /** * 放大显示 */ rotate: function () &#123; //放大显示后并恢复 // //现在唯一的问题是 如果在循环里绑定相同的动画 却是单一执行呢 唉.... // this.animation.rotate(150).step() this.animation.opacity(1).scale(1.5, 1.5).step().scale(1, 1).step(); this.setData(&#123; //输出动画 animation: this.animation.export() &#125;) &#125;&#125;) wxml 1234&lt;view class=&quot;container&quot;&gt; &lt;view animation=&quot;&#123;&#123;animation&#125;&#125;&quot; style=&#x27;opacity:0&#x27; class=&quot;view&quot;&gt;我在做动画&lt;/view&gt;&lt;/view&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;rotate&quot;&gt;旋转&lt;/button&gt; 参考文档微信小程序把玩（四十）animation API微信小程序的动画效果官方文档","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"sublime text 插件 PlainTasks 任务计划","slug":"sublime text 插件 PlainTasks 任务计划","date":"2017-12-27T14:50:01.000Z","updated":"2021-09-09T16:34:45.398Z","comments":true,"path":"2017/12/sublime text 插件 PlainTasks 任务计划/","link":"","permalink":"http://elickzhao.github.io/2017/12/sublime%20text%20%E6%8F%92%E4%BB%B6%20PlainTasks%20%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/","excerpt":"","text":"还没正式开始使用 所以先记录几篇文章 哦 对了 因为字体原因 会造成图标不显示的问题 下面有具体解决方法 Sublime Text 3的PlainTasks插件 这篇文章. 这里简单说下,一 是改字体,改系统字体或者插件字体. 二 是把option后面能看到的图标 放到前面使用 说一下问题 自定义设置 open_tasks_bullet 和 done_tasks_bullet 如果这两个改了,就会出现 进度条无法显示的问题, 因为每次完成一个任务会直接把任务当作取消来算了.但是问题在于有时系统不会显示默认的字体.这里就必须改写 &quot;font_face&quot;: &quot;Microsoft YaHei&quot;, 雅黑还算好看点,所以现在暂且用这个.并用默认图标 已经用了sublime的同步设置,下面保存这个其实没什么太多意义,不过还是保存一份吧自己的配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; &quot;open_tasks_bullet&quot;: &quot;☐&quot;, // options: - | ❍ | ❑ | ■ | □ | ☐ | ▪ | ▫ | – | — | ≡ | → | › | [ ] &quot;done_tasks_bullet&quot;: &quot;✔&quot;, // options: + | ✓ | ✔ | √ | [x] &quot;cancelled_tasks_bullet&quot;: &quot;✘&quot;, // options: x | ✘ | [-] &quot;before_tasks_bullet_margin&quot;: 1, &quot;date_format&quot;: &quot;(%y-%m-%d %H:%M)&quot;, &quot;done_tag&quot;: true, // related to @cancelled as well &quot;project_tag&quot;: true, // if true - postfix archived task with project tag, if false - prefix &quot;archive_name&quot;: &quot;Archive:&quot;, // make sure it is the unique project name within your todo files &quot;new_on_top&quot;: true, // how to sort archived tasks &quot;show_remain_due&quot;: false, // in Sublime 3, show remain or overdue time under due tags //按理说这是这进度条设计啊 &quot;stats_format&quot;:&quot;$n/$a done ($percent%) $progress Last task @done $last&quot;, //&quot;stats_format&quot;:&quot;□$o [√]$d ≡$a&quot;, &quot;bar_full&quot;: &quot;■&quot;, &quot;bar_empty&quot;: &quot;□&quot;, // empty cell for progress-bar in status-bar, for more details see Custom Statistics in README &quot;replace_stats_chars&quot;: [[&quot; ■&quot;, &quot; [=&quot;], [&quot;■&quot;, &quot;=&quot;], [&quot;▫&quot;, &quot; ] &quot;], [&quot;▫&quot;, &quot; &quot;]], &quot;color_scheme&quot;: &quot;Packages/PlainTasks/tasks.hidden-tmTheme&quot;, // other bundled schemes: // Packages/PlainTasks/tasks-dark.hidden-tmTheme // Packages/PlainTasks/tasks-eighties-colored.hidden-tmTheme // Packages/PlainTasks/tasks-eighties-dark.hidden-tmTheme // Packages/PlainTasks/tasks-gray.hidden-tmTheme // Packages/PlainTasks/tasks-monokai.hidden-tmTheme // Packages/PlainTasks/tasks-solarized-dark.hidden-tmTheme // Packages/PlainTasks/tasks-solarized-light.hidden-tmTheme // &quot;font_size&quot;: 11, // &quot;font_face&quot;: &quot;Consolas&quot;, &quot;draw_indent_guides&quot;: false, &quot;line_numbers&quot;: false, &quot;gutter&quot;: true, &quot;margin&quot;: 2, &quot;tab_size&quot;: 2, &quot;translate_tabs_to_spaces&quot;: true, &quot;use_tab_stops&quot;: false, &quot;match_brackets&quot;: false, &quot;fold_buttons&quot;: true, &quot;fade_fold_buttons&quot;: false, &quot;extensions&quot;: [ &quot;TODO&quot;, &quot;todo&quot;, &quot;todolist&quot;, &quot;taskpaper&quot;, &quot;tasks&quot; ], &quot;font_face&quot;: &quot;Microsoft YaHei&quot;,&#125; 参考文档SublimeText 插件 - PlainTasks使用方法Sublime Text 3的PlainTasks插件SublimeText3 插件PlainTasks（Todo-list）的使用方法SublimeText 插件 - PlainTasks使用方法","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"}]},{"title":"小程序本地存储实例","slug":"小程序本地存储实例","date":"2017-12-25T14:36:56.000Z","updated":"2021-09-09T16:34:45.625Z","comments":true,"path":"2017/12/小程序本地存储实例/","link":"","permalink":"http://elickzhao.github.io/2017/12/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"test.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899Page(&#123; data: &#123; // text:&quot;这是一个页面&quot; storageContent: &#x27;&#x27;, storageSyncContent: &#x27;&#x27; &#125;, onLoad: function (options) &#123; // 页面初始化 options为页面跳转所带来的参数 &#125;, /** * 异步存储 */ listenerStorageSave: function () &#123; //以键值对的形式存储 传进去的是个对象 wx.setStorage(&#123; key: &#x27;key&#x27;, data: &#x27;我是storeage异步存储的信息&#x27;, success: function (res) &#123; console.log(res) &#125; &#125;) &#125;, /** * 异步取信息 */ listenerStorageGet: function () &#123; var that = this; wx.getStorage(&#123; //获取数据的key key: &#x27;key&#x27;, success: function (res) &#123; console.log(res) that.setData(&#123; // storageContent: res.data &#125;) &#125;, /** * 失败会调用 */ fail: function (res) &#123; console.log(res) &#125; &#125;) &#125;, /** * 清除数据 */ listenerStorageClear: function () &#123; var that = this; wx.clearStorage(&#123; success: function (res) &#123; that.setData(&#123; storageContent: &#x27;&#x27; &#125;) &#125; &#125;) &#125;, /** * 数据同步存储 */ listenerStorageSyncSave: function () &#123; wx.setStorageSync(&#x27;key&#x27;, &#x27;我是同步存储的数据&#x27;) &#125;, /** * 数据同步获取 */ listenerStorageSyncGet: function () &#123; // var that = this; var value = wx.getStorageSync(&#x27;key&#x27;) this.setData(&#123; storageSyncContent: value &#125;) &#125;, /** * 清除同步存储数据 */ listenerStorageSyncClear: function () &#123; wx.clearStorageSync() &#125;, onReady: function () &#123; // 页面渲染完成 &#125;, onShow: function () &#123; // 页面显示 &#125;, onHide: function () &#123; // 页面隐藏 &#125;, onUnload: function () &#123; // 页面关闭 &#125;&#125;) test.wxml 1234567891011121314&lt;!--动态获取数据--&gt;&lt;text&gt;&#123;&#123;storageContent&#125;&#125;&lt;/text&gt;&lt;!--存--&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;listenerStorageSave&quot;&gt;storage存储信息会在text上显示&lt;/button&gt;&lt;!--取--&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;listenerStorageGet&quot;&gt;获取storage存储的信息&lt;/button&gt;&lt;!--清--&gt;&lt;button type=&quot;warn&quot; bindtap=&quot;listenerStorageClear&quot;&gt;清楚异步存储数据&lt;/button&gt;&lt;text&gt;&#123;&#123;storageSyncContent&#125;&#125;&lt;/text&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;listenerStorageSyncSave&quot;&gt;storageSync存储信息会在text上显示&lt;/button&gt;&lt;button type=&quot;primary&quot; bindtap=&quot;listenerStorageSyncGet&quot;&gt;获取storageSync存储信息&lt;/button&gt;&lt;button type=&quot;warn&quot; bindtap=&quot;listenerStorageSyncClear&quot;&gt;清除同步存储数据&lt;/button&gt;","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"小程序中引用import和include区别","slug":"小程序中引用import和include区别","date":"2017-12-21T14:11:52.000Z","updated":"2021-09-09T16:34:45.616Z","comments":true,"path":"2017/12/小程序中引用import和include区别/","link":"","permalink":"http://elickzhao.github.io/2017/12/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%BC%95%E7%94%A8import%E5%92%8Cinclude%E5%8C%BA%E5%88%AB/","excerpt":"","text":"先说这两个的主要用法吧import 引入模版 可以根据固定样式显示数据 所以适合和数据进行组合的include 引入内容 无法和数据进行组合 所以适合引用固定样式的组件 而没有与数据交换操作的页面 现在很奇怪的事情是 include的不好使. 只有import是可用的已经搞懂include怎么用了,这个文档啊,字句真需要仔细琢磨.要不太有歧义了. include可以将目标文件除了的整个代码引入，相当于是拷贝到include位 应该是 除了&lt;template/&gt;代码块内的,其余内容全部引入. include这么用 12345678910111213141516171819202122&lt;include src=&quot;/pages/template/tabbar.wxml&quot; /&gt;--- &lt;view class=&quot;weui-tabbars&quot;&gt; &lt;navigator url=&quot;/pages/index/index&quot; open-type=&#x27;switchTab&#x27; class=&quot;weui-tabbar&quot;&gt; &lt;image class=&quot;weui-tabbar__icon&quot; src=&quot;../../images/icons/a.png&quot; /&gt; &lt;view class=&quot;weui-tabbar__label&quot;&gt;首页&lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=&quot;/pages/category/index&quot; open-type=&#x27;switchTab&#x27; class=&quot;weui-tabbar&quot;&gt; &lt;image class=&quot;weui-tabbar__icon&quot; src=&quot;../../images/icons/b.png&quot; /&gt; &lt;view class=&quot;weui-tabbar__label&quot;&gt;分类&lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=&quot;/pages/cart/cart&quot; open-type=&#x27;switchTab&#x27; class=&quot;weui-tabbar&quot;&gt; &lt;image class=&quot;weui-tabbar__icon&quot; src=&quot;../../images/icons/c.png&quot; /&gt; &lt;view class=&quot;weui-tabbar__label&quot;&gt;购物车&lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=&quot;/pages/user/user&quot; open-type=&#x27;switchTab&#x27; class=&quot;weui-tabbar&quot;&gt; &lt;image class=&quot;weui-tabbar__icon&quot; src=&quot;../../images/icons/dd.png&quot; /&gt; &lt;view class=&quot;weui-tabbar__label&quot; style=&#x27;color: #FF8140&#x27;&gt;我的&lt;/view&gt; &lt;/navigator&gt; &lt;/view&gt; import这么用 123456789101112131415161718192021222324 &lt;import src=&quot;../template/tabbar.wxml&quot; /&gt; &lt;template is=&quot;tabbar&quot; /&gt;----&lt;template name=&quot;tabbar&quot;&gt; &lt;view class=&quot;weui-tabbars&quot;&gt; &lt;navigator url=&quot;/pages/index/index&quot; open-type=&amp;#39;switchTab&amp;#39; class=&quot;weui-tabbar&quot;&gt; &lt;image class=&quot;weui-tabbar__icon&quot; src=&quot;../../images/icons/a.png&quot; /&gt; &lt;view class=&quot;weui-tabbar__label&quot;&gt;首页&lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=&quot;/pages/category/index&quot; open-type=&amp;#39;switchTab&amp;#39; class=&quot;weui-tabbar&quot;&gt; &lt;image class=&quot;weui-tabbar__icon&quot; src=&quot;../../images/icons/b.png&quot; /&gt; &lt;view class=&quot;weui-tabbar__label&quot;&gt;分类&lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=&quot;/pages/cart/cart&quot; open-type=&amp;#39;switchTab&amp;#39; class=&quot;weui-tabbar&quot;&gt; &lt;image class=&quot;weui-tabbar__icon&quot; src=&quot;../../images/icons/c.png&quot; /&gt; &lt;view class=&quot;weui-tabbar__label&quot;&gt;购物车&lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=&quot;/pages/user/user&quot; open-type=&amp;#39;switchTab&amp;#39; class=&quot;weui-tabbar&quot;&gt; &lt;image class=&quot;weui-tabbar__icon&quot; src=&quot;../../images/icons/dd.png&quot; /&gt; &lt;view class=&quot;weui-tabbar__label&quot; style=&amp;#39;color: #FF8140&amp;#39;&gt;我的&lt;/view&gt; &lt;/navigator&gt; &lt;/view&gt;&lt;/template&gt; 参考文档小程序中引用import和include区别","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"composer 删不掉的全局包","slug":"composer 删不掉的全局包 ","date":"2017-12-18T14:18:40.000Z","updated":"2021-09-09T16:34:45.124Z","comments":true,"path":"2017/12/composer 删不掉的全局包 /","link":"","permalink":"http://elickzhao.github.io/2017/12/composer%20%E5%88%A0%E4%B8%8D%E6%8E%89%E7%9A%84%E5%85%A8%E5%B1%80%E5%8C%85%20/","excerpt":"","text":"今天安装 php-cs-fixer 遇到个讨厌的情况.一直提示我需要卸载 symfony/console 12345Problem 1 - Installation request for friendsofphp/php-cs-fixer ^2.9 -&gt; satisfiable by friendsofphp/php-cs-fixer[v2.9.0]. - Conclusion: remove symfony/console v2.8.32 - Conclusion: don&#x27;t install symfony/console v2.8.32 - friendsofphp/php-cs-fixer v2.9.0 requires symfony/console ^3.2 || ^4.0 -&gt; satisfiable by symfony/console[v3.2.0, v3.2.1, v3.2.10, v3.2.11, v3.2.12, v3.2.13, v3.2.14, v3.2.2, v3.2.3, v3.2.4, v3.2.5, v3.2.6, v3.2.7, v3.2.8, v3.2.9, v3.3.0, v3.3.1, v3.3.10, v3.3.11, v3.3.12, v3.3.13, v3.3.14, v3.3.2, v3.3.3, v3.3.4, v3.3.5, v3.3.6, v3.3.7, v3.3.8, v3.3.9, v3.4.0, v3.4.1, v3.4.2, v4.0.0, v4.0.1, v4.0.2]. 可是 composer remove symfony/console -g 却提示说根本没有安装而且在C:\\Users\\elick\\AppData\\Roaming\\Composer的 composer.json 也确实没有啊 这就晕了 最后无奈更新了下 composer update 结果在更新的信息里的确发现了 symfony/console 后来才终于找到 原来在这里安装着呢 C:\\Users\\elick\\AppData\\Roaming\\Composer\\vendor\\composer的 installed.json 这可能是composer自带的插件或者依赖的插件吧 可能我用了好久一直没更新 于是出现了这个错误 看来以后安装插件的时候,提前更新下 是个好操作啊.","categories":[],"tags":[{"name":"composer","slug":"composer","permalink":"http://elickzhao.github.io/tags/composer/"}]},{"title":"让人遭心的  MySql enum字段使用问题","slug":"让人遭心的  MySql enum字段使用问题","date":"2017-12-14T08:44:08.000Z","updated":"2021-09-09T16:34:45.741Z","comments":true,"path":"2017/12/让人遭心的  MySql enum字段使用问题/","link":"","permalink":"http://elickzhao.github.io/2017/12/%E8%AE%A9%E4%BA%BA%E9%81%AD%E5%BF%83%E7%9A%84%20%20MySql%20enum%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"今天在改程序的时候遇到了 enum字段 这个东西果真奇葩.怎么搜索都搜索不到.后来查了资料才搞懂.这个字段是 mysql独有 其他数据库都没有的 所以用了他就别想换了他的唯一优点就是控制大小,因为他是类似数组形式保存的 所以数量是可控的但也造成了搜索时候的问题. 直接搜索的时候有可能搜索的是按key来搜不是保存在字段里value 唉… 据下面文档说 他的key是从1开始 所以搜不到0但是我遇到更奇葩的事 就算我按key=1 来搜索也搜不到 0 这个值. 而其他两个 1 和 2 全能搜到妈蛋 原来人家说的是对的 只不过数据库形式我没仔细看错了 搜索3就出来了数据库形式 是这样的 [‘1’=&gt;1,’2’=&gt;’2’,’3’=&gt;0] 1SELECT * FROM lr_order WHERE back = 3; //这是按key搜索 匹配出来的 全是 back=0 如果想按值搜索怎么做? 加上单引号就行了 1SELECT * FROM lr_order WHERE back = &#x27;0&#x27;; //这是按value搜索 匹配出来的 全是 back=0 这个破东西的确烦,可能框架都没法用.所以建立数据库的时候,还是用tinyint算了 ##参考文档MySql enum字段使用问题要慎用mysql的enum字段的原因","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"mysql","slug":"mysql","permalink":"http://elickzhao.github.io/tags/mysql/"}]},{"title":"php自动加载原理","slug":"php自动加载原理","date":"2017-11-27T13:44:41.000Z","updated":"2021-09-09T16:34:45.389Z","comments":true,"path":"2017/11/php自动加载原理/","link":"","permalink":"http://elickzhao.github.io/2017/11/php%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/","excerpt":"目录结构 F:.│ Power.php│ Superman.php│└─IoC Power.php Superman.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpnamespace IoC;//use Power\\Power; //定义了命名空间也需要引入???? 不能用use自动加载?//已经确定了 必须的引入 框架里都是使用了自动加载程序 所以无需引用//比如composer//include_once &#x27;Power.php&#x27;;//两点需要注意的//一 autoload不能在有命名空间下使用//二 函数是不能再类里面写的 要么写在之前 要么写在方法里//spl_autoload_register现在建议用这个函数 不建议使用__autoload了 好像7.2就要把他删掉了//这两个存在哪一个都可以//不过这是加载相同命名空间下的文件spl_autoload_register(function($class)&#123; if($class)&#123; $file = $class.&#x27;.php&#x27;; if(file_exists($file))&#123; include_once $file; &#125; &#125;&#125;);class Superman&#123; protected $power; public function __construct() &#123; // spl_autoload_register(function($class)&#123; // if($class)&#123; // $file = $class.&#x27;.php&#x27;; // if(file_exists($file))&#123; // include_once $file; // &#125; // &#125; // &#125;); //所以这个是IoC/下的Power 而不是和Superman同目录下的Power 因注册的是相同命名空间IoC下的文件 $this-&gt;power = new Power(999,100); &#125;// public function makeNew()&#123;// $this-&gt;power = new Power(999,100);// &#125; public function getPower()&#123; //var_dump($this-&gt;power); return $this-&gt;power; &#125;&#125;//明白了这个函数链是怎么回事了$man = new Superman;echo $man-&gt;getPower()-&gt;getAbility();echo &quot;&lt;br&gt;&quot;;//这个class的用法 必须没经过实例化的类 经过实例化的类是动态的会报错echo Power::class;","text":"目录结构 F:.│ Power.php│ Superman.php│└─IoC Power.php Superman.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpnamespace IoC;//use Power\\Power; //定义了命名空间也需要引入???? 不能用use自动加载?//已经确定了 必须的引入 框架里都是使用了自动加载程序 所以无需引用//比如composer//include_once &#x27;Power.php&#x27;;//两点需要注意的//一 autoload不能在有命名空间下使用//二 函数是不能再类里面写的 要么写在之前 要么写在方法里//spl_autoload_register现在建议用这个函数 不建议使用__autoload了 好像7.2就要把他删掉了//这两个存在哪一个都可以//不过这是加载相同命名空间下的文件spl_autoload_register(function($class)&#123; if($class)&#123; $file = $class.&#x27;.php&#x27;; if(file_exists($file))&#123; include_once $file; &#125; &#125;&#125;);class Superman&#123; protected $power; public function __construct() &#123; // spl_autoload_register(function($class)&#123; // if($class)&#123; // $file = $class.&#x27;.php&#x27;; // if(file_exists($file))&#123; // include_once $file; // &#125; // &#125; // &#125;); //所以这个是IoC/下的Power 而不是和Superman同目录下的Power 因注册的是相同命名空间IoC下的文件 $this-&gt;power = new Power(999,100); &#125;// public function makeNew()&#123;// $this-&gt;power = new Power(999,100);// &#125; public function getPower()&#123; //var_dump($this-&gt;power); return $this-&gt;power; &#125;&#125;//明白了这个函数链是怎么回事了$man = new Superman;echo $man-&gt;getPower()-&gt;getAbility();echo &quot;&lt;br&gt;&quot;;//这个class的用法 必须没经过实例化的类 经过实例化的类是动态的会报错echo Power::class; Power.php 12345678910111213141516171819&lt;?phpnamespace IoC;//namespace Power;class Power&#123; protected $ability; protected $range; public function __construct($ability,$range) &#123; $this-&gt;ability = $ability; $this-&gt;range = $range; &#125; public function getAbility()&#123; return $this-&gt;ability; &#125;&#125; 自动加载使用的是spl_autoload_register()现在不建议使用__autoload()了spl_autoload_register(&#39;类名&#39;)这个函数可以多次加载这比__autoload()只能用一次方便很多利于扩展而且可以在类中使用就想上面那个例子,而’__autoload()’就不可以了下面这个例子更好的说明了使用方式 12345678910111213141516171819202122232425262728293031&lt;?php/** * Created by PhpStorm. * User: chengtao * Date: 14-7-3 * Time: 上午11:27 */ define(&#x27;BASE_PATH&#x27;,dirname(__FILE__).&#x27;/&#x27;) ; function cron_autoload1 ($name) &#123; $file = BASE_PATH.&#x27;lib1/&#x27;.$name.&#x27;.class.php&#x27;; if(file_exists($file))&#123; include_once($file); return true; &#125; &#125;function cron_autoload2 ($name) &#123; $file = BASE_PATH.&#x27;lib2/&#x27;.$name.&#x27;.class.php&#x27;; if(file_exists($file))&#123; include_once($file); return true; &#125;&#125;spl_autoload_register(&#x27;cron_autoload1&#x27;);spl_autoload_register(&#x27;cron_autoload2&#x27;); new Class1();new Class2(); 所以只要有个单独的文件写这些注册的类的地址,然后只要引入这一个文件就好了以后可以扩展那个文件了这样就可以实现所有的自动加载.也就是我最初的疑问,还以为只要use 类 就能自己加载呢 其实是两码事 没那么智能 呵呵而且命名空间和存放文件地址也未必是一定相对应的,比如最上面第一个例子 Superman的命名空间和地址就不是对应的","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"}]},{"title":"Nuxt.js - Vue.js 通用应用框架","slug":"Nuxt.js - Vue.js 通用应用框架","date":"2017-09-07T15:13:43.000Z","updated":"2021-09-09T16:34:44.996Z","comments":true,"path":"2017/09/Nuxt.js - Vue.js 通用应用框架/","link":"","permalink":"http://elickzhao.github.io/2017/09/Nuxt.js%20-%20Vue.js%20%E9%80%9A%E7%94%A8%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/","excerpt":"","text":"其实主要看官方文档就可以了,非常之详尽而且是中文.以后遇到问题,或者容易忘记的点再记录下吧 ##参考文档官方文档Vue 基于 NUXT 的 SSR","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"一些vue的文章打算读一下","slug":"一些vue的文章打算读一下","date":"2017-09-02T14:53:51.000Z","updated":"2021-09-09T16:34:45.490Z","comments":true,"path":"2017/09/一些vue的文章打算读一下/","link":"","permalink":"http://elickzhao.github.io/2017/09/%E4%B8%80%E4%BA%9Bvue%E7%9A%84%E6%96%87%E7%AB%A0%E6%89%93%E7%AE%97%E8%AF%BB%E4%B8%80%E4%B8%8B/","excerpt":"","text":"Vue 全家桶 + Electron 开发的一个跨三端的应用饿了么基于Vue2.0的通用组件开发之路（分享会记录）","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"待读","slug":"待读","permalink":"http://elickzhao.github.io/tags/%E5%BE%85%E8%AF%BB/"}]},{"title":"前端图标插件总结","slug":"前端图标插件总结","date":"2017-09-01T15:18:23.000Z","updated":"2021-09-09T16:34:45.556Z","comments":true,"path":"2017/09/前端图标插件总结/","link":"","permalink":"http://elickzhao.github.io/2017/09/%E5%89%8D%E7%AB%AF%E5%9B%BE%E6%A0%87%E6%8F%92%E4%BB%B6%E6%80%BB%E7%BB%93/","excerpt":"","text":"名称 说明 ECharts 百度出品,免费且十分强大,各种图表都有,唯一可能造成的问题就是因为支持的太多可能体积大些 sChart.js 简单且易用,基本图表都有了.不过现在好像改名了叫chartjs中文文档,这个可以使用npm方式安装 Highcharts 这个的确很吊,但是呢收费,虽然说个人用户免费,但还不如用百度的Echarts比较安心 EasyReport 这个也很牛逼,这个是直接通过数据库形成列表形式的表单.这个用的时候复杂点,不过之后只要管理数据库就行了.这点很赞. 示例 metrics-graphics 这个的优势是可以用json文件来导入数据,而且使用上很简洁明了,几乎看一眼就会用了.但是支持格式少点","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"vue一些特别有用的插件","slug":"vue一些特别有用的插件","date":"2017-08-31T15:13:12.000Z","updated":"2021-09-09T16:34:45.761Z","comments":true,"path":"2017/08/vue一些特别有用的插件/","link":"","permalink":"http://elickzhao.github.io/2017/08/vue%E4%B8%80%E4%BA%9B%E7%89%B9%E5%88%AB%E6%9C%89%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/","excerpt":"Vue相关网站参考： Vue中文帮助网站：http://cn.vuejs.org/ Vue github开源地址：https://github.com/vuejs/vue Vue.js专业中文社区：http://www.vue-js.com/ 前端开发Vue相关：http://www.opendigg.com/tags/front-vue 本文开源地址：https://github.com/yonghu86/awesome-github-vue 本文主要是收集与整理Vue相关的开源资料，以供需要的朋友参考。主要包含以下几方面的内容： UI组件、开发框架、实用库、服务端、辅助工具、应用实例、Demo示例 构建插件 名称 说明 vue-spa-template 构建vue全家桶,Github说明很详细.参考文档:基于 vue 全家桶的 spa 项目脚手架 electron-vue 构建electron时用的 cooking vue特别简单的构建工具,不过东西可能没有上面vue-spa-template那么全. 中文文档 Vue-Element-Starter vue启动页.这个已经有了个后台框架的样子了.基本的东西已经弄好,可以快速开发了 Vue Paper Dashboard 这个真的很漂亮 就是不能用作大型后台 Vue Admin Panel Framework vue和buluma的后台好像是重复两个啊 CoPilot 这个也不错 是AdminLTE模板做的 CoreUI-Free-Bootstrap-Admin-Template 这个也不错 是CoreUI模板做的 Vuestic Admin Dashboard 这个也不错 是 Bootstrap 4.模板做的","text":"Vue相关网站参考： Vue中文帮助网站：http://cn.vuejs.org/ Vue github开源地址：https://github.com/vuejs/vue Vue.js专业中文社区：http://www.vue-js.com/ 前端开发Vue相关：http://www.opendigg.com/tags/front-vue 本文开源地址：https://github.com/yonghu86/awesome-github-vue 本文主要是收集与整理Vue相关的开源资料，以供需要的朋友参考。主要包含以下几方面的内容： UI组件、开发框架、实用库、服务端、辅助工具、应用实例、Demo示例 构建插件 名称 说明 vue-spa-template 构建vue全家桶,Github说明很详细.参考文档:基于 vue 全家桶的 spa 项目脚手架 electron-vue 构建electron时用的 cooking vue特别简单的构建工具,不过东西可能没有上面vue-spa-template那么全. 中文文档 Vue-Element-Starter vue启动页.这个已经有了个后台框架的样子了.基本的东西已经弄好,可以快速开发了 Vue Paper Dashboard 这个真的很漂亮 就是不能用作大型后台 Vue Admin Panel Framework vue和buluma的后台好像是重复两个啊 CoPilot 这个也不错 是AdminLTE模板做的 CoreUI-Free-Bootstrap-Admin-Template 这个也不错 是CoreUI模板做的 Vuestic Admin Dashboard 这个也不错 是 Bootstrap 4.模板做的 UI组件 名称 说明 element ★9305 饿了么出品的Vue2的web UI工具套件 Vux ★6802 基于Vue和WeUI的组件库 mint-ui ★4776 - Vue 2的移动UI元素 iview ★4458 - 基于 Vuejs 的开源 UI 组件库 Keen-UI ★2363 - 轻量级的基本UI组件合集 vue-material ★2207 - 通过Vue Material和Vue 2建立精美的app应用 muse-ui ★1992 - 三端样式一致的响应式 UI 库 vuetify ★1678 - 为移动而生的Vue JS 2组件框架 vonic ★1494 - 快速构建移动端单页应用 eme ★1390 - 优雅的Markdown编辑器 vue-multiselect ★1166 - Vue.js选择框解决方案 vue-table ★824 - 简化数据表格 VueCircleMenu ★776 - 漂亮的vue圆环菜单 vue-chat ★748 - vuejs和vuex及webpack的聊天示例 radon-ui ★633 - 快速开发产品的Vue组件库 vue-waterfall ★605 - Vue.js的瀑布布局组件 vue-carbon ★595 - 基于 vue 开发MD风格的移动端 vue-beauty ★569 - 由vue和ant design创建的优美UI组件 vue-blu ★557 - 帮助你轻松创建web应用 vueAdmin ★556 - 基于vuejs2和element的简单的管理员模板 vue-syntax-highlight ★551 - Sublime Text语法高亮 vue-infinite-scroll ★524 - VueJS的无限滚动指令 Vue.Draggable ★493 - 实现拖放和视图模型数组同步 vue-awesome-swiper ★476 - vue.js触摸滑动组件 vue-calendar ★465 - 日期选择插件 bootstrap-vue ★458 - 应用于Vuejs2的Twitter的Bootstrap 4组件 vue-swipe ★361 - VueJS触摸滑块 vue-amap ★346 - 基于Vue 2和高德地图的地图组件 vue-chartjs ★333 - vue中的Chartjs的封装 vue-datepicker ★331 - 日历和日期选择组件 markcook ★318 - 好看的markdown编辑器 vue-google-maps ★287 - 带有双向数据绑定Google地图组件 vue-progressbar ★248 - vue轻量级进度条 vue-picture-input ★236 - 移动友好的图片文件输入组件 vue-infinite-loading ★224 - VueJS的无限滚动插件 vue-upload-component ★204 - Vuejs文件上传组件 vue-datetime-picker ★197 - 日期时间选择控件 vue-scroller ★196 - Vonic UI的功能性组件 vue2-calendar ★181 - 支持lunar和日期事件的日期选择器 vue-video-player ★178 - VueJS视频及直播播放器 vue-fullcalendar ★176 - 基于vue.js的全日历组件 rubik ★170 - 基于Vuejs2的开源 UI 组件库 VueStar ★169 - 带星星动画的vue点赞按钮 vue-mugen-scroll ★167 - 无限滚动组件 mint-loadmore ★167 - VueJS的双向下拉刷新组件 vue-tables-2 ★162 - 显示数据的bootstrap样式网格 vue-virtual-scroller ★158 - 带任意数目数据的顺畅的滚动 DataVisualization ★149 - 数据可视化 vue-quill-editor ★149 - 基于Quill适用于Vue2的富文本编辑器 Vueditor ★138 - 所见即所得的编辑器 vue-html5-editor ★132 - html5所见即所得编辑器 vue-msgbox ★127 - vuejs的消息框 vue-slider ★126 - vue 滑动组件 vue-core-image-upload ★124 - 轻量级的vue上传插件 vue-slide ★121 - vue轻量级滑动组件 vue-lazyload-img ★118 - 移动优化的vue图片懒加载插件 vue-drag-and-drop-list ★114 - 创建排序列表的 vue-progressive-image ★107 - Vue的渐进图像加载插件 vuwe ★107 - 基于微信WeUI所开发的专用于Vue2的组件库 vue-dropzone ★105 - 用于文件上传的Vue组件 vue-charts ★101 - 轻松渲染一个图表 vue-swiper ★95 - 易于使用的滑块组件 vue-images ★93 - 显示一组图片的lightbox组件 vue-carousel-3d ★91 - VueJS的3D轮播组件 vue-region-picker ★89 - 选择中国的省份市和地区 vue-typer ★89 - 模拟用户输入选择和删除文本的 vue-impression ★88 - 移动Vuejs2 UI元素 vue-datatable ★87 - 使用Vuejs创建的DataTableView vue-instant ★86 - 轻松创建自动提示的自定义搜索控件 vue-dragging ★86 - 使元素可以拖拽 vue-slider-component ★85 - 在vue1和vue2中使用滑块 vue2-loading-bar ★76 - 最简单的仿Youtube加载条视图 vue-datepicker ★75 - 漂亮的Vue日期选择器组件 vue-video ★70 - Vue.js的HTML5视频播放器 vue-toast-mobile ★68 - VueJS的toast插件 vue-image-crop-upload ★67 - vue图片剪裁上传组件 vue-tooltip ★66 - 带绑定信息提示的提示工具 vue-highcharts ★66 - HighCharts组件 vue-touch-ripple ★62 - vuejs的触摸ripple组件,点击后的效果 coffeebreak ★61 - 实时编辑CSS组件工具 vue-datasource ★60 - 创建VueJS动态表格 vue2-timepicker ★60 - 下拉时间选择器 vue-date-picker ★59 - VueJS日期选择器组件 vue-scrollbar ★58 - 最简单的滚动区域组件 vue-quill ★56 - vue组件构建quill编辑器 vue-google-signin-button ★55 - 导入谷歌登录按钮 vue-svgicon ★53 - 创建svg图标组件的工具 vue-float-label ★49 - VueJS浮动标签模式 vue-baidu-map ★46 - 基于 Vue 2的百度地图组件库 vue-social-sharing ★45 - 社交分享组件 vue2-editor ★44 - HTML编辑器 vue-tagsinput ★41 - 基于VueJS的标签组件 vue-easy-slider ★41 - Vue 2.x的滑块组件 datepicker ★38 - 基于flatpickr的时间选择组件 vue-chart ★37 - 强大的高速的vue图表解析 vue-music-master ★37 - vue手机端网页音乐播放器 handsontable ★35 - 网页表格组件 vue-simplemde ★35 - VueJS的Markdown编辑器组件 vue-popup-mixin ★35 - 用于管理弹出框的遮盖层 cubeex ★33 - 包含一套完整的移动UI vue-fullcalendar ★32 - vue FullCalendar封装 vue-material-design ★32 - Vue MD风格组件 vue-morris ★31 - Vuejs组件封装Morrisjs库 we-vue ★30 - Vue2及weui1开发的组件 vue-image-clip ★29 - 基于vue的图像剪辑组件 vue-bootstrap-table ★29 - 可排序可检索的表格 vue-radial-progress ★28 - Vue.js放射性进度条组件 vue-slick ★28 - 实现流畅轮播框的vue组件 vue-pull-to-refresh ★27 - Vue2的上拉下拉 vue-form-2 ★26 - 全面的HTML表单管理的解决方案 vue-side-nav ★26 - 响应式的侧边导航 (这个一般) mint-indicator ★26 - VueJS移动加载指示器插件 (没有demo不知道干啥的) chartjs ★24 - Vue Bulma的chartjs组件 (这是组件之一 很少单独用) vue-scroll ★24 - vue滚动 vue-ripple ★24 - 制作谷歌MD风格涟漪效果的Vue组件 (这跟上面的点击效果一样) vue-touch-keyboard ★22 - VueJS虚拟键盘组件 (这个有点意思) vue-chartkick ★22 - VueJS一行代码实现优美图表 vue-ztree ★21 - 用 vue 写的树层级组件 vue-m-carousel ★20 - vue 移动端轮播组件 (这个很一般 参考学习还行) vue-datepicker-simple ★20 - 基于Vue的日期选择器 vue-tabs ★20 - 多tab页轻型框架 vue-verify-pop ★19 - 带气泡提示的Vue校验插件 vue-parallax ★15 - 整洁的视觉效果 vue-img-loader ★14 - 图片加载UI组件 (应该是不好用) vue-typewriter ★13 - vue组件类型 vue-smoothscroll ★12 - smoothscroll的VueJS版本 vue-city ★10 - 城市选择器 (这个不错) vue-tree ★10 - vue树视图组件 (这个不错) vue-ios-alertview ★8 - iOS7+ 风格的alertview服务 dd-vue-component ★7 - 订单来了的公共组件库 paco-ui-vue ★7 - PACOUI的vue组件 vue-cmap ★5 - Vue China map可视化组件 vue-button ★4 - Vue按钮组件 开发框架 名称 说明 vue.js ★45466 - 流行的轻量高效的前端组件化方案 vue-admin ★3222 - Vue管理面板框架 electron-vue ★1273 - Electron及VueJS快速启动样板 vue-2.0-boilerplate ★241 - Vue2单页应用样板​ vue-spa-template ★223 - 前后端分离后的单页应用开发 Framework7-Vue ★210 - VueJS与Framework7结合 vue-bulma ★132 - 轻量级高性能MVVM Admin UI框架 vue-webgulp ★100 - 仿VueJS Vue loader示例 vue-element-starter ★34 - vue启动页 实用库 名称 说明 vuex ★5997 - 专为 Vue.js 应用程序开 vuelidate ★750 - 简单轻量级的基于模块的Vue.js验证 qingcheng ★677 - qingcheng主题 (不知道这个是干啥用的) vue-desktop ★461 - 创建管理面板网站的UI库 (演示网站都没了 唉) vue-meta ★257 - 管理app的meta信息 vue-axios ★209 - 将axios整合到 vue-svg-icon ★116 - vue2的可变彩色svg图标方案 avoriaz ★110 - VueJS测试实用工具库 vue-framework7 ★83 - 结合VueJS使用的Framework7组件 vue-bootstrap-modal ★78 - vue的Bootstrap样式组件 vuep ★72 - 用实时编辑和预览来渲染Vue组件 vue-online ★67 - reactive的在线和离线组件 vue-lazy-render ★66 - 用于Vue组件的延迟渲染 vue-password-strength-meter ★65 - 交互式密码强度计 (这个不错) element-admin ★57 - 支持 vuecli 的 Element UI 的后台模板 vue-electron ★55 - 将选择的API封装到Vue对象中的插件 vue-cleave ★55 - 基于cleave.js的Cleave组件 cleave.js演示 vue-events ★54 - 简化事件的VueJS插件 vue-shortkey ★53 - 应用于Vue.js的Vue-ShortKey 插件 vue-cordova ★50 - Cordova的VueJS插件 vue-gesture ★48 - VueJS的手势事件插件 http-vue-loader ★46 - 从html及js环境加载vue文件 vue-qart ★46 - 用于qartjs的Vue2指令 生成二维码的 vuemit ★44 - 处理VueJS事件 vue-websocket ★42 - VueJS的Websocket插件 vue-local-storage ★41 - 具有类型支持的Vuejs本地储存插件 vue-reactive-storage ★35 - vue插件的Reactive层,也是处理storage的 vue-notifications ★32 - 非阻塞 通知提示信息 库 vue-lazy-component ★32 - 懒加载组件或者元素的Vue指令 v-media-query ★32 - vue中添加用于配合媒体查询的方法, (其实是检测屏幕是否改变做出相应动作) vuex-i18n ★26 - 定位插件 (这应该是多语言话的工具) Vue.resize ★26 - 检测HTML调整大小事件的vue指令 vuex-shared-mutations ★25 - 分享某种Vuex mutations (这不太懂) vue-file-base64 ★16 - 将文件转换为Base64的vue组件 vue-truncate-filter ★9 - 截断字符串的VueJS过滤器 vue-input-autowidth ★5 - 基于内容自动调整文本输入的大小 vue-lazyloadImg ★3 - 图片懒加载插件 服务端 名称 说明 nuxt.js ★2743 - 用于服务器渲染Vue app的最小化框架 express-vue ★137 - 简单的使用服务器端渲染vue.js Vue.js SSR Template ★67 - 非常简单的VueJS服务器端渲染模板 辅助工具 名称 说明 DejaVue ★543 - Vuejs可视化及压力测试 vue-play ★445 - 展示Vue组件的最小化框架 vscode-VueHelper ★185 - 目前vscode最好的vue代码提示插件 vue-generate-component ★39 - 轻松生成Vue js组件的CLI工具 vue-multipage-cli ★33 - 简单的多页CLI 应用实例 名称 说明 koel ★7175 - 基于网络的个人音频流媒体服务 pagekit ★4021 - 轻量级的CMS建站系统 vuedo ★1040 - 博客平台 jackblog-vue ★943 - 个人博客系统 vue-cnode ★597 - 重写vue版cnode社区 CMS-of-Blog ★405 - 博客内容管理器 rss-reader ★326 - 简单的rss阅读器 vue-ghpages-blog ★208 - 依赖GitHub Pages无需本地生成的静态博客 swoole-vue-webim ★97 - Web版的聊天应用 vue-blog ★33 - 使用Vue2.0 和Vuex的vue-blog Demo示例 名称 说明 Vue-cnodejs ★2113 - 基于vue重写Cnodejs.org的webapp NeteaseCloudWebApp ★1154 - 高仿网易云音乐的webapp vue-zhihu-daily ★875 - 知乎日报 with Vuejs vue-wechat ★732 - vue.js开发微信app界面 vue2-demo ★699 - 从零构建vue2 + vue-router + vuex 开发环境 eleme ★612 - 高仿饿了么app商家详情 vue-demo ★575 - vue简易留言板 maizuo ★498 - vue/vuex/redux仿卖座网 vue-music ★485 - Vue 音乐搜索播放 vue-Meizi ★394 - vue最新实战项目 zhihudaily-vue ★386 - 知乎日报web版 vue-demo-kugou ★310 - vuejs仿写酷狗音乐webapp vue2.0-taopiaopiao ★246 - vue2.0与express构建淘票票页面 vue-leancloud-blog ★239 - 一个前后端完全分离的单页应用 vue2.x-douban ★188 - Vue2实现简易豆瓣电影webApp vue-demo-maizuo ★188 - 使用Vue2全家桶仿制卖座电影 vue-adminLte-vue-router ★162 - vue和adminLte整合应用 vue-axios-github ★157 - 登录拦截登出功能 Zhihu-Daily-Vue.js ★134 - Vuejs单页网页应用 x-blog ★100 - 开源的个人blog项目 vue-express-mongodb ★96 - 简单的前后端分离案例 websocket_chat ★91 - 基于vue和websocket的多人在线聊天室 photoShare ★85 - 基于图片分享的社交平台 notepad ★77 - 本地存储的记事本 vueBlog ★75 - 前后端分离博客 vue-ruby-china ★70 - VueJS框架搭建的rubychina平台 Zhihu_Daily ★70 - 基于Vue和Nodejs的Web单页应用 vue-koa-demo ★60 - 使用Vue2和Koa1的全栈demo vue2.x-Cnode ★50 - 基于vue全家桶的Cnode社区 houtai ★44 - 基于vue和Element的后台管理系统 vue-cli-multipage-bootstrap ★36 - 将vue官方在线示例整合到组件中 HyaReader ★30 - 移动友好的阅读器 zhihu-daily ★28 - 轻松查看知乎日报内容 seeMusic ★27 - 跨平台云音乐播放器 vue-cnode ★22 - 使用cNode社区提供的接口 sls-vuex2-demo ★20 - vuex2商城购物车demo vue-memo ★7 - 用 vue写的记事本应用","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"电商产品的SKU是什么意思","slug":"电商产品的SKU是什么意思","date":"2017-08-30T11:18:37.000Z","updated":"2021-09-09T16:34:45.698Z","comments":true,"path":"2017/08/电商产品的SKU是什么意思/","link":"","permalink":"http://elickzhao.github.io/2017/08/%E7%94%B5%E5%95%86%E4%BA%A7%E5%93%81%E7%9A%84SKU%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/","excerpt":"","text":"spu 和 sku 都是属性值的集合, 举个栗子 一部 6S, 它身上有很多的属性和值. 比如 : 毛重: 420.00 g 产地: 中国大陆 容量: 16G, 64G, 128G 颜色: 银, 白, 玫瑰金 你跑进苏宁顺电, 说想要一台 6S, 店员也会再继续问: 你想要什么 6S? 16G 银色? 64G 白色? 每一台 6S 的毛重都是 420.00 g, 产地也都是 中国大陆. 这两个属性就属于 spu 属性. 而容量和颜色, 这种会影响价格和库存的(比如 16G 与 64G 的价格不同, 16G 银色还有货, 金色卖完了)属性就是 sku 属性. spu 属性(不会影响到库存和价格的属性, 又叫关键属性) 毛重: 420.00 g 产地: 中国大陆 sku 属性(会影响到库存和价格的属性, 又叫销售属性) 容量: 16G, 64G, 128G 颜色: 银, 白, 玫瑰金 sku 在生成时, 会根据 属性生成 相应的 笛卡尔积.想像一下扑克牌的黑红梅方和 A-K, 扑克牌是这样的 sku 属性: 牌面: A - K 花色: 黑红梅方 最终会生成 13 * 4 = 52 张牌, 上面的 6S 则会生成 3 * 3 = 9 个 SKU商品 : iphone 6sspu : 包含在每一部 6s 的属性集合, 与商品是一对一的关系(产地:中国, 毛重:420g…)sku : 影响价格和库存的 属性集合, 与商品是多对一的关系单品 : 同 sku. 国人的另一种叫法!","categories":[],"tags":[{"name":"小百科,杂学","slug":"小百科-杂学","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91-%E6%9D%82%E5%AD%A6/"}]},{"title":"前端动画及绘画插件总结","slug":"前端动画及绘画插件总结","date":"2017-08-29T13:59:30.000Z","updated":"2021-09-09T16:34:45.554Z","comments":true,"path":"2017/08/前端动画及绘画插件总结/","link":"","permalink":"http://elickzhao.github.io/2017/08/%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E5%8F%8A%E7%BB%98%E7%94%BB%E6%8F%92%E4%BB%B6%E6%80%BB%E7%BB%93/","excerpt":"","text":"名称 说明 two.js 一个渲染器无关的适用于 web 的二维绘图 api 。 paper.js 是矢量图形脚本中的瑞士军刀 —— 使用 HTML5 Canvas 将 Scriptographer 移植到 JavaScript和浏览器 three.js 这没的说了,js里绘制3D的老大,只要技术强可以绘制各种东西,并且能做小游戏","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"SPA和SSR开发模式简介","slug":"SPA和SSR开发模式简介","date":"2017-08-28T15:06:41.000Z","updated":"2021-09-09T16:34:45.022Z","comments":true,"path":"2017/08/SPA和SSR开发模式简介/","link":"","permalink":"http://elickzhao.github.io/2017/08/SPA%E5%92%8CSSR%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/","excerpt":"","text":"SPA: SPA (Single-Page App) 单页面应用模式SSR: 意为 Server Side Rendering（服务端渲染）前后端都各自有自己的开发流程，构建工具，测试集合等等。前后端仅仅通过接口来编程，这个接口可能是JSON格式的RESTFul的接口，也可能是XML的，重点是后台只负责数据的提供和计算，而完全不处理展现。而前端则负责拿到数据，组织数据并展现的工作。这样结构清晰，关注点分离，前后端会变得相对独立并松耦合。 参考文档前后端分离了，然后呢？前后端分离的思考与实践（一） 如何快速开发SPA应用一种SPA（单页面应用）架构单页面(SPA)开发会不会比多页面有更多的安全问题？","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"API开发接口管理及mock数据","slug":"API开发接口管理及mock数据","date":"2017-08-27T15:21:41.000Z","updated":"2021-09-09T16:34:44.860Z","comments":true,"path":"2017/08/API开发接口管理及mock数据/","link":"","permalink":"http://elickzhao.github.io/2017/08/API%E5%BC%80%E5%8F%91%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86%E5%8F%8Amock%E6%95%B0%E6%8D%AE/","excerpt":"","text":"这里总结了一些开发前后端分离,对于开发API的管理.不仅可以在没有后端搭建成的时候mock数据.而且可以管理接口及版本,并生成文档.这为开发及后续整理提供很大的方便. 网站 具有的特色 DOClever 这个平台有很好的介绍用的都是视频真是太贴心了教程.而且可以管理团队,项目分配,模拟数据,测试接口,版本管理.真的是功能十分丰富,这个也可以导入Swagger,只要导出json文件 当创建项目时导入就可以了,但现在只能复制导入,导入文件总说错 Easy Mock 这个也很好,虽然没有那么多功能.但是对于开发是测试数据已经足够了.还可以配合Swagger来管理API接口 eoApi 是简化版的eolinker.也是同样的不清不楚.可能他们有自己一套API开发逻辑吧,搞不懂.有数据字典结果跟接口一毛钱关系没有.而且没有mock数据.这个都不如上面两个好用 eolinker 这个也还行,自带数据库管理.可能会根据数据库来对接口进行操作吧.功能也是十分强大.但是模拟数据这一块让人摸不着头脑.还有就是本地测试需要插件,文档教程不清.上手复杂一些.还有一点是收费,以后可能功能受到限制.但是有接口市场可以简化一些操作比如连接微信什么的 RAP 功能也非常强大,但是操作有点反人类,还有就是服务器不是独立的经常会慢或者崩溃.不太推荐","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"},{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"}]},{"title":"一些应该知道的php框架","slug":"一些应该知道的php框架","date":"2017-08-26T13:38:21.000Z","updated":"2021-09-09T16:34:45.509Z","comments":true,"path":"2017/08/一些应该知道的php框架/","link":"","permalink":"http://elickzhao.github.io/2017/08/%E4%B8%80%E4%BA%9B%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84php%E6%A1%86%E6%9E%B6/","excerpt":"","text":"名称 说明 laravel/lumen 这是我目前在研究和用的 laravel擅长主流网站 lumen是微框架适合做API后台 Swoole C扩展实现的PHP异步并行网络通信框架，可以重新定义PHP。过去PHP只能做Web项目，现在有了Swoole。任意服务器端程序都可以用PHP来写。 workerman 类似swoole，不过是纯PHP实现的，官网有很多示例项目。底层功能比swoole少一些，但相对简单，应用层面的功能比swoole丰富。 Slim Slim是一款 PHP 微框架，可以帮助你快速编写简单但功能强大的 web 应用和 API silex Silex:基于Symfony组件的微型框架 一些文章PHP的异步Web服务器+异步Redis客户端《使用php轻框架－lumen搭建api服务》","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"Swagger简介","slug":"Swagger简介","date":"2017-08-25T09:41:59.000Z","updated":"2021-09-09T16:34:45.037Z","comments":true,"path":"2017/08/Swagger简介/","link":"","permalink":"http://elickzhao.github.io/2017/08/Swagger%E7%AE%80%E4%BB%8B/","excerpt":"主要看这篇文章就行了 Swagger从入门到精通 虽然可能有些地方可能有老了,没讲到不过还是很实用,而且非常细致. 剩下的看编辑器事例就好了,一下子就能看懂了 官方在线编辑器 记录点一: 当请求操作时,有两种方式一种是路径请求,另一种是参数请求.两种表现形式不同. 参数请求 12345678910// get(请求方式) /persons?pageSize=20&amp;pageNumber=2 parameters: - name: pageSize in: query //就是这里,这里query表示参数请求 description: Number of persons returned type: integer - name: pageNumber in: query description: Page number type: integer 路径请求 1234567// get(请求方式) /persons/&#123;username&#125; parameters: - name: username in: path //这里path表示路径请求 required: true //这个表示路径参数必须填写,默认为false表示这个路径是可选填的 description: The person&#x27;s username type: string","text":"主要看这篇文章就行了 Swagger从入门到精通 虽然可能有些地方可能有老了,没讲到不过还是很实用,而且非常细致. 剩下的看编辑器事例就好了,一下子就能看懂了 官方在线编辑器 记录点一: 当请求操作时,有两种方式一种是路径请求,另一种是参数请求.两种表现形式不同. 参数请求 12345678910// get(请求方式) /persons?pageSize=20&amp;pageNumber=2 parameters: - name: pageSize in: query //就是这里,这里query表示参数请求 description: Number of persons returned type: integer - name: pageNumber in: query description: Page number type: integer 路径请求 1234567// get(请求方式) /persons/&#123;username&#125; parameters: - name: username in: path //这里path表示路径请求 required: true //这个表示路径参数必须填写,默认为false表示这个路径是可选填的 description: The person&#x27;s username type: string 记录点二返回数据形式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 responses: &#x27;200&#x27;: description: successful operation schema: type: array items: $ref: &#x27;#/definitions/Pet&#x27; //这个是连接底下的数据结构 .... //其实这就是数据库的结构 Pet: type: object required: - name - photoUrls properties: id: type: integer format: int64 category: $ref: &#x27;#/definitions/Category&#x27; //这个还可以关联另一个数据表内容 这样返回时很简单. name: type: string example: doggie //这是事例 在测试时就直接显示了 photoUrls: type: array xml: // 这个xml可能是在选择返回为xml才有用 但一般是json格式 name: photoUrl wrapped: true items: //这个才是json正常显示的东西 type: string tags: type: array xml: name: tag wrapped: true items: $ref: &#x27;#/definitions/Tag&#x27; status: type: string description: pet status in the store enum: - available - pending - sold xml: name: Pet 记录点三 定义消息体参数 接下来我们给 post 方法添加参数，通过 in 属性显式说明参数是在 body 中的。参数的定义参考 get /persons/{username} 的 200 响应消息体参数，也就是包含用户的姓氏、名字、用户名。 1234567891011121314parameters: - name: person in: body description: The person to create. schema: required: - username properties: firstName: type: string lastName: type: string username: type: string 官方在线编辑器Swagger - 前后端分离后的契约[译]5.41 Swagger tutorialSwagger从入门到精通Swagger","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"前端模拟本地数据 mock 的各种方法","slug":"前端模拟本地数据 mock 的各种方法","date":"2017-08-19T13:40:01.000Z","updated":"2021-09-09T16:34:45.564Z","comments":true,"path":"2017/08/前端模拟本地数据 mock 的各种方法/","link":"","permalink":"http://elickzhao.github.io/2017/08/%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%8B%9F%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%20mock%20%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"json-server通过REST路由操作JSON文件数据库 JSONPlaceholder用于测试和原型的简单假REST API服务器。 fake-api-server跟JSONPlaceholder一样,是用于测试信息的测试服务器 ssr这个和上面的 json-server 异曲同工之妙,这不过这个既可以当作静态网站服务器,也可以提供 本地数据mock 用于测试开发 这个可以配合mock.js 利用代理路由 达到模拟数据 这个方法简单些 比上面的写json文件好点 mock.js这个有个问题拦截ajax只能是jq,还有个插件是angular的 可惜我不用.我只用vue,虽然也可以手动添加但还是不如插件简单,以后可以考虑自己搞一个.对了可以配合另一个插件 axios-mock-adapter 做到拦截并返回模拟数据我自己的文章说明","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"mock","slug":"mock","permalink":"http://elickzhao.github.io/tags/mock/"}]},{"title":"各种网页大收藏","slug":"各种网页大收藏","date":"2017-08-07T14:34:47.000Z","updated":"2021-09-09T16:34:45.583Z","comments":true,"path":"2017/08/各种网页大收藏/","link":"","permalink":"http://elickzhao.github.io/2017/08/%E5%90%84%E7%A7%8D%E7%BD%91%E9%A1%B5%E5%A4%A7%E6%94%B6%E8%97%8F/","excerpt":"","text":"因为好多网站呢,放在收藏夹也没什么必要,因为不经常用.但是偶尔也许能用到,所以都记录到这里吧. 课程网站 网站 说明 菜鸟教程 这个是最好的,所有都免费.而且各种程序都有.唯一的缺点只是比较入门 不够深入. 泰课在线 主要以游戏开发为主,有一些免费的公开课 优才学院 以网页开发为主 课程库 也是以网页开发为主,而且全是免费的,挺不错的 汇至网 什么开发都有些,不过有一大半是收费的 CSDN视频学院 视频的确很直接,但是免费的不如开始那么多了,我收藏的go语音开发也没了 资源网站 网站 说明 求字体 前端想要各种字体可以上这里来找 字体转换器 可以转换成各种好看的字体 不过下载的是图片而已","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"node.js包大收集","slug":"node.js包大收集","date":"2017-08-06T13:05:05.000Z","updated":"2021-09-09T16:34:45.329Z","comments":true,"path":"2017/08/node.js包大收集/","link":"","permalink":"http://elickzhao.github.io/2017/08/node.js%E5%8C%85%E5%A4%A7%E6%94%B6%E9%9B%86/","excerpt":"","text":"包名 简介 图片 multispinner 在CLI模式下进度显示程序 cfonts 在CLI模式下输出各种拼接文字,只支持英文 chalk 在CLI模式下,设置字体颜色及背景颜色 figures 在CLI模式下,输出符号 lowdb lowdb是一个基于lodash API的轻量级本地JSON数据库 (支持 Node.js , 浏览器 和 Electron) lodash 这是一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库 中文手册 lodash-id 用于js对象数据库.一般配合lowdb使用 uuid 生成UUID的工具包 cryptr 一个用于加密解密的工具包 json-server 通过REST路由操作JSON文件数据库 Ramda 一款实用的 JavaScript 函数式编程库。Ramda 中文 JSONPlaceholder 用于测试和原型的简单假REST API服务器。 fake-api-server 跟JSONPlaceholder一样,是用于测试信息的测试服务器 electron 把node程序打包成各平台应用 Electron中文文档 uglify-js 加密工具 Tippy.js 一个提示的小插件,有多种效果的 iconate.js 图标切换动画效果的插件,用这个插件轻松制作动画切换 idoc 用MD文件直接生成文档网站,比如API文档网站网站演示 ssr 这个和上面的 json-server 异曲同工之妙,这不过这个既可以当作静态网站服务器,也可以提供 本地数据mock 用于测试开发 这个可以配合mock.js 利用代理路由 达到模拟数据 这个方法简单些 比上面的写json文件好点","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"}]},{"title":"CSS3之Transition（变换过渡）使用","slug":"CSS3之Transition（变换过渡）使用","date":"2017-08-05T14:17:21.000Z","updated":"2021-09-09T16:34:44.873Z","comments":true,"path":"2017/08/CSS3之Transition（变换过渡）使用/","link":"","permalink":"http://elickzhao.github.io/2017/08/CSS3%E4%B9%8BTransition%EF%BC%88%E5%8F%98%E6%8D%A2%E8%BF%87%E6%B8%A1%EF%BC%89%E4%BD%BF%E7%94%A8/","excerpt":"","text":"12345678910111213141516171819202122transition: property duration timing-function delay;/*property：执行过渡的属性 all 或者 width 这些css属性duration：执行过渡的持续时间 s 或者 mstiming-function：执行过渡的速率模式 linear：（匀速） ease-in-out （加速然后减速）delay：延时多久执行 单位为s（秒）或者ms（毫秒），默认就是0，也就是立即执行， 多个动画执行 一个和另一个之间的时间间隔*/例子.ivu-col &#123; /* 修改了速度 和 模式 现在看来没有以前的效果, 不过观感好多 */ transition: width .08s ease-out; /* property：执行过渡的属性 all 或者 width duration：执行过渡的持续时间 可以是 s 或是 ms timing-function：执行过渡的速率模式 ease-in-out delay：延时多久执行 */&#125; 参考文档CSS3之Transition（变换过渡）","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"Axios 初探","slug":"Axios 初探","date":"2017-08-01T12:07:38.000Z","updated":"2021-09-09T16:34:44.870Z","comments":true,"path":"2017/08/Axios 初探/","link":"","permalink":"http://elickzhao.github.io/2017/08/Axios%20%E5%88%9D%E6%8E%A2/","excerpt":"","text":"简单用法 123456789101112/* 向具有指定ID的用户发出请求 *///其实和jq的ajax差不多 then 是成功返回执行其后任务,catch捕捉错误//其实就是 Promise 可以进行并发操作的 axios.all(iterable) 其实就是 promise.all()axios.get(&#x27;/user?ID=12345&#x27;) .then(function(response)&#123; console.log(response); &#125;) .catch(function(error)&#123; console.log(error); &#125;); 还有以下用法 1234567axios.request(config)axios.get(url [，config])axios.delete(url [，config])axios.head(url [，config])axios.post(url [，data [，config]])axios.put(url [，data [，config]])axios.patch(url [，data [，config]]) 创建实例使用 1234567891011121314151617181920const ajaxUrl = env === &#x27;development&#x27; ? &#x27;http://127.0.0.1:3000&#x27; : env === &#x27;production&#x27; ? &#x27;https://www.url.com&#x27; : &#x27;https://debug.url.com&#x27;;util.ajax = axios.create(&#123; baseURL: ajaxUrl, timeout: 30000&#125;);//这样使用 这样就不用每次都写那个很长的请求地址了 Util.ajax.get(&#x27;users&#x27;, &#123; //只能用get 是请求 post是创建 params: &#123; user: this.formInline.user, password: this.formInline.password &#125; &#125;) 参考文档Axios全攻略axios基本用法","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"vue键盘监听事件","slug":"vue键盘监听事件","date":"2017-07-29T13:58:02.000Z","updated":"2021-09-09T16:34:45.454Z","comments":true,"path":"2017/07/vue键盘监听事件/","link":"","permalink":"http://elickzhao.github.io/2017/07/vue%E9%94%AE%E7%9B%98%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6/","excerpt":"聚焦一个焦点,判断键值这么写 123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/Vue.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &#x27;#box&#x27;, data: &#123;&#125;, methods: &#123; show: function (ev) &#123; if(ev.keyCode==13)&#123; alert(&#x27;你按了回车键！&#x27;) &#125; &#125; &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; @keyup=&quot;show($event)&quot;&gt; &lt;!-- 这里 @keydown 也是可行的--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","text":"聚焦一个焦点,判断键值这么写 123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/Vue.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &#x27;#box&#x27;, data: &#123;&#125;, methods: &#123; show: function (ev) &#123; if(ev.keyCode==13)&#123; alert(&#x27;你按了回车键！&#x27;) &#125; &#125; &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; @keyup=&quot;show($event)&quot;&gt; &lt;!-- 这里 @keydown 也是可行的--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 简单写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/Vue.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &#x27;#box&#x27;, data: &#123;&#125;, methods: &#123; show: function () &#123; alert(&#x27;你按了回车！&#x27;); &#125;, show2: function () &#123; alert(&#x27;你按了回车！&#x27;); &#125;, show3: function () &#123; alert(&#x27;你按了上键！&#x27;); &#125;, show4: function () &#123; alert(&#x27;你按了下键！&#x27;); &#125;, show5: function () &#123; alert(&#x27;你按了左键！&#x27;); &#125;, show6: function () &#123; alert(&#x27;你按了右键！&#x27;); &#125; &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; @keyup.13=&quot;show()&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keyup.enter=&quot;show2()&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keyup.up=&quot;show3()&quot;&gt; &lt;!-- 这里是方向键的上下左右 --&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keyup.down=&quot;show4()&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keyup.left=&quot;show5()&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keyup.right=&quot;show6()&quot;&gt; &lt;hr&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 整个页面监听键盘按键 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253export default &#123; mounted: function () &#123; // 用 $nextTick 也不行 应该是这里可以用this 但是 document.onkeyup 里面不行 // this.$nextTick(function () &#123; // // 代码保证 this.$el 在 document 中 // document.onkeyup = function (ev) &#123; // if (ev.keyCode == 13) &#123; // this.handleSubmit(&#x27;formInline&#x27;); // &#125; // &#125; // &#125;) //就是这里了 用钩子在组件加载完毕后 监听按键 这样当页面按下回车就会执行下面方法 let self = this; document.onkeyup = function (ev) &#123; if (ev.keyCode == 13) &#123; self.handleSubmit(&#x27;formInline&#x27;); &#125; &#125; &#125;, methods: &#123; handleSubmit(name) &#123; this.$refs[name].validate((valid) =&gt; &#123; if (valid) &#123; this.$Message.success(&#x27;登录成功!&#x27;); this.$router.push(&#123; path: &#x27;/main&#x27; &#125;) //模拟数据测试 let mock = new MockAdapter(axios); var template = &#123; &#x27;people|1-4&#x27;: [&#123; &#x27;name&#x27;: &#x27;@name&#x27;, &#x27;age&#x27;: &#x27;@integer(10,80)&#x27; &#125;] &#125; let data = Mock.mock(template); mock.onGet(&quot;www.h.com&quot;).reply(200, data); axios.get(&quot;www.h.com&quot;).then(function (res) &#123; let u = res.data.user; console.log(JSON.stringify(res.data, null, 2)); &#125;); &#125; else &#123; this.$Message.error(&#x27;表单验证失败!&#x27;); &#125; &#125;) &#125; &#125;&#125; 参考文档键值修饰符Vue键盘事件vue里面的针对window的键盘监听事件，应该怎么写","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"GSAP的TimelineMax时间轴及TweenMax缓动学习","slug":"GSAP的TimelineMax时间轴及TweenMax缓动学习 ","date":"2017-07-26T14:55:58.000Z","updated":"2021-09-09T16:34:44.915Z","comments":true,"path":"2017/07/GSAP的TimelineMax时间轴及TweenMax缓动学习 /","link":"","permalink":"http://elickzhao.github.io/2017/07/GSAP%E7%9A%84TimelineMax%E6%97%B6%E9%97%B4%E8%BD%B4%E5%8F%8ATweenMax%E7%BC%93%E5%8A%A8%E5%AD%A6%E4%B9%A0%20/","excerpt":"","text":"参考文档TimelineMax系列学习文章TimelineMax：Tweening简介GSAP官方参考文档Easing缓动演示","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"vue及vue-router程序的title修改","slug":"vue及vue-router程序的title修改","date":"2017-07-22T06:02:38.000Z","updated":"2021-09-09T16:34:45.452Z","comments":true,"path":"2017/07/vue及vue-router程序的title修改/","link":"","permalink":"http://elickzhao.github.io/2017/07/vue%E5%8F%8Avue-router%E7%A8%8B%E5%BA%8F%E7%9A%84title%E4%BF%AE%E6%94%B9/","excerpt":"","text":"因为vue控制的是body部分,所以没法修改header里的title这个比较麻烦而且不美观. 现在新的 vue-router 可以解决这个问题了.用钩子方法来做. 12345//这是钩子进入页面之前,就修改titlerouter.beforeEach((to, from, next) =&gt; &#123; document.title = to.meta.title //这 to.meta.title 是在router里设置的 next()&#125;) 这是vue-router设置 123456789101112131415const routers = [&#123; path: &#x27;/&#x27;, meta: &#123; title: &#x27;后台登录&#x27; //这个就是上面设置 &#125;, component: (resolve) =&gt; require([&#x27;./views/login.vue&#x27;], resolve)&#125;,&#123; path: &#x27;/main&#x27;, meta: &#123; title: &#x27;后台管理中心&#x27; //这个是title标题 &#125;, component: (resolve) =&gt; require([&#x27;./views/main.vue&#x27;], resolve)&#125;]; 参考文档vue-router2.0设置title","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"vue-router的学习笔记","slug":"vue-router的学习笔记","date":"2017-07-18T15:24:37.000Z","updated":"2021-09-09T16:34:45.436Z","comments":true,"path":"2017/07/vue-router的学习笔记/","link":"","permalink":"http://elickzhao.github.io/2017/07/vue-router%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"模版里链接跳转 1&lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; js跳转方法 1this.$router.push(&#123; path: &#x27;/main&#x27; &#125;) 子页面这么用 router 配置 12345678910111213141516171819202122232425262728293031323334353637const routers = [&#123; path: &#x27;/&#x27;, meta: &#123; title: &#x27;后台登录&#x27; &#125;, component: (resolve) =&gt; require([&#x27;./views/login.vue&#x27;], resolve) //这个resolve原来是懒加载的意思. 不是一次性加载组件,访问哪个加载哪个&#125;, &#123; path: &#x27;/main&#x27;, meta: &#123; title: &#x27;后台管理中心&#x27; //这个是title标题 &#125;, component: (resolve) =&gt; require([&#x27;./views/main.vue&#x27;], resolve), //这就是子页面了 children: [ &#123; path: &#x27;/&#x27;, //当一开始进入页面转到子页面,避免空页面 //redirect: &#x27;/main/sub1&#x27; //指定路径 redirect:&#123; name: &#x27;goods&#x27; &#125; //指定命名路径 &#125;, &#123; path: &#x27;sub1&#x27;, component: (resolve) =&gt; require([&#x27;./views/sub1.vue&#x27;], resolve), name:&#x27;sub1&#x27; &#125;, &#123; path: &#x27;sub2&#x27;, component: (resolve) =&gt; require([&#x27;./views/sub2.vue&#x27;], resolve), name:&#x27;sub2&#x27; &#125;, &#123; path: &#x27;sub3&#x27;, component: (resolve) =&gt; require([&#x27;./views/sub3.vue&#x27;], resolve), name:&#x27;sub3&#x27; &#125;, ]&#125;]; 模版页面使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445..... &lt;i-col :span=&quot;spanLeft&quot; class=&quot;layout-menu-left&quot;&gt; &lt;Menu active-name=&quot;1&quot; theme=&quot;light&quot; width=&quot;auto&quot;&gt; &lt;div class=&quot;layout-logo-left&quot;&gt; &lt;span class=&quot;logo-lg&quot; v-show=&quot;spanLeft == 4&quot;&gt; &lt;b&gt;Admin&lt;/b&gt;LTE &lt;/span&gt; &lt;span class=&quot;logo-mini&quot; v-show=&quot;spanLeft == 1&quot;&gt; &lt;b&gt;LTE&lt;/b&gt; &lt;/span&gt; &lt;/div&gt; &lt;Menu-item name=&quot;1&quot;&gt; &lt;!-- 这里链接一定是 /main/这个下面的子链接 虽然在配置里没这么写 --&gt; &lt;router-link to=&quot;/main/sub1&quot; &gt; &lt;Icon type=&quot;ios-navigate&quot; :size=&quot;iconSize&quot;&gt;&lt;/Icon&gt; &lt;span class=&quot;layout-text&quot; v-show=&quot;spanLeft == 4&quot;&gt;选项 1选项&lt;/span&gt; &lt;/router-link&gt; &lt;/Menu-item&gt; &lt;Menu-item name=&quot;2&quot;&gt; &lt;router-link to=&quot;/main/sub2&quot;&gt; &lt;Icon type=&quot;ios-keypad&quot; :size=&quot;iconSize&quot;&gt;&lt;/Icon&gt; &lt;span class=&quot;layout-text&quot;&gt;选项 2&lt;/span&gt; &lt;/router-link&gt; &lt;/Menu-item&gt; &lt;Menu-item name=&quot;3&quot;&gt; &lt;router-link to=&quot;/main/sub3&quot;&gt; &lt;Icon type=&quot;ios-analytics&quot; :size=&quot;iconSize&quot;&gt;&lt;/Icon&gt; &lt;span class=&quot;layout-text&quot;&gt;选项 3&lt;/span&gt; &lt;/router-link&gt; &lt;/Menu-item&gt; &lt;/Menu&gt; &lt;/i-col&gt; ........ &lt;div class=&quot;layout-content-main&quot;&gt; &lt;!-- 这里显示子页面 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 参考文档官方文档Vue-router2.0学习笔记vue-router带你出坑Vue.js——vue-router 60分钟快速入门 这个是老版文章只能做参考了Vue 爬坑之路（三）—— 使用 vue-router 跳转页面","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"node.js 自建简易服务器","slug":"node.js 自建简易服务器","date":"2017-07-16T14:45:54.000Z","updated":"2021-09-09T16:34:45.320Z","comments":true,"path":"2017/07/node.js 自建简易服务器/","link":"","permalink":"http://elickzhao.github.io/2017/07/node.js%20%E8%87%AA%E5%BB%BA%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"废话先不多说,代码就是如下这么简单. 123456789101112var express = require(&#x27;express&#x27;)var app = express()app.use(express.static(&#x27;./dist&#x27;)) //指定目录app.get(&#x27;/&#x27;, function (req, res) &#123; //res.send(&#x27;Hello World&#x27;) //这里注意下因为生成的静态页不是index.html标准名称 所以不会显示 res.sendFile( path.join(__dirname, &#x27;./dist/index_prod.html&#x27;)) //这是返回静态页,注意啊一定要绝对路径&#125;)app.listen(3000)","text":"废话先不多说,代码就是如下这么简单. 123456789101112var express = require(&#x27;express&#x27;)var app = express()app.use(express.static(&#x27;./dist&#x27;)) //指定目录app.get(&#x27;/&#x27;, function (req, res) &#123; //res.send(&#x27;Hello World&#x27;) //这里注意下因为生成的静态页不是index.html标准名称 所以不会显示 res.sendFile( path.join(__dirname, &#x27;./dist/index_prod.html&#x27;)) //这是返回静态页,注意啊一定要绝对路径&#125;)app.listen(3000) 下面这个是参考文档里的写法 123456789var http = require(&#x27;http&#x27;);var express = require(&#x27;express&#x27;);var app = express();app.use(&quot;/public&quot;, express.static(__dirname + &#x27;/public&#x27;)); //访问路径写到一起了// 创建服务端http.createServer(app).listen(&#x27;80&#x27;, function() &#123; console.log(&#x27;启动服务器完成&#x27;);&#125;); 然后执行 node app.js 就可以启动服务器了. app.js 就是上面配置所保存的文件名. 上面用的是express,用http-server的话就更简单,不需要自己写配置直接用命令就可以启动了.不过这个需要全局安装才行,要不不会有命令的.http-server是另一个插件,别搞混了 1234//如果你的当前项目中存在 public 文件夹,那么默认静态目录会指定到 public//如果没有 public 文件夹,那么静态目录就是 根目录//所以要哪个目录充当静态服务器的根目录 就得进入哪个目录执行下面命令http-server -a 127.0.0.1 -p 7070 下面开始唠叨: 因为现在做动静分离的后台程序,所以需要前端的静态服务器.在本地时单击打开静态文件,有时因为所需插件原因.也是无法打开的,必须放在静态服务器.所以这时就需要上面的东西了. 还有一点是,我在这个项目里生成的首页名字为 index_prod.html 一定要改成 index.html 一来服务器可以直接显示,二来是如果不改无法正确显示内容. 用res.sendFile( path.join(__dirname, ‘./dist/index_prod.html’))就可以返回指定文件了,但是路径一定要是绝对路径 关于设置静态服务器的必要性 看看这里 是否有必要为网站的静态资源设置一个单独的服务器?能了解到不少东西. 这两个搭建服务器的插件 express和 http-server 都得先安装才能用.不过呢 因为项目里有时用到别的插件.比如 webpace的时候 express就不用特别安装了.因为已经包涵在里面.但是http-server使用的范围不是那么广,所以必须安装. 还有就是下面参考文档里说,http-server比express要小巧,不过从下载的包来看,并不是如此.可能指的的是功能上吧. 而且express可以操作数据库,这可能对我要写的程序有点用处. ##参考文档Node.js用6行代码1个JS文件搭建一个HTTP静态服务器随笔 http-server 快速创建node.js 静态服务器http-server Angular.js 后端node服务首选 轻量级替换 Express 解决方案","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"multispinner 使用简介","slug":"multispinner 使用简介","date":"2017-07-10T12:55:01.000Z","updated":"2021-09-09T16:34:45.310Z","comments":true,"path":"2017/07/multispinner 使用简介/","link":"","permalink":"http://elickzhao.github.io/2017/07/multispinner%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/","excerpt":"multispinner 是在命令行执行时等待的样式,并且能根据结果返回不同的提示信息. 这个node插件使用起来非常简单 在multispinner Github 里有例子 不太懂可以看一下.","text":"multispinner 是在命令行执行时等待的样式,并且能根据结果返回不同的提示信息. 这个node插件使用起来非常简单 在multispinner Github 里有例子 不太懂可以看一下.","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"LowDB静态JSON文件数据库详细介绍","slug":"LowDB静态JSON文件数据库详细介绍","date":"2017-07-09T14:12:51.000Z","updated":"2021-09-09T16:34:44.972Z","comments":true,"path":"2017/07/LowDB静态JSON文件数据库详细介绍/","link":"","permalink":"http://elickzhao.github.io/2017/07/LowDB%E9%9D%99%E6%80%81JSON%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/","excerpt":"lowdb lowdb是一个基于lodash API的轻量级本地JSON数据库 (支持 Node.js , 浏览器 和 Electron) 特点 Small（轻量级） Serverless（不需要服务器） lodash rich API（lodash丰富的API） In-memory or disk-based（基于内存和硬盘的存储） Hackable (mixins, id, encryption, …)(可以扩展第三方插件,比如lodash-id) 安装 npm install lowdb –save或者yarn add lowdb 也可以外部引用使用 12345&lt;script src=&quot;https://unpkg.com/lodash@4/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/lowdb/dist/lowdb.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var db = low(&#x27;db&#x27;)&lt;/script&gt; ##使用","text":"lowdb lowdb是一个基于lodash API的轻量级本地JSON数据库 (支持 Node.js , 浏览器 和 Electron) 特点 Small（轻量级） Serverless（不需要服务器） lodash rich API（lodash丰富的API） In-memory or disk-based（基于内存和硬盘的存储） Hackable (mixins, id, encryption, …)(可以扩展第三方插件,比如lodash-id) 安装 npm install lowdb –save或者yarn add lowdb 也可以外部引用使用 12345&lt;script src=&quot;https://unpkg.com/lodash@4/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/lowdb/dist/lowdb.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var db = low(&#x27;db&#x27;)&lt;/script&gt; ##使用 low() 12345678910111213141516171819202122232425//lowdb几种模式// 内存模式low()// 使用异步方式处理本地数据存储low(&#x27;db.json&#x27;, &#123; storage: require(&#x27;lowdb/lib/storages/file-async&#x27;) &#125;)// 使用用户自定义数据low(&#x27;some-source&#x27;, &#123; storage: require(&#x27;./my-custom-storage&#x27;) &#125;)// 只读模式const fileSync = require(&#x27;lowdb/lib/storages/file-sync&#x27;)low(&#x27;db.json&#x27;, &#123; storage: &#123; read: fileSync.read &#125;&#125;)// 只写模式low(&#x27;db.json&#x27;, &#123; storage: &#123; write: fileSync.write &#125;&#125;) db._ 一个数据库lodash实例,用于扩展第三方插件或自定义方法 12345678db._.mixin(&#123; second: function(array) &#123; return array[1] &#125;&#125;)const post1 = db.get(&#x27;posts&#x27;).first().value()const post2 = db.get(&#x27;posts&#x27;).second().value() db.getState() 获得数据库状态和内容 是个字符串 12345db.getState() // &#123; posts: [ ... ] &#125;//---------//这么用fs.writeFileSync(&#x27;db.json&#x27;, JSON.stringify(db.getState())) //fs文件操作 db.setState(newState) 清空数据库 12345678910111213 const newState = &#123;&#125; db.setState(newState)``` **db.write([source])db.read([source])**&gt;这两个都是返回一个promise执行异步操作,可以用于备份```js//read和这个完全一样const db = low(&#x27;db.json&#x27;)db.write() // writes to db.jsondb.write(&#x27;copy.json&#x27;) // writes to copy.json db.defaults() 初始化一个数据库 12db.defaults(&#123; posts: [], user: &#123;&#125; &#125;) .write() .id 自动插入id字段,生成一个随机值 1db.get(&#x27;posts&#x27;).insert(&#123; title: &#x27;今天是个好日子!&#x27; &#125;).write().id 常用写法 根据lodash API 写出的常用写法 是否存在数据 12db.has(&#x27;posts&#x27;) .value() 设置数据 12db.set(&#x27;posts&#x27;, []) .write() 排序前五 12345db.get(&#x27;posts&#x27;) .filter(&#123;published: true&#125;) .sortBy(&#x27;views&#x27;) .take(5) .value() 获得标题 123db.get(&#x27;posts&#x27;) .map(&#x27;title&#x27;) .value() 获得数量 123db.get(&#x27;posts&#x27;) .size() .value() 获得第一个标题 12db.get(&#x27;posts[0].title&#x27;) .value() 更新数据 1234db.get(&#x27;posts&#x27;) .find(&#123; title: &#x27;low!&#x27; &#125;) .assign(&#123; title: &#x27;hi!&#x27;&#125;) .write() 删除数据 123db.get(&#x27;posts&#x27;) .remove(&#123; title: &#x27;low!&#x27; &#125;) .write() 删除一个属性 12345678910111213141516171819//db.unset(&#x27;user&#x27;).write() 可以把这个属性整个删除掉db.unset(&#x27;user.name&#x27;) .write()/* db是这个样子的&#123; &quot;posts&quot;: [ &#123; &quot;title&quot;: &quot;今天是个好日子!&quot;, &quot;id&quot;: &quot;6dde9a48-e204-401c-b869-96e16605269f&quot; &#125; ], &quot;user&quot;: &#123; &quot;age&quot;: &quot;25&quot;, &quot;name&quot;: &quot;elick&quot; &#125;&#125; */ 复制可以用作备份时使用 123456789101112131415db.get(&#x27;posts&#x27;) .cloneDeep() .value()//---------------------//这样可以达到备份单个表用途let clone = db.get(&#x27;posts&#x27;) .cloneDeep() .value()const db1 = low(&#x27;copy.json&#x27;)db1.defaults(&#123;posts:clone&#125;).write() ##添加扩展 lodash-id 123456const db = low(&#x27;db.json&#x27;)db._.mixin(require(&#x27;lodash-id&#x27;))const postId = db.get(&#x27;posts&#x27;).insert(&#123; title: &#x27;low!&#x27; &#125;).write().idconst post = db.get(&#x27;posts&#x27;).getById(postId).value() uuid 1234const uuid = require(&#x27;uuid&#x27;)const postId = db.get(&#x27;posts&#x27;).push(&#123; id: uuid(), title: &#x27;low!&#x27; &#125;).write().idconst post = db.get(&#x27;posts&#x27;).find(&#123; id: postId &#125;).value() cryptr 加密解密 (这个加密注意一个情况,如果库文件存在的话会报错,只有初始化一个新的才可以) 1234567891011121314151617181920const Cryptr = require(&quot;./cryptr&quot;),const cryptr = new Cryptr(&#x27;my secret key&#x27;)const db = low(&#x27;db.json&#x27;, &#123; format: &#123; deserialize: (str) =&gt; &#123; const decrypted = cryptr.decrypt(str) const obj = JSON.parse(decrypted) return obj &#125;, serialize: (obj) =&gt; &#123; const str = JSON.stringify(obj) const encrypted = cryptr.encrypt(str) return encrypted &#125; &#125;&#125;)db.defaults(&#123; posts: [], user: &#123;&#125; &#125;) .write() ##使用问题总结 set和unset的使用 123456//也可以操作,二维的数组,不过删除时最好不要用 unset ,会造成多一个`逗号`//一般情况下造作一维比较好db.unset(&#x27;user.age&#x27;).write()db.set(&#x27;posts[4].title&#x27;, &#x27;啦啦啦啦&#x27;) .write() 加密解密 这个问题上面已经说了,就是必须生成一个新文件,要不会报错json格式不正确 使用lodash-id 1234567891011121314151617181920212223242526272829//这个是正确的使用方式 不过这个插入真心意义不大和push 还不如push打字少db.get(&#x27;posts&#x27;).insert(&#123;id:333, body: &#x27;New post&#x27;&#125;).write()//----------------------------------------------------------------------//只有write()的时候才真正写入, 如果没有write()只是返回不会修改文件let dd = db.get(&#x27;posts&#x27;).replaceById(3,&#123;body: &#x27;心心心心&#x27;&#125;).write()//----------------------------------------------------------------------//这是原本更新和lodash-id比是稍显复杂写.而且这个和lodash-id都有个问题是,不能跟新所有只能跟新第一个//因为这时我的库里有好几个 id:3 的数据db.get(&#x27;posts&#x27;).find(&#123;id:3&#125;).assign(&#123;body:&#x27;哈哈哈哈&#x27;&#125;).write() //----------------------------------------------------------------------//配合浏览器的时候 lodash-id 最有用app.get(&#x27;/posts/:id&#x27;,(req,res)=&gt;&#123; console.log(typeof(req.params.id)) //别说这个还是有点用的 如果用原版的找就找不到 可能是类型的关系 //const post = db.get(&#x27;posts&#x27;).getById(req.params.id).value() const post = db.get(&#x27;posts&#x27;) .find(&#123; id: parseInt(req.params.id) &#125;) //就是类型问题 .value() console.log(post) res.send(post)&#125;) 使用前一点要初始化数据库文件 曾经遇到过一次,因为清空数据.里面却保存了字符,结果再插入数据时报错还有一次清空了数据.里面没有了表.插入数据时报错而且不能初始化两次哦 否则看上去正常插入数据时也会报错 ##官方例子clis.js 用命行令使用方式 123456789101112131415&quot;use strict&quot;//import low from &#x27;lowdb&#x27;const low = require(&#x27;lowdb&#x27;)const db = low(&#x27;db.json&#x27;)db.defaults(&#123;posts:[]&#125;) .write()const result = db.get(&#x27;posts&#x27;) .push(&#123;name: process.argv[2]&#125;) .write()console.log(result) server.js 这里美精简 整个测试过程全在里面了 挑着用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const express = require(&#x27;express&#x27;)const _ = require(&#x27;lodash&#x27;)_.mixin(require(&#x27;lodash-id&#x27;))const low = require(&#x27;lowdb&#x27;)const fileAsync = require(&#x27;lowdb/lib/storages/file-async&#x27;)const app = express()const db = low(&#x27;db/db.json&#x27;,&#123; storage: fileAsync&#125;)//使用这句 才能使用 lodash-iddb._.mixin(_)db.defaults(&#123;posts:[]&#125;) .write()// var radnum = Math.floor(Math.random()*10)// console.log(radnum)// db.get(&#x27;posts&#x27;)// .push(&#123; id: radnum, body: &#x27;lowdb is awesome&#x27;&#125;)// .write()// //这是更新// db.get(&#x27;posts&#x27;).find(&#123;id:3&#125;).assign(&#123;body:&#x27;哈哈哈哈&#x27;&#125;).write() // //好像只能改变一维数组,要不就只能清空// // db.set(&#x27;user.name&#x27;, &#x27;typicode&#x27;)// // .write()// let v = db.get(&#x27;posts&#x27;).value()// console.log(v)//这个是正确的使用方式 不过这个插入真心意义不大和push 还不如push打字少//db.get(&#x27;posts&#x27;).insert(&#123;id:333, body: &#x27;New post333333333&#x27;&#125;).write()//这个和find区别也不大let aa = db.get(&#x27;posts&#x27;).getById(3).value()//console.log(aa)//这还有点用比上面那个少 不过也只能改写一个 这个数据库里有两个3其实//还有就是只有write()的时候才真正写入,也许这是上面异步的关系let dd = db.get(&#x27;posts&#x27;).replaceById(3,&#123;body: &#x27;心心心心&#x27;&#125;).write()console.log(dd)console.log(&#x27;---------------------&#x27;)let pp = db.get(&#x27;posts&#x27;).value()console.log(pp)app.get(&#x27;/posts/:id&#x27;,(req,res)=&gt;&#123; console.log(typeof(req.params.id)) //别说这个还是有点用的 如果用原版的找就找不到 可能是类型的关系 //const post = db.get(&#x27;posts&#x27;).getById(req.params.id).value() const post = db.get(&#x27;posts&#x27;) .find(&#123; id: parseInt(req.params.id) &#125;) //就是类型问题 .value() console.log(post) res.send(post)&#125;)app.get(&#x27;/posts&#x27;,(req,res)=&gt;&#123; //low(&#x27;posts&#x27;).insert(&#123; title: &#x27;foo&#x27;,id:Date.now() &#125;).then(post=&gt;&#123;res.send(post)&#125;)// db.set(&#x27;posts&#x27;, &#123;body:&#x27;呵呵&#x27;,id:Date.now()&#125;)// .write()// console.log(db.posts) db.get(&#x27;posts&#x27;).insert(&#123;id:666, body: &#x27;双击屏幕666666666666&#x27;&#125;).write().then(post=&gt;res.send(post))&#125;)// app.get(&#x27;/posts&#x27;,(req,res)=&gt;&#123;// db.get(&#x27;posts&#x27;)// .push(req.body)// .last()// .assign(&#123;id:Date.now()&#125;)// .write()// .then(post=&gt;res.send(post))// &#125;)//这应该是异步写法// app.post(&#x27;/posts&#x27;, async (req, res) =&gt; &#123;// const post = await db.get(&#x27;posts&#x27;)// .push(req.body)// .last()// .assign(&#123; id: Date.now() &#125;)// .write()// res.send(post)// &#125;)db.defaults(&#123;posts:[]&#125;) .write() .then(()=&gt;&#123; app.listen(8080,()=&gt;console.log(&#x27;Server is listening&#x27;)) &#125;)//app.listen(8080,()=&gt;console.log(&#x27;Server is listening&#x27;)) memory.js 内存模式这样应该会速度快很多吧 123456789101112const fs = require(&#x27;fs&#x27;)const db = low()db.defaults(&#123; posts: [] &#125;) .write()db.get(&#x27;posts&#x27;) .push(&#123; title: &#x27;lowdb&#x27; &#125;) .write()// Manual writingfs.writeFileSync(&#x27;db.json&#x27;, JSON.stringify(db.getState())) ##参考文档LowDB静态JSON文件数据库介绍","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"module.exports与exports，export与export default解析","slug":"module.exports与exports，export与export default解析","date":"2017-07-08T13:13:07.000Z","updated":"2021-09-09T16:34:45.303Z","comments":true,"path":"2017/07/module.exports与exports，export与export default解析/","link":"","permalink":"http://elickzhao.github.io/2017/07/module.exports%E4%B8%8Eexports%EF%BC%8Cexport%E4%B8%8Eexport%20default%E8%A7%A3%E6%9E%90/","excerpt":"","text":"其实下面文章写的特别好了,真没必要在复制一份,忘记的时候就再看一下下面的文章吧 下面写点自己容易忽视的东西吧. module.exports exports 与 export export default 注意哟 少个 S module.exports 是 CommonJS模块规范 export 是 node 的一个简写,不用你写那么多了 export export default 是 ES6模块规范 export default就是为模块指定默认输出 1234567891011121314151617181920212223242526272829303132333435// module.exports 例子var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX;------------------------------------------------------------------var example = require(&#x27;./example.js&#x27;);console.log(example.x); // 5console.log(example.addX(1)); // 6------------------------------------------------------------------//export 例子var firstName = &#x27;Michael&#x27;;var lastName = &#x27;Jackson&#x27;;var year = 1958;export &#123;firstName, lastName, year&#125;;export default function () &#123; console.log(&#x27;foo&#x27;);&#125;------------------------------------------------------------------//ES6 有这个优势吧,可以分开引入部分内容 exports 可能就不行吧 .我是这么觉得的import &#123; firstName, lastName &#125; from &#x27;demo1&#x27; 参考文档这个文章很好,讲的很详细module.exports与exports，export与export default之间的关系和区别","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://elickzhao.github.io/tags/JavaScript/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"弹性盒子(flexible box) 定位属性 align-content  justify-content align-items align-self","slug":"弹性盒子(flexible box) 定位属性 align-content  justify-content align-items align-self","date":"2017-07-06T15:25:48.000Z","updated":"2021-09-09T16:34:45.647Z","comments":true,"path":"2017/07/弹性盒子(flexible box) 定位属性 align-content  justify-content align-items align-self/","link":"","permalink":"http://elickzhao.github.io/2017/07/%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90(flexible%20box)%20%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7%20align-content%20%20justify-content%20align-items%20align-self/","excerpt":"","text":"align-content:在弹性容器内的各项没有占用交叉轴上所有可用的空间时对齐容器内的各项（垂直）。请注意本属性在只有一行的伸缩容器上没有效果。测试效果页说明文章页 justify-content:设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。当弹性盒里一行上的所有子元素都不能伸缩或已经达到其最大值时，这一属性可协助对多余的空间进行分配。当元素溢出某行时，这一属性同样会在对齐上进行控制。 测试效果页说明文章页 align-items:align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。提示：使用每个弹性对象元素的 align-self 属性可重写 align-items 属性。 测试效果页说明文章页 align-self:align-self 属性定义flex子项单独在侧轴（纵轴）方向上的对齐方式。。注意：align-self 属性可重写灵活容器的 align-items 属性。 测试效果页说明文章页","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"JavaScript 严格模式(use strict)","slug":"JavaScript 严格模式(use strict)","date":"2017-07-02T12:13:29.000Z","updated":"2021-09-09T16:34:44.948Z","comments":true,"path":"2017/07/JavaScript 严格模式(use strict)/","link":"","permalink":"http://elickzhao.github.io/2017/07/JavaScript%20%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F(use%20strict)/","excerpt":"","text":"“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。“use strict” 的目的是指定代码在严格条件下执行。 会限制一些写法,并且提示一些错误.据说可以加速js的运行速度具体改进了那些内容可以看第二个文章.里面写的特别详细了. 为什么使用”use strict”可以节约你的时间Javascript 严格模式详解JavaScript 严格模式(use strict)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"Mock.js 模拟随机测试数据","slug":"Mock.js 模拟随机测试数据","date":"2017-07-01T14:22:56.000Z","updated":"2021-09-09T16:34:44.975Z","comments":true,"path":"2017/07/Mock.js 模拟随机测试数据/","link":"","permalink":"http://elickzhao.github.io/2017/07/Mock.js%20%E6%A8%A1%E6%8B%9F%E9%9A%8F%E6%9C%BA%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/","excerpt":"这个东西用起来简单并且强大,不过现在可能不太流行了.因为这个配合jquery比较多. 直接随机产生数据 1234567891011&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;&lt;script&gt;// 使用 Mockvar data = Mock.mock(&#123; &#x27;list|1-10&#x27;: [&#123; &#x27;id|+1&#x27;: 1 &#125;]&#125;);$(&#x27;&lt;pre&gt;&#x27;).text(JSON.stringify(data, null, 4)).appendTo(&#x27;body&#x27;)&lt;/script&gt; 12345678910111213&#123;&quot;list&quot;: [ &#123; &quot;id&quot;: 1 &#125;, &#123; &quot;id&quot;: 2 &#125;, &#123; &quot;id&quot;: 3 &#125; ]&#125;","text":"这个东西用起来简单并且强大,不过现在可能不太流行了.因为这个配合jquery比较多. 直接随机产生数据 1234567891011&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;&lt;script&gt;// 使用 Mockvar data = Mock.mock(&#123; &#x27;list|1-10&#x27;: [&#123; &#x27;id|+1&#x27;: 1 &#125;]&#125;);$(&#x27;&lt;pre&gt;&#x27;).text(JSON.stringify(data, null, 4)).appendTo(&#x27;body&#x27;)&lt;/script&gt; 12345678910111213&#123;&quot;list&quot;: [ &#123; &quot;id&quot;: 1 &#125;, &#123; &quot;id&quot;: 2 &#125;, &#123; &quot;id&quot;: 3 &#125; ]&#125; 这个是拦截Ajax,返回模拟数据. 1234567891011121314151617181920212223242526272829303132Mock.mock(&#x27;http://g.cn&#x27;, &#123; &#x27;name&#x27; : &#x27;@name&#x27;, &#x27;age|1-100&#x27;: 100, &#x27;color&#x27; : &#x27;@color&#x27;&#125;);$.ajax(&#123; url: &#x27;http://g.cn&#x27;, dataType:&#x27;json&#x27; &#125;).done(function(data, status, xhr)&#123; console.log( JSON.stringify(data, null, 4) ) &#125;)；//输出结果----------------------------// 结果1&#123;&quot;name&quot;: &quot;Elizabeth Hall&quot;,&quot;age&quot;: 91,&quot;color&quot;: &quot;#0e64ea&quot;&#125;// 结果2&#123;&quot;name&quot;: &quot;Michael Taylor&quot;,&quot;age&quot;: 61,&quot;color&quot;: &quot;#081086&quot;&#125; 官方的 JSFiddle 例子 不明白可以看看这个 参考文档使用Mock.js进行独立于后端的前端开发官方文档","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"mock","slug":"mock","permalink":"http://elickzhao.github.io/tags/mock/"}]},{"title":"js继承 extend mixin","slug":"js继承 extend mixin","date":"2017-06-27T15:13:20.000Z","updated":"2021-09-09T16:34:45.234Z","comments":true,"path":"2017/06/js继承 extend mixin/","link":"","permalink":"http://elickzhao.github.io/2017/06/js%E7%BB%A7%E6%89%BF%20extend%20mixin/","excerpt":"","text":"这两个说有用也有用,说没用也没用,这是因为必须这个类支持这两个方法才能用,如果不支持是用不了的现在又有个什么Composition 不过这个还没来得及看 mixin 1234var _ = require(&#x27;lodash&#x27;);var _db = require(&#x27;lodash-id&#x27;);_.mixin(_db); extend 12//_应该是lodash 这是个插件或者说类_.extend(app.locals, require(’./common/render_helpers’)); 参考文档 JavaScript-mixin实现多继承http://cnodejs.org/topic/5413e4ce8518442c62f3b503Mixin 已死，Composition 万岁","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"用 html5+js+css vue 开发个桌面应用 -Electron","slug":"用 html5+js+css vue 开发个桌面应用 -Electron","date":"2017-06-24T13:01:43.000Z","updated":"2021-09-09T16:34:45.702Z","comments":true,"path":"2017/06/用 html5+js+css vue 开发个桌面应用 -Electron/","link":"","permalink":"http://elickzhao.github.io/2017/06/%E7%94%A8%20html5+js+css%20vue%20%E5%BC%80%E5%8F%91%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%20-Electron/","excerpt":"简单说明想用js开发桌面现在有两个框架可以用 Electron 另外一个是 nwjs.但感觉还是用 Electron比较好,因为现在一些流行的软件是那这个弄的,比如说我现在用的 Atom ,VSCode 这两个软件都非常好用,而且漂亮.另外还有个原因是,他有中文文档.这样实在是方便太多了 编写这里主要编写个 Electron 启动配置文件.是 package.json 里的 main 字段的文件.注意：如果 main 字段没有在 package.json 声明，Electron会优先加载 index.js。剩下的就是编写自己的程序了就行了. 贴两个配置文件样本.一 这是官方的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;)// 保持一个对于 window 对象的全局引用，如果你不这样做，// 当 JavaScript 对象被垃圾回收， window 会被自动地关闭let winfunction createWindow() &#123; // 创建浏览器窗口。 win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) // 加载应用的 index.html。 win.loadURL(url.format(&#123; pathname: path.join(__dirname, &#x27;dist/index_prod.html&#x27;), protocol: &#x27;file:&#x27;, slashes: true &#125;)) //win.loadURL(&#x27;http://localhost:8080&#x27;) // 打开开发者工具。 win.webContents.openDevTools(); // 当 window 被关闭，这个事件会被触发。 win.on(&#x27;closed&#x27;, () =&gt; &#123; // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 与此同时，你应该删除相应的元素。 win = null &#125;)&#125;// Electron 会在初始化后并准备// 创建浏览器窗口时，调用这个函数。// 部分 API 在 ready 事件触发后才能使用。app.on(&#x27;ready&#x27;, createWindow)// 当全部窗口关闭时退出。app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit() &#125;&#125;)app.on(&#x27;activate&#x27;, () =&gt; &#123; // 在这文件，你可以续写应用剩下主进程代码。 // 也可以拆分成几个文件，然后用 require 导入。 if (win === null) &#123; createWindow() &#125;&#125;)// 在这文件，你可以续写应用剩下主进程代码。// 也可以拆分成几个文件，然后用 require 导入。","text":"简单说明想用js开发桌面现在有两个框架可以用 Electron 另外一个是 nwjs.但感觉还是用 Electron比较好,因为现在一些流行的软件是那这个弄的,比如说我现在用的 Atom ,VSCode 这两个软件都非常好用,而且漂亮.另外还有个原因是,他有中文文档.这样实在是方便太多了 编写这里主要编写个 Electron 启动配置文件.是 package.json 里的 main 字段的文件.注意：如果 main 字段没有在 package.json 声明，Electron会优先加载 index.js。剩下的就是编写自己的程序了就行了. 贴两个配置文件样本.一 这是官方的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;)// 保持一个对于 window 对象的全局引用，如果你不这样做，// 当 JavaScript 对象被垃圾回收， window 会被自动地关闭let winfunction createWindow() &#123; // 创建浏览器窗口。 win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) // 加载应用的 index.html。 win.loadURL(url.format(&#123; pathname: path.join(__dirname, &#x27;dist/index_prod.html&#x27;), protocol: &#x27;file:&#x27;, slashes: true &#125;)) //win.loadURL(&#x27;http://localhost:8080&#x27;) // 打开开发者工具。 win.webContents.openDevTools(); // 当 window 被关闭，这个事件会被触发。 win.on(&#x27;closed&#x27;, () =&gt; &#123; // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 与此同时，你应该删除相应的元素。 win = null &#125;)&#125;// Electron 会在初始化后并准备// 创建浏览器窗口时，调用这个函数。// 部分 API 在 ready 事件触发后才能使用。app.on(&#x27;ready&#x27;, createWindow)// 当全部窗口关闭时退出。app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit() &#125;&#125;)app.on(&#x27;activate&#x27;, () =&gt; &#123; // 在这文件，你可以续写应用剩下主进程代码。 // 也可以拆分成几个文件，然后用 require 导入。 if (win === null) &#123; createWindow() &#125;&#125;)// 在这文件，你可以续写应用剩下主进程代码。// 也可以拆分成几个文件，然后用 require 导入。 二 这个项目electron-anyproxy的例子 贴这个例子是因为这里有个程序启动页面,这个不错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const electron = require(&#x27;electron&#x27;);const menuTemplate = require(&#x27;./menu.js&#x27;);const ipcMain = electron.ipcMain;const app = electron.app;const Menu = electron.Menu;const BrowserWindow = electron.BrowserWindow;//启动页面参数let loadingParams = &#123; width: 580, height: 200, frame: false, show: false&#125;;//主页面参数let mainParams = &#123; width: 1300, height: 780, icon: __dirname + &#x27;/icon.png&#x27;, // titleBarStyle: &#x27;hidden-inset&#x27;, backgroundColor: &#x27;#fff&#x27;, show: false&#125;;let mainWindow;function createWindow() &#123; mainWindow = new BrowserWindow(mainParams); mainWindow.setTitle(require(&#x27;./package.json&#x27;).name); //setting in .vscode/launch.json //测试时可以这么写 但是必须启动静态服务器才行 if (process.env.NODE_ENV === &#x27;development&#x27;) &#123; console.log(&#x27;develop&#x27;); mainWindow.loadURL(&#x27;http://localhost:4000&#x27;); mainWindow.webContents.openDevTools(); &#125; else &#123; //完成后打包时 必须加载生成的静态页才行. //这个写法比较好 比上面那个简单些 mainWindow.loadURL(`file://$&#123;__dirname&#125;/client/index.html`); &#125; //这个监听页面加载完成显示 mainWindow.webContents.on(&#x27;did-finish-load&#x27;, () =&gt; &#123; mainWindow.show(); //主页面加载完毕显示,把启动页关闭. if (loadingScreen) &#123; loadingScreen.close(); &#125; &#125;); //测试工具 这是我添加的 mainWindow.webContents.openDevTools(); mainWindow.on(&#x27;closed&#x27;, () =&gt; &#123; mainWindow = null; &#125;);&#125;//创建启动页面function createLoadingScreen() &#123; //这里加了父页面的参数不知道是何用 loadingScreen = new BrowserWindow(Object.assign(loadingParams, &#123; parent: mainWindow &#125;)); if (process.env.NODE_ENV === &#x27;development&#x27;) &#123; loadingScreen.loadURL(&#x27;http://localhost:4000/loading.html&#x27;); &#125; else &#123; loadingScreen.loadURL(`file://$&#123;__dirname&#125;/client/loading.html`); &#125; loadingScreen.on(&#x27;closed&#x27;, () =&gt; loadingScreen = null); //这个感觉是没必要的 loadingScreen.webContents.on(&#x27;did-finish-load&#x27;, () =&gt; &#123; loadingScreen.show(); &#125;);&#125;//这是个菜单模版function createMenu() &#123; const menu = Menu.buildFromTemplate(menuTemplate); Menu.setApplicationMenu(menu);&#125;app.on(&#x27;ready&#x27;, () =&gt; &#123; createLoadingScreen(); createWindow(); createMenu();&#125;);app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit(); &#125;&#125;);app.on(&#x27;activate&#x27;, () =&gt; &#123; if (mainWindow === null) &#123; createWindow(); &#125;&#125;); 测试测试话就用 webpace 打开服务器测试就好.然后 electron 打开页面.但配置一定要这么写.这样你修改的时候浏览器和程序都会自动更新了,能即时发现问题. 1loadingScreen.loadURL(&#x27;http://localhost:4000/loading.html&#x27;); 打包打包需要安装另外一个插件electron-packager 这是简单的配置说明 location of project：项目所在路径 name of project：打包的项目名字 platform：确定了你要构建哪个平台的应用（Windows、Mac 还是 Linux） architecture：决定了使用 x86 还是 x64 还是两个架构都用 electron version：electron 的版本 optional options：可选选项 ignore : 忽略打包目录 (但我测试没什么效果啊) overwrite : 好像是打包后会把上一个删除 这个插件可以全局安装,这样就可以使用全局命令 electron-packager.当然也可以安装到项目里.然后放到 package.json里,使用 npm命令启动 1234&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot;, &quot;pack&quot;: &quot;electron-packager . Anyproxy --out=pack --overwrite --ignore=client/node_modules --icon=icon.icns&quot;&#125;, 打包会下载 electron 不同操作系统框架,但是这个包下载比较麻烦.还有另外一个打包方式这就是另一个方式 其实就是指定了一个镜像ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ electron-packager但这里还有个问题是, 同时启动了 webpack 不知道是干什么用这段出自 TooNote 这个项目 12345678910111213141516&#123; &quot;name&quot;: &quot;TooNote&quot;, &quot;version&quot;: &quot;0.3.0&quot;, &quot;description&quot;: &quot;Markdown based note app.&quot;, &quot;main&quot;: &quot;electron.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack -w&quot;, &quot;prod&quot;: &quot;NODE_ENV=production webpack&quot;, &quot;prod-win&quot;: &quot;set NODE_ENV=production&amp;&amp; webpack&quot;, &quot;run&quot;: &quot;electron .&quot;, &quot;start&quot;: &quot;npm-run-all -p -r dev run&quot;, &quot;cloud&quot;: &quot;CLOUD=1 npm-run-all -p -r dev run&quot;, &quot;build:osx&quot;: &quot;npm run prod&amp;&amp; ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ electron-packager . --overwrite --arch=all --icon=../assets/logo.icns --out=../dist --ignore=\\&quot;^/(?:api|component|models|modules|vuex)\\&quot; --ignore=\\&quot;/windows\\&quot; --ignore=\\&quot;\\\\.map$\\&quot; --ignore=\\&quot;node_modules/(?:d[$/]|babel-core|es5\\\\-ext|vue/src|vue/types|remarkable/dist|[\\\\w\\\\-]+/benchmark|[\\\\w\\\\-]+/test|[\\\\w\\\\-]+/docs|[\\\\w\\\\-]+/demo|brace/mode/[^m])\\&quot;&quot;, &quot;build:win&quot;: &quot;npm run prod-win&amp;&amp; set ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/&amp;&amp; electron-packager . --overwrite --arch=all --icon=../assets/logo.ico --out=../dist --win32metadata.CompanyName=\\&quot;TooNote\\&quot; --win32metadata.ProductName=\\&quot;TooNote\\&quot; --win32metadata.FileDescription=\\&quot;TooNote\\&quot; --ignore=\\&quot;^/(?:api|component|models|modules|vuex)\\&quot; --ignore=\\&quot;/osx\\&quot; --ignore=\\&quot;\\\\.map$\\&quot; --ignore=\\&quot;node_modules/(?:d[$/]|babel-core|es5\\\\-ext|vue/src|vue/types|remarkable/dist|[\\\\w\\\\-]+/benchmark|[\\\\w\\\\-]+/test|[\\\\w\\\\-]+/docs|[\\\\w\\\\-]+/demo|brace/mode/[^m])\\&quot;&quot; &#125;, 打包加密此时打包完毕,但是源文件目录会放在resources,这总让人感觉不太舒服.这时就需要 asar了. 安装 1npm install --save-dev asar 使用:同上面一样放在package.json 当作一个命令.当然也可以全局安装. 1234&quot;build:asar&quot;: &quot;asar pack . app.asar&quot;---npm run build:asar 发现打包完毕,把 app.asar 复制到 resources 里,然后把源文件目录 app 删除就好了启动看看吧 应该成功了 注意:下面这句可能是谣传啊,我测试后发现大小好像没有明显改变. 我又试了几次 完全没看出效果来 打包时建议用yarn安装npm包，因为npm install会在node_modules中安装隐藏目录，导致electron-packager打包的时候无法将electron等大文件删除，打包出来的软件包会很大。 安装 electron 包过慢（国内情况）的解决方法：临时方式： DEBUG=* ELECTRON_MIRROR=”https://npm.taobao.org/mirrors/electron/&quot; npm install electron加入DEBUG=*是为了查看调试信息，确认下载源是否替换成功。我再windows下使用这个命令不好使啊 扩展包Electron社区 这里有很多扩展包|包名|说明||–|–||electron-packager| 打包成绿色包 直接能用|electron-builder| 打包成安装包|vue-electron |好像是让vue程序 可以用electron APIs|electron-vue |这是个模版项目 . vue-init simulatedgreg/electron-vue my-project 这样使用.||linux和windows命令不同要注意.这里的是windows的,linux是 vue init||asar|可以把程序打包成asar,这样看起来更简洁,而且容易出现胡乱改动,造成程序不可用| electron-vue 命令解释pack: 这是指原来的build 打包静态页 打包后放在 dist/electron里pack:renderer按道理这个应该放在dist/web下的但却没有build 结果这个是打包成exe文件 还有一点千万不要用 electron-builder 真的很差 不能选路径 界面很丑 待解决只是把vue打包好的静态文件加载到了 Electron 这一步倒是很简单我现在想做到的是,vue 不用 build,直接用 Electron 打包成程序,但好像是不行啊.打完包后源文件还在,而且不能删除,这个好像有点不对吧,应可以删除的吧,以后可以看看 第一个问题解决方法经过查看是,把两部写成一个命令就好了第二个问题使用asar打包成asar包,就可以把源文件给删除了.其实也是只防君子不防小人. 参考文档用HTML5+JS开发跨平台的桌面应用用Electron开发桌面应用Electron Github仓库Electron 中文文档nwjs官方网站这里有两个例子,其中一个是vue的【Electron】Electron开发入门（五）：项目打包XCel 项目总结 - Electron 与 Vue 的性能优化TooNotez 一个实例项目使用 Electron 开发一款理财计算器从零开始使用Electron + jQuery开发桌面应用 （二） 打包应用","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"Electron","slug":"Electron","permalink":"http://elickzhao.github.io/tags/Electron/"}]},{"title":"ES6 新函数 Promise 简介","slug":"ES6 新函数 Promise 简介","date":"2017-06-23T14:38:40.000Z","updated":"2021-09-09T16:34:44.897Z","comments":true,"path":"2017/06/ES6 新函数 Promise 简介/","link":"","permalink":"http://elickzhao.github.io/2017/06/ES6%20%E6%96%B0%E5%87%BD%E6%95%B0%20Promise%20%E7%AE%80%E4%BB%8B/","excerpt":"这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。 1234567891011121314151617function runAsync()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&#x27;执行完成&#x27;); //执行成功后 执行这个回调 resolve(&#x27;随便什么数据&#x27;); //reject是失败 &#125;, 2000); &#125;); return p; &#125;runAsync().then(function(data)&#123; console.log(data+&#x27;-------&#x27;); //后面可以用传过来的数据做些其他操作 //......&#125;); 功能相同 12345678910function runAsync(callback)&#123; setTimeout(function()&#123; console.log(&#x27;执行完成&#x27;); callback(&#x27;随便什么数据&#x27;); &#125;, 2000);&#125;runAsync(function(data)&#123; console.log(data);&#125;); 优点: 效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。","text":"这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。 1234567891011121314151617function runAsync()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&#x27;执行完成&#x27;); //执行成功后 执行这个回调 resolve(&#x27;随便什么数据&#x27;); //reject是失败 &#125;, 2000); &#125;); return p; &#125;runAsync().then(function(data)&#123; console.log(data+&#x27;-------&#x27;); //后面可以用传过来的数据做些其他操作 //......&#125;); 功能相同 12345678910function runAsync(callback)&#123; setTimeout(function()&#123; console.log(&#x27;执行完成&#x27;); callback(&#x27;随便什么数据&#x27;); &#125;, 2000);&#125;runAsync(function(data)&#123; console.log(data);&#125;); 优点: 效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。 123456789101112runAsync1().then(function(data)&#123; console.log(data); return runAsync2();&#125;).then(function(data)&#123; console.log(data); return runAsync3();&#125;).then(function(data)&#123; console.log(data);&#125;); reject的用法 123456789101112131415161718192021222324252627function getNumber()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; var num = Math.ceil(Math.random()*10); //生成1-10的随机数 if(num&lt;=5)&#123; resolve(num); &#125; else&#123; reject(&#x27;数字太大了&#x27;); &#125; &#125;, 2000); &#125;); return p; &#125;getNumber().then( function(data)&#123; console.log(&#x27;resolved&#x27;); console.log(data); &#125;, function(reason, data)&#123; console.log(&#x27;rejected&#x27;); console.log(reason); &#125;); catch的用法 12345678910getNumber().then(function(data)&#123; console.log(&#x27;resolved&#x27;); console.log(data); console.log(somedata); //此处的somedata未定义&#125;).catch(function(reason)&#123; console.log(&#x27;rejected&#x27;); console.log(reason);&#125;); 注意:效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。 all的用法Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调 1234567891011121314151617181920212223242526272829303132333435363738394041function runAsync1()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&#x27;第一个执行完成&#x27;); //执行成功后 执行这个回调 resolve(&#x27;随便什么数据&#x27;); //reject是失败 &#125;, 2000); &#125;); return p; &#125;function runAsync2()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&#x27;第二个执行完成&#x27;); //执行成功后 执行这个回调 resolve(&#x27;随便什么数据&#x27;); //reject是失败 &#125;, 2000); &#125;); return p; &#125;function runAsync3()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&#x27;第三个执行完成&#x27;); //执行成功后 执行这个回调 resolve(&#x27;随便什么数据&#x27;); //reject是失败 &#125;, 2000); &#125;); return p; &#125;Promise .all([runAsync1(), runAsync2(), runAsync3()]) .then(function(results)&#123; console.log(results);&#125;); race的用法all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。 上面例子的测试 参考文档这篇文章好棒Javascript 中的神器——Promise大白话讲解Promise（一）","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"webpack-dev-server 的 Node.js Api方式和CLI 方式 两种用法","slug":"webpack-dev-server 的 Node.js Api方式和CLI 方式 两种用法","date":"2017-06-22T14:40:27.000Z","updated":"2021-09-09T16:34:45.465Z","comments":true,"path":"2017/06/webpack-dev-server 的 Node.js Api方式和CLI 方式 两种用法/","link":"","permalink":"http://elickzhao.github.io/2017/06/webpack-dev-server%20%E7%9A%84%20Node.js%20Api%E6%96%B9%E5%BC%8F%E5%92%8CCLI%20%E6%96%B9%E5%BC%8F%20%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95/","excerpt":"","text":"CLI 方式会比Node.js Api方式简单很多.Node.js Api方式 如果配置热启动 还需要配置 webpack.HotModuleReplacementPlugin 而且有时还得安装 webpack-hot-middleware 额外的插件 还有需要特别注意的地方是 publicPath必填使用Node.js Api方式 结果还是不能自动更新.因为这个方法实在问题太多,最后还是使用了命令行 还有一点 入口配置一定要这么写 entry: [&quot;webpack-dev-server/client?http://localhost:8080&quot;], 12345678910111213141516171819202122//就到这里吧 热更新也做了 可惜就是不自动刷新浏览器//[WDS] App hot update... (执行到这里就不走了)//dev-server.js:45 [HMR] Checking for updates on the server... (就差这一句 不知道为啥)//这个写法真心没有命令行简单啊const server = new WebpackDevServer( compiler, &#123; contentBase: path.join(__dirname, &#x27;../&#x27;), quiet: true, publicPath: &#x27;/dist/&#x27;, //publicPath必填 否则就不好使 hot: true, compress: true, historyApiFallback: true, setup(app, ctx) &#123; app.use(hotMiddleware) ctx.middleware.waitUntilValid(() =&gt; &#123; resolve() &#125;) &#125; &#125;)server.listen(8080) 直接看这里吧http://www.cnblogs.com/hhhyaaon/p/5664002.html","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"webpack","slug":"webpack","permalink":"http://elickzhao.github.io/tags/webpack/"}]},{"title":"nodejs 的 cross-env 的使用及介绍","slug":"nodejs 的 cross-env 的使用及介绍","date":"2017-06-21T15:11:58.000Z","updated":"2021-09-09T16:34:45.335Z","comments":true,"path":"2017/06/nodejs 的 cross-env 的使用及介绍/","link":"","permalink":"http://elickzhao.github.io/2017/06/nodejs%20%E7%9A%84%20cross-env%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"这个小插件主要解决 windows 下 无法设置 NODE_ENV=development 这个东西. 因为程序可以根据 NODE的环境变量,做出不同选择. 这个在 linux 下是可以设置的,但在 windows 下不行 安装 1npm install across-env --save-dev 使用在package.json里,需要设置环境的地方加上这句就好了 1cross-env NODE_ENV=development 参考文档使用cross-env解决跨平台设置NODE_ENV的问题","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"关于child_process中的exec和spawn","slug":"关于child_process中的exec和spawn","date":"2017-06-19T13:41:49.000Z","updated":"2021-09-09T16:34:45.534Z","comments":true,"path":"2017/06/关于child_process中的exec和spawn/","link":"","permalink":"http://elickzhao.github.io/2017/06/%E5%85%B3%E4%BA%8Echild_process%E4%B8%AD%E7%9A%84exec%E5%92%8Cspawn/","excerpt":"","text":"这是篇转发,因为原文写的实在是太明白了. http://cnodejs.org/topic/507285c101d0b80148f7c538 开始学习child_process模块的时候以为spawn可以直接运行命令, 后来发现这是一个小陷阱就拿出来和大家分享一下. 先说下我碰到的情况由于在windos下写的所以根据docs上的例子我就写出了这么一句代码:”require(“child_process”).spawn(“dir”), 这么写是会有错误的,用error接受到的数据是没有此文件. 而用exec就不会有问题,于是得到了以前的猜想. 大家都知道在linux下, ls命令对应的是一个文件, 而在windows下是做为cmd的内置命令的. 所以像我那样写是会报错. 12345678910111213于是我查看了child_process的源码发现spawn是这样定义的var spawn = exports.spawn = function(file, args, options); 也就是说他传入的应该是一个文件, 例如ping, cmd等. 而exec的源码中有一段这样的代码: if (process.platform === &#x27;win32&#x27;) &#123;file = &#x27;cmd.exe&#x27;;args = [&#x27;/s&#x27;, &#x27;/c&#x27;, &#x27;&quot;&#x27; + command + &#x27;&quot;&#x27;];// Make a shallow copy before patching so we don&#x27;t clobber the user&#x27;s// options object.options = util._extend(&#123;&#125;, options);options.windowsVerbatimArguments = true;&#125; else &#123; file = &#x27;/bin/sh&#x27;; args = [&#x27;-c&#x27;, command];&#125; 所以想使用内置命令可以直接使用exec或者把spawn改成spawn(“cmd.exe”,[“\\s”, “\\c”, “dir”]); 总结起来就是spawn是调用一个文件! 不要被docs上的child_process.spawn(command, [args], [options])中的command给骗了","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"七牛,又拍云,阿里oss这类网站的了解","slug":"七牛,又拍云,阿里oss这类网站的了解","date":"2017-06-15T15:29:59.000Z","updated":"2021-09-09T16:34:45.517Z","comments":true,"path":"2017/06/七牛,又拍云,阿里oss这类网站的了解/","link":"","permalink":"http://elickzhao.github.io/2017/06/%E4%B8%83%E7%89%9B,%E5%8F%88%E6%8B%8D%E4%BA%91,%E9%98%BF%E9%87%8Coss%E8%BF%99%E7%B1%BB%E7%BD%91%E7%AB%99%E7%9A%84%E4%BA%86%E8%A7%A3/","excerpt":"","text":"用来给WordPress加速（用作图床、下载、CDN等） 七牛云是和国内第二大CDN提供商网宿合作的，所以他们的加速效果应该是非常给力的。根据个人的实际体验来看，确实很不错。七牛云可以为站点提供静态文件加速，比如js、CSS、图片、音乐等文件都可以缓存在七牛云的服务器上，当有访问请求时，大量的静态资源由七牛云承担了，这会极大的提升网页打开速度。 根据PING测试，七牛云的CDN节点远远多于安全宝、加速乐一类。不仅国内节点数有压倒性优势，在国外还有美国、英国等节点，这绝对是其他免费CDN做不到的。同时还赠送了10GB存储空间和每月10GB流量，相信有些比较爱折腾的站长已经用上了，如果您还没用七牛的话，推荐您使用： 这类网站主要的用户是做CDN加速.其次是做图床和静态分离.这样能好加快应用速度吧. 参考文档七牛云使用心得又拍云解决方案简介","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}]},{"title":"node.js 自建简易服务","slug":"node.js 自建简易服务","date":"2017-06-14T15:35:18.000Z","updated":"2021-09-09T16:34:45.317Z","comments":true,"path":"2017/06/node.js 自建简易服务/","link":"","permalink":"http://elickzhao.github.io/2017/06/node.js%20%E8%87%AA%E5%BB%BA%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1/","excerpt":"废话先不多说,代码就是如下这么简单. 1234567891011var express = require(&#x27;express&#x27;)var app = express()app.use(express.static(&#x27;./dist&#x27;)) //指定目录app.get(&#x27;/&#x27;, function (req, res) &#123; res.send(&#x27;Hello World&#x27;)&#125;)app.listen(3000) 下面这个是参考文档里的写法 123456789var http = require(&#x27;http&#x27;);var express = require(&#x27;express&#x27;);var app = express();app.use(&quot;/public&quot;, express.static(__dirname + &#x27;/public&#x27;)); //访问路径写到一起了// 创建服务端http.createServer(app).listen(&#x27;80&#x27;, function() &#123; console.log(&#x27;启动服务器完成&#x27;);&#125;); 然后执行 node app.js 就可以启动服务器了. app.js 就是上面配置所保存的文件名.","text":"废话先不多说,代码就是如下这么简单. 1234567891011var express = require(&#x27;express&#x27;)var app = express()app.use(express.static(&#x27;./dist&#x27;)) //指定目录app.get(&#x27;/&#x27;, function (req, res) &#123; res.send(&#x27;Hello World&#x27;)&#125;)app.listen(3000) 下面这个是参考文档里的写法 123456789var http = require(&#x27;http&#x27;);var express = require(&#x27;express&#x27;);var app = express();app.use(&quot;/public&quot;, express.static(__dirname + &#x27;/public&#x27;)); //访问路径写到一起了// 创建服务端http.createServer(app).listen(&#x27;80&#x27;, function() &#123; console.log(&#x27;启动服务器完成&#x27;);&#125;); 然后执行 node app.js 就可以启动服务器了. app.js 就是上面配置所保存的文件名. 上面用的是express,用http-server的话就更简单,不需要自己写配置直接用命令就可以启动了.不过这个需要全局安装才行,要不不会有命令的. 1234//如果你的当前项目中存在 public 文件夹,那么默认静态目录会指定到 public//如果没有 public 文件夹,那么静态目录就是 根目录//所以要哪个目录充当静态服务器的根目录 就得进入哪个目录执行下面命令http-server -a 127.0.0.1 -p 7070 下面开始唠叨: 因为现在做动静分离的后台程序,所以需要前端的静态服务器.在本地时单击打开静态文件,有时因为所需插件原因.也是无法打开的,必须放在静态服务器.所以这时就需要上面的东西了.关于设置静态服务器的必要性 看看这里 是否有必要为网站的静态资源设置一个单独的服务器?能了解到不少东西. 这两个搭建服务器的插件 express和 http-server 都得先安装才能用.不过呢 因为项目里有时用到别的插件.比如 webpace的时候 express就不用特别安装了.因为已经包涵在里面.但是http-server使用的范围不是那么广,所以必须安装. 还有就是下面参考文档里说,http-server比express要小巧,不过从下载的包来看,并不是如此.可能指的的是功能上吧. 而且express可以操作数据库,这可能对我要写的程序有点用处. ##参考文档Node.js用6行代码1个JS文件搭建一个HTTP静态服务器随笔 http-server 快速创建node.js 静态服务器http-server Angular.js 后端node服务首选 轻量级替换 Express 解决方案","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"vue + iview后台实例问题总结  vue学习问题总结","slug":"vue + iview后台实例问题总结  vue学习问题总结","date":"2017-06-13T15:20:45.000Z","updated":"2021-09-09T16:34:45.422Z","comments":true,"path":"2017/06/vue + iview后台实例问题总结  vue学习问题总结/","link":"","permalink":"http://elickzhao.github.io/2017/06/vue%20+%20iview%E5%90%8E%E5%8F%B0%E5%AE%9E%E4%BE%8B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%20%20vue%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"vue组件模版编写规则main.vue 在组件里 所有的样式必须放在一个 &lt;div&gt;&lt;/div&gt; 标签里 否则会出错. 这个标签可以指定 默认为 class=index 这个看教程时已经知道,只是做的时候又给忘记了 vue组件开始之前执行组件方法的方法.呵呵 Vue.nextTick(function () { }) 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 因为有的插件需要操作DOM 但是DOM还没创建出来时 会出现问题 这个也是如此无法用this 我理解的关于Vue.nextTick()的正确使用 created:function(){} 这个也可以的 这是钩子程序 但是这个时期 DOM没有创建出来 mounted: function (){} 这个也是vue生命周期中一个钩子,这个就是加载完组件,生成了DOM的时候,所这个可以用,需要对DOM进行操作的程序可以放在这里执行 12345678// 记性真是不好上一次还知道怎么用,下一次就又忘了 现在放在这export default &#123; mounted: function () &#123; particlesJS(&#x27;particles-js&#x27;, particles_config) &#125;, methods: &#123; ... &#125;","text":"vue组件模版编写规则main.vue 在组件里 所有的样式必须放在一个 &lt;div&gt;&lt;/div&gt; 标签里 否则会出错. 这个标签可以指定 默认为 class=index 这个看教程时已经知道,只是做的时候又给忘记了 vue组件开始之前执行组件方法的方法.呵呵 Vue.nextTick(function () { }) 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 因为有的插件需要操作DOM 但是DOM还没创建出来时 会出现问题 这个也是如此无法用this 我理解的关于Vue.nextTick()的正确使用 created:function(){} 这个也可以的 这是钩子程序 但是这个时期 DOM没有创建出来 mounted: function (){} 这个也是vue生命周期中一个钩子,这个就是加载完组件,生成了DOM的时候,所这个可以用,需要对DOM进行操作的程序可以放在这里执行 12345678// 记性真是不好上一次还知道怎么用,下一次就又忘了 现在放在这export default &#123; mounted: function () &#123; particlesJS(&#x27;particles-js&#x27;, particles_config) &#125;, methods: &#123; ... &#125; 4.beforeRouteEnter(to, from, next) {} 这是vue-router的一个钩子,在进入路由之前调用一个函数,这个也是可行的,这个有时会有问题 如果路由没跳转,那么就不会执行了 但是无法执行组件的方法,因为this是不存在的用另一个方法就可以使用组件内部的方法了,而且更神器的是插件居然执行了. new Particleground.particle(&#39;#canvas&#39;, options); 这个插件一直不执行的,只有触发他所在的方法handleStart()才会执行. 12345678910111213141516171819beforeRouteEnter(to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 vm.handleStart() &#125;);&#125;, methods: &#123; handleStart() &#123; var options = &#123; color: &#x27;#FFF&#x27;, //[&#x27;#2d8cf0&#x27;, &#x27;#19be6b&#x27;, &#x27;#ff9900&#x27;, &#x27;#ed3f14&#x27;], num: 100, range: 300, linewidth: 1, maxSpeed: 1, maxR: 5, &#125; //这个就更奇葩了.因为是类 不是函数 结果必须在方法里靠点击才能运行 其他的一概不执行 而且他运行也不像文档里写的必须引入particles.js 也够怪的 new Particleground.particle(&#x27;#canvas&#x27;, options); console.log(&quot;cccccccccccccc&quot;); &#125; 5.又找到个办法可以使用 new Particleground.particle(&#39;#canvas&#39;, options);就是这么些 1234567891011121314151617 var options = &#123; color: &#x27;#FFF&#x27;, //[&#x27;#2d8cf0&#x27;, &#x27;#19be6b&#x27;, &#x27;#ff9900&#x27;, &#x27;#ed3f14&#x27;], num: 100, proximity:100, //点点连线距离,只有两点小于这个距离才会连线,值太大的话连线会很密的 range: 1300, //点点连线的范围 值越大范围越大 太小的话即使达到距离 也有些点不连线 linewidth: 1, maxSpeed: 1, maxR: 5, lineShape:&#x27;cube&#x27;,&#125;//这个效果和上面的 beforeRouteEnter(to, from, next) &#123;&#125; 是一直的 而且我这次升级了 Particleground//现在叫JParticles 参数更多了一些//呵呵 又发现个区别啊 document.ready 就不可以 只能用 window.onloadwindow.onload = function()&#123; new JParticles.particle(&#x27;#canvas&#x27;, options);&#125; 6.这三个的加载顺序很有趣, beforeRouteEnter -&gt; Vue.nextTick -&gt; created 看来created是创建组件的时候 7.放在export default {}的js代码也会被执行的,而且好像是页面渲染完成后执行的. 这句当时不知道怎么写的,好像是错了. 这里只能放,函数和属性,是没法使用js代码段的 老插件及不能用NPM安装的插件引用用webpack创建的项目,引用这种插件很费事.而且不能用CND,也许能用只是我没找到方法.看下面的文章,有好几个方法,不过都很麻烦.不过我发现好像直接用 import particlesJS from &#39;../libs/particles.js&#39;;也是能找到正确位置的,但是否可用没测试 以后再说吧. 下面这个方法是我现在用的.var particlesJS = require(&#39;exports-loader?window.particlesJS!../libs/particles.js&#39;);记住一定用 npm 安装 exports-loader 这样就可以使用自己下载的插件了.而且还解决了另外一个问题.以为particlesJS是个老插件,他没有现代的模块方式开发,所以用npm安装了,import了也是无法使用的.所以必须用exports-loader转换一下,这样particlesJS的方法就可用了. 参考文档如何在 vue 项目里正确地引用 jquery 和 jquery-ui的插件 插件的选择,有些插件不可以用.这次就遇到了这个问题.一 有可能是插件太老,引用后无法使用.会提示这个不是方法.二 就是这个插件写的有问题,使用时是个类必须new 比如 new Particleground.particle(&#39;#canvas&#39;, options); 这个不是方法,所以无法自动执行,必须放在vue的方法里触发才可以.幸好如上面讲到的,用vue-router里的钩子程序能触发 所以就一点用都没有了. 至于这个插件的写法以后研究下. webpace打包后单击静态文件显示空白内容看到 &lt;router-view&gt;&lt;/router-view&gt; 加载内容为空.判断为这个插件出问题了. 最后发现,是 vue-router 的配置,mode 这个有三个选项 &quot;hash&quot; | &quot;history&quot; | &quot;abstract&quot;必须选择 hash,否则的话必须用静态服务器访问才行,单击打开文件是不行的.history的 url路径会美观不少,不过就是必须用静态服务器了 注意: 在用本地服务器测试的时候. 用nodejs写的简易服务器,必须装载 express模块.我这里并没有把express装到全局里,所以在其他目录是不好用的.但是项目目录里因为webpace使用了express,所以没有特别装也没问题. 用 phpstudy 充当服务器的时候,必须指定域名.如果不指定域名的话也是一片空白的. 12345// 路由配置const RouterConfig = &#123; mode: &#x27;hash&#x27;, //哦 的确如此 必须用hash才能打包成静态页 routes: Routers&#125;; Node.js Api方式使用就是把命令行模式,转换写到程序里.不过这个方式写起来太复杂了哦 热启动还有一点 如果不行这么写 entry: [&quot;webpack-dev-server/client?http://localhost:8080&quot;], 123456789101112131415161718192021222324const compiler = webpack(rendererConfig) //就到这里吧 热更新也做了 可惜就是不自动刷新浏览器 //[WDS] App hot update... (执行到这里就不走了) //dev-server.js:45 [HMR] Checking for updates on the server... (就差这一句 不知道为啥) //这个写法真心没有命令行简单啊 const server = new WebpackDevServer( compiler, &#123; contentBase: path.join(__dirname, &#x27;../&#x27;), quiet: true, publicPath: &#x27;/dist/&#x27;, hot: true, compress: true, historyApiFallback: true, setup(app, ctx) &#123; app.use(hotMiddleware) ctx.middleware.waitUntilValid(() =&gt; &#123; resolve() &#125;) &#125; &#125; ) server.listen(8080) webpack-dev-server 的 Node.js Api方式和CLI 方式 两种用法 webpack输出文件设置这里 path已经设置publicPath不设置也可以,设置的话有可能出现引入错误filename 也不用设置位置了.这样直接全部生成在 dist 目录下如果publicPath设置了,css和js会保存在那里.但是html会在根目录 注意: 总是忘记啊 json 配置文件里是不能添加注释的 否则会报错 是 package.json 注释会报错 12345678910111213output: &#123; path: path.join(__dirname, &#x27;./dist&#x27;)&#125;,output: &#123; publicPath: &#x27;&#x27;, filename: &#x27;[name].[hash].js&#x27;, chunkFilename: &#x27;[name].[hash].chunk.js&#x27;&#125;, new HtmlWebpackPlugin(&#123; filename: &#x27;index_prod.html&#x27;, template: &#x27;./src/template/index.ejs&#x27;, inject: false &#125;) 在iview里build和dev模版在iview里dev的时候用的是根目录的 index.html 因为dev的时候是css等静态文件是不加版本号所以可以在index.html里写死 &lt;script type=&quot;text/javascript&quot; src=&quot;/dist/main.js&quot;&gt;&lt;/script&gt; 在build的时候,用的是 src/template/index.ejs 所以这里必须加这个 &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= htmlWebpackPlugin.files.js[1] %&gt;&quot;&gt;&lt;/script&gt; 否则就无法添加带版本号的静态文件了 所以 在iview里 build 和 dev 是分开的. 他们的 config文件也不一样所以修改时要注意 这里需要修改啊现在遇到的问题是我的 粒子插件的配置文件遇到了跨域请求问题. 而且他不能自动拷贝到dist目录下.虽然报错写着这个,目录没有这个文件,可是拷过去依然没用 版本号插件输出信息问题因为在做 electron 的时候,打包时需要用个效果插件.但是process其他信息都不会输出,唯独这个会输出个信息,应该是那里有问题,但是并影响使用,所以到现在也没仔细研究.就算 webpack 的显示进度 也会被他打断. 这个以后有空解决下吧 还有一点是在强调下,json不能有注释. 唉 总忘记 这句是错的是 package.json不能有注释 123456789101112131415161718192021 test: /\\.vue$/, loader: &#x27;vue-loader&#x27;, options: &#123; loaders: &#123; css: ExtractTextPlugin.extract(&#123; use: [&#x27;css-loader&#x27;, &#x27;autoprefixer-loader&#x27;], //加这个 autoprefixer-loader 就报错 有个输出 以后再考虑吧 反正现在可以用了 就是不是最完美样子 //use: [&#x27;css-loader&#x27;], fallback: &#x27;vue-style-loader&#x27; &#125;) &#125; &#125;&#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; //这里去除这个插件就会找不到带版本号的插件了 use: [&#x27;css-loader?minimize&#x27;, &#x27;autoprefixer-loader&#x27;], // 这个也是 这个autoprefixer-loader 好像是版本选择 //use: [&#x27;css-loader?minimize&#x27;], fallback: &#x27;style-loader&#x27; &#125;)&#125;, 简易服务器返回静态文件这么写1234app.get(&#x27;/&#x27;, function (req, res) &#123; //res.send(&#x27;Hello World&#x27;) //这里注意下因为生成的静态页不是index.html标准名称 所以不会显示 res.sendFile( path.join(__dirname, &#x27;./dist/index_prod.html&#x27;)) //一定是绝对路径&#125;) 使用 yarn 千万要注意yarn 虽然速度比 npm 快很多,但总会出现莫名其妙的问题.我有个项目前两天运行正常,今天再打开一大堆报错.说各种文件找不到用 yarn 重装一遍也不行,没办法用 npm重装 一切都好了 所以 用yarn千万要小心, 要不项目一开始就用,千万别中间再用 webpack复制指定目录到dist生成目录使用这个插件copy-webpack-plugin就ok了用法很简单 12345678910var CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;);var path = require(&#x27;path&#x27;); plugins: [ new CopyWebpackPlugin([&#123; //还有就是这个参数必须是数组才行,哪怕只有一个 from:&#x27;./src/assets&#x27;, to:&#x27;assets&#x27; //因为上面已经有了输出路径,所以不需要写两次了 &#125;]), ...... ] vue报错 template or render function not defined问题产生: 独立构建-vs-运行时构建 这就是问题根源,webpack运行的不是完整vue,所以不包含解析template.这里需要在webpack设置里天上这句. 123alias: &#123; &#x27;vue&#x27;: &#x27;vue/dist/vue.esm.js&#x27; &#125; 有的地方说是 vue.common.js 其实一样看下面官方说明不同构建版本的解释说明 问题解决:但是我这个不是这么解决的,这还多亏了,vue-router里的提示 12345components:&#123; //原本应该这么写 ff:require([&#x27;./aa.vue&#x27;]) 就可以了 不知道这个 resolve 是哪里起的作用以后查查 ff:(resolve) =&gt; require([&#x27;./aa.vue&#x27;], resolve) //这么写组件就可以用了&#125; 下面两个文章都不错,第一个讲解的非常深入,第二个是最开始的解决办法,现在好像不实用了,不过也可以了解下问题的起因. 从一个奇怪的错误出发理解 Vue 基本概念vue2.0组件注册的问题","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"npm安装时报错 却无明确提示的原因","slug":"npm安装时报错 却无明确提示的原因","date":"2017-06-12T14:45:23.000Z","updated":"2021-09-09T16:34:45.341Z","comments":true,"path":"2017/06/npm安装时报错 却无明确提示的原因/","link":"","permalink":"http://elickzhao.github.io/2017/06/npm%E5%AE%89%E8%A3%85%E6%97%B6%E6%8A%A5%E9%94%99%20%E5%8D%B4%E6%97%A0%E6%98%8E%E7%A1%AE%E6%8F%90%E7%A4%BA%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"","text":"唉 今天又遇到了.只不过是自己脑袋短路了.我想使用 element-ui 结果创建个项目文件夹也叫 element-ui.所以进去之后 如何 npm i element-ui -S 都不好使.后来发现了问题,就改了文件名,一切就ok了所以 切记 切记啊!","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"}]},{"title":"codepen使用方法","slug":"codepen使用方法","date":"2017-06-11T14:34:05.000Z","updated":"2021-09-09T16:34:45.116Z","comments":true,"path":"2017/06/codepen使用方法/","link":"","permalink":"http://elickzhao.github.io/2017/06/codepen%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"嗯 现在基本用法都会了,如果忘记就看下面网站吧.有点复制了.以后遇到需要提醒的再写. 哦 对了 现在快捷键已经和下面文章里写的不同了.如果想单独放大一个编辑栏,比如js的,就点右边的倒三角符号,然后能看到maxjsEditor 这个就是扩大编辑区域了.不过这个扩大了也没有jsbin用起来舒服.不过jsbin保存实在太恶心了.只是用Github的gist所以保存很烦.而且jsbin好像不能对外分享,所以用那个写一下还可以,如果要分享还是用别的吧. 参考文档见多识广：CodePen项目网站简介","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"}]},{"title":"JSFiddle使用说明","slug":"JSFiddle使用说明","date":"2017-06-10T13:00:58.000Z","updated":"2021-09-09T16:34:44.939Z","comments":true,"path":"2017/06/JSFiddle使用说明/","link":"","permalink":"http://elickzhao.github.io/2017/06/JSFiddle%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"额.下面的文章写的超详细,真的不想再复制一遍了.这里就把菜单说明一下吧,因为这个总是糊涂. 保存前保存后 Save: 将当前编辑的内容保存到服务器上，方便下次调用和分享。如果你只是想测试用的话是不需要保存的。 Update： 将当前的状态保存为一个版本。类似于版本控制，会在URL后面加上一个数字。之前的版本还会存在，方便后期调试。 Fork: 把现在的项目复制到一个新的文件当中。 Base: 出现在没有进行Update的项目当中，表明这是最初效果，只是一个标识符。 Set as base: 出现在非初始版本的项目中。可点击，作用是把当前版本变成最初版本，原先的初始版本会被删除。 Share: 提供了分享的三种形式。 Run: 点击运行代码，结果会在result中显示。 Debug on mobile: 在手机端调试。 Tidyup: 格式化代码。 JSHint: 调试js代码。 参考文档在线前端代码展示分享神器-JSFiddle","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"}]},{"title":"three.js学习及小例子","slug":"three.js学习及小例子","date":"2017-06-07T14:32:01.000Z","updated":"2021-09-09T16:34:45.411Z","comments":true,"path":"2017/06/three.js学习及小例子/","link":"","permalink":"http://elickzhao.github.io/2017/06/three.js%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%B0%8F%E4%BE%8B%E5%AD%90/","excerpt":"","text":"一个例子 自己弄的小方块 粒子波动 参考文档three.js中文文档WebGL入门教程1 - 3D绘图基础知识 学习文章three.js实现的波浪效果WebGL学习笔记-使用3D引擎threeJS实现星空粒子移动 第一篇就画一个球体吧Three.js基础探寻四——立方体、平面与球体","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"前端背景特效总结一波","slug":"前端背景特效总结一波","date":"2017-06-03T15:31:11.000Z","updated":"2021-09-09T16:34:45.566Z","comments":true,"path":"2017/06/前端背景特效总结一波/","link":"","permalink":"http://elickzhao.github.io/2017/06/%E5%89%8D%E7%AB%AF%E8%83%8C%E6%99%AF%E7%89%B9%E6%95%88%E6%80%BB%E7%BB%93%E4%B8%80%E6%B3%A2/","excerpt":"魔幻线条curvejs 这个感觉实用性不强 粒子特效插件particles-自己的文章JParticles是多个特效的一个整合 shape-shifter 用粒子组成文字shape-shifter Demo anime.js 动画库 其实跟上面的不同 但可以用这个做许多特效 而且例子不错 GreenSock-JS 动画库 这个动画的例子真的很棒GreenSock-JS DEMOTweenMax的实例TweenMax的实例2 看来TweenMax用来做菱形这个背景应该是很拿手的 有空可以看一下","text":"魔幻线条curvejs 这个感觉实用性不强 粒子特效插件particles-自己的文章JParticles是多个特效的一个整合 shape-shifter 用粒子组成文字shape-shifter Demo anime.js 动画库 其实跟上面的不同 但可以用这个做许多特效 而且例子不错 GreenSock-JS 动画库 这个动画的例子真的很棒GreenSock-JS DEMOTweenMax的实例TweenMax的实例2 看来TweenMax用来做菱形这个背景应该是很拿手的 有空可以看一下 HTML5 Background Video H5腾讯QQ登录界面背景动画特效 不断生成的粒子特效 其实是three.js的一个例子HTML5 3D 粒子波浪动画特效 See the Pen vZYYyj by elick (@elick) on CodePen. 菱形背景特效 固定版菱形背景特效 [用的是这个 trianglify插件](https://github.com/qrohlf/trianglify) 用three.js做的低多边形 这个是我比较喜欢的JS Bin on jsbin.com","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"particlesJS 粒子背景的库 使用简介","slug":"particlesJS 粒子背景的库 使用简介","date":"2017-06-02T15:28:06.000Z","updated":"2021-09-09T16:34:45.346Z","comments":true,"path":"2017/06/particlesJS 粒子背景的库 使用简介/","link":"","permalink":"http://elickzhao.github.io/2017/06/particlesJS%20%E7%B2%92%E5%AD%90%E8%83%8C%E6%99%AF%E7%9A%84%E5%BA%93%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/","excerpt":"使用方法: 123456789101112131415161718192021&lt;!-- 动画容器 --&gt;&lt;div id=&quot;particles-js&quot;&gt;&lt;/div&gt;&lt;!-- 库引入 --&gt;&lt;script src=&quot;particles.js&quot;&gt;&lt;/script&gt;&lt;!-- 配置及使用 --&gt;&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;style&gt;/*这句很关键 如果不设置的话大小总会出现偏移的 不过按照官方的说应该是 #particles-js 也就是容器id 可不知道为啥是canvas类名还有个问题就是我这个文件不知道从哪里来的,好像跟从官方复制的不一样,把Github上的复制到文件里就报错了*/.particles-js-canvas-el &#123; position: absolute; display: block; top: 0; left: 0; /*z-index:-1;*/ /*有的说这句必须加 要不会阻挡前面内容 不过我这次用的时候没出现 反而会多退后一层*/&#125;&lt;/style&gt; 注意: 如果下次样式还出现偏移,就按原来官方的试试 使用#particles-js 写样式","text":"使用方法: 123456789101112131415161718192021&lt;!-- 动画容器 --&gt;&lt;div id=&quot;particles-js&quot;&gt;&lt;/div&gt;&lt;!-- 库引入 --&gt;&lt;script src=&quot;particles.js&quot;&gt;&lt;/script&gt;&lt;!-- 配置及使用 --&gt;&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;style&gt;/*这句很关键 如果不设置的话大小总会出现偏移的 不过按照官方的说应该是 #particles-js 也就是容器id 可不知道为啥是canvas类名还有个问题就是我这个文件不知道从哪里来的,好像跟从官方复制的不一样,把Github上的复制到文件里就报错了*/.particles-js-canvas-el &#123; position: absolute; display: block; top: 0; left: 0; /*z-index:-1;*/ /*有的说这句必须加 要不会阻挡前面内容 不过我这次用的时候没出现 反而会多退后一层*/&#125;&lt;/style&gt; 注意: 如果下次样式还出现偏移,就按原来官方的试试 使用#particles-js 写样式 12345/* particlesJS.load(@dom-id, @path-json, @callback (optional)); *//* particles.json 是具体的 配置内容 */particlesJS.load(&#x27;particles-js&#x27;, &#x27;assets/particles.json&#x27;, function() &#123; console.log(&#x27;callback - particles.js config loaded&#x27;);&#125;); 配置解说: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110 &#123; //dom标签 &quot;particles&quot;: &#123; &quot;number&quot;: &#123; //粒子的数量 &quot;value&quot;: 80, &quot;density&quot;: &#123; //粒子的稀密程度 这个轻易别该 会死机 越大越稀疏 &quot;enable&quot;: true, &quot;value_area&quot;: 1000 // 每一个粒子占据的空间 &#125; &#125;, &quot;color&quot;: &#123; &quot;value&quot;: [&#x27;#2d8cf0&#x27;, &#x27;#19be6b&#x27;, &#x27;#ff9900&#x27;, &#x27;#ed3f14&#x27;] //粒子颜色 （支持16进制”#b61924”，rgb”&#123;r:182, g:25, b:36&#125;”，hsl，以及random）[&#x27;#2d8cf0&#x27;, &#x27;#19be6b&#x27;, &#x27;#ff9900&#x27;, &#x27;#ed3f14&#x27;] &#125;, &quot;image&quot;: &#123; //如果使用图片 这里设置 &quot;src&quot;: &quot;img/github.svg&quot;, &quot;width&quot;: 100, &quot;height&quot;: 100 &#125;, &quot;shape&quot;: &#123; &quot;type&quot;: &quot;circle&quot;, // 粒子的形状 （”circle” “edge” “triangle” “polygon” “star” “image”） &quot;stroke&quot;: &#123; // 粒子边缘线条 宽度和颜色 &quot;width&quot;: 0, &quot;color&quot;: &quot;#000000&quot; &#125;, &quot;polygon&quot;: &#123; //多变形状,不太理解 &quot;nb_sides&quot;: 5 &#125;, &#125;, &quot;opacity&quot;: &#123; &quot;value&quot;: 0.75, //粒子透明度 (0~1) &quot;random&quot;: true, //随机透明度 &quot;anim&quot;: &#123; &quot;enable&quot;: false, //开启动画 这样粒子的透明度将不断变化 &quot;speed&quot;: 1, //数值越大 速度变化越快 &quot;opacity_min&quot;: 0.1, //应该是透明变化幅度 &quot;sync&quot;: false &#125; &#125;, &quot;size&quot;: &#123; &quot;value&quot;: 10, //粒子大小 &quot;random&quot;: true, &quot;anim&quot;: &#123; &quot;enable&quot;: false, //大小动画 &quot;speed&quot;: 40, &quot;size_min&quot;: 0.1, &quot;sync&quot;: false &#125; &#125;, &quot;line_linked&quot;: &#123; //连线 &quot;enable&quot;: true, &quot;distance&quot;: 150, //相距多少连线 &quot;color&quot;: &quot;#ffffff&quot;, &quot;opacity&quot;: 0.4, //透明度 &quot;width&quot;: 1 &#125;, &quot;move&quot;: &#123; &quot;enable&quot;: true, //如果关闭了 就没有画面了 &quot;speed&quot;: 4, //越大速度越快 &quot;direction&quot;: &quot;none&quot;, //移动方向 none碰撞运动 &quot;random&quot;: false, //粒子随机运动了 也没物理特性了 &quot;straight&quot;: false, //静止 &quot;out_mode&quot;: &quot;out&quot;, //粒子是否可以出边缘 out/bounce &quot;bounce&quot;: false, //粒子之间是否碰撞 &quot;attract&quot;: &#123; //这个不知道是干啥的 好像粒子互相吸引 &quot;enable&quot;: false, &quot;rotateX&quot;: 600, &quot;rotateY&quot;: 1200 &#125; &#125; &#125;, &quot;interactivity&quot;: &#123; &quot;detect_on&quot;: &quot;canvas&quot;, &quot;events&quot;: &#123; &quot;onhover&quot;: &#123; //鼠标是否互动 &quot;enable&quot;: false, &quot;mode&quot;: &quot;repulse&quot; //互动模式 [&quot;grab&quot;, &quot;bubble&quot;,&quot;repulse&quot;] 第一个是连线 第二个粒子放大 第三个是推开 &#125;, &quot;onclick&quot;: &#123; &quot;enable&quot;: false, &quot;mode&quot;: &quot;repulse&quot; //点击特效 &quot;push&quot; [&quot;push&quot;, &quot;remove&quot;,&quot;bubble&quot; ,&quot;repulse&quot;] push是添加 其他的和上面一样 &#125;, &quot;resize&quot;: true //重画不太懂干什么用的 &#125;, &quot;modes&quot;: &#123; //这里是模式的设置 &quot;grab&quot;: &#123; &quot;distance&quot;: 140, &quot;line_linked&quot;: &#123; &quot;opacity&quot;: 1 &#125; &#125;, &quot;bubble&quot;: &#123; &quot;distance&quot;: 400, &quot;size&quot;: 40, &quot;duration&quot;: 2, &quot;opacity&quot;: 8, &quot;speed&quot;: 3 &#125;, &quot;repulse&quot;: &#123; &quot;distance&quot;: 200, &quot;duration&quot;: 0.4 &#125;, &quot;push&quot;: &#123; &quot;particles_nb&quot;: 4 &#125;, &quot;remove&quot;: &#123; &quot;particles_nb&quot;: 2 &#125; &#125; &#125;, &quot;retina_detect&quot;: true //不知道干啥的&#125; 例子:自己的 星空 经典 泡泡版 ##参考文档Github仓库particlesJS使用简介 这个是个整合 其配置比上面简单很多 但本质还是上面的particlesjparticles.js","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"VSCode 自定义代码块  snippet","slug":"VSCode 自定义代码块  snippet","date":"2017-05-29T14:33:53.000Z","updated":"2021-09-09T16:34:45.056Z","comments":true,"path":"2017/05/VSCode 自定义代码块  snippet/","link":"","permalink":"http://elickzhao.github.io/2017/05/VSCode%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E5%9D%97%20%20snippet/","excerpt":"什么是 snippetsnippet[ˈsnɪpɪt]，或者说「code snippet」，指的是能够帮助输入重复代码模式串，比如循环或条件语句，的模板。通过 snippet ，我们仅仅输入一小段代码就可以生成预定义的模板代码，甚至可以通过内部跳转快速补全模板。","text":"什么是 snippetsnippet[ˈsnɪpɪt]，或者说「code snippet」，指的是能够帮助输入重复代码模式串，比如循环或条件语句，的模板。通过 snippet ，我们仅仅输入一小段代码就可以生成预定义的模板代码，甚至可以通过内部跳转快速补全模板。 如何配置 snippet操作流程 进入 snippet 设置文件 这里提供了两种方法： 按「Alt」键切换菜单栏，通过文件 &gt; 首选项 &gt; 用户代码片段，选择进入目的语言的代码段设置文件；通过快捷键「Ctrl + Shift + P」打开命令窗口（all command window），输入「snippet」，通过候选栏中的选项进入目的语言的代码段设置文件。 填写 snippets 例子 123456789101112131415161718192021222324252627&#123; /* // Place your snippets for TypeScript here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected. // Example: &quot;Print to console&quot;: &#123; &quot;prefix&quot;: &quot;log&quot;, &quot;body&quot;: [ &quot;console.log(&#x27;$1&#x27;);&quot;, &quot;$2&quot; ], &quot;description&quot;: &quot;Log output to console&quot; &#125;*/ //这是个json格式的文件 &quot;Print to for&quot;: &#123; &quot;prefix&quot;: &quot;forz&quot;, //快捷输入 &quot;body&quot;: [ //格式代码构成 &quot;for(var $&#123;1:i&#125; = 0; $&#123;1:i&#125; &lt; $&#123;2:len&#125;; $&#123;1:i&#125;++ )&#123;&quot;, &quot; $0&quot;, &quot;&#125;&quot; ], &quot;description&quot;: &quot;for循环快速编写 for(var i = 0; i &lt; len; i++ )&#123; ... &#125; &quot; //注释 &#125;&#125; snippet 由三部分组成： prefix：前缀，定义了 snippets 从 IntelliSense 中呼出的关键字; body： 主体，即模板的主体内容，其中每个字符串表示一行; description：说明，会在 IntelliSense 候选栏中出现。未定义的情况下直接显示对象名，上例中将会显示 Print to console。 其中 body 部分可以使用特殊结构来控制光标和要插入的文本。 支持的功能及其文法如下： Tabstops：制表符 用「Tabstops」可以让编辑器的指针在 snippet 内跳转。使用 $1，$2 etc. 指定光标位置。这些数字指定了Tabstops将被访问的顺序，特别地，$0表示最终光标位置。相同序号的「Tabstops」被链接在一起，将会同步更新.比如下列用于生成头文件封装的 snippet 被替换到编辑器上时，光标就将同时出现在所有$1位置。 Placeholders：占位符 「placeholder」是带有默认值的「Tabstops」，如${1：foo}。「placeholder」文本将被插入「Tabstops」位置，并在跳转时被全选，以方便修改。占位符还可以嵌套，例如${1:another ${2:placeholder}}。 Variables：变量 使用$name或${name:default}可以插入变量的值。 当未设置变量时，将插入其缺省值或空字符串。 当varibale未知（即，其名称未定义）时，将插入变量的名称，并将其转换为「placeholder」。 可以使用以下「Variable」： TM_SELECTED_TEXT：当前选定的文本或空字符串 TM_CURRENT_LINE：当前行的内容 TM_CURRENT_WORD：光标下的单词的内容或空字符串 TM_LINE_INDEX：基于零索引的行号 TM_LINE_NUMBER：基于一索引的行号 TM_FILENAME：当前文档的文件名 TM_DIRECTORY：当前文档的目录 TM_FILEPATH：当前文档的完整文件路径 注意，这些都是变量名，不是宏，在实际使用的时候还是要加上$符的。 拓展阅读：官网也给出了 snippet 的 EBNF 范式的正则文法，注意，使用\\（反斜杠）转义$, ,, }和\\。any ::= tabstop | placeholder | variable | texttabstop ::= ‘$’ int | ‘${‘ int ‘}’placeholder ::= ‘${‘ int ‘:’ any ‘}’variable ::= ‘$’ var | ‘${‘ var }’ | ‘${‘ var ‘:’ any ‘}’var ::= [_a-zA-Z] [_a-zA-Z0-9]*int ::= [0-9]+text ::= .* 有用的建议 默认情况下 snippet 在 IntelliSense 中的显示优先级并不高，而且在 IntelliSense 中选择相应 snippet 需要按「enter」键，这对于手指短的人来说并不是什么很好的体验。所幸，VSCode 意识到了这一点，并为我们提供了改进的方式。 在 VSCode 的用户设置（「Ctrl+P」在输入框中写「user settings」后点选）中，检索代码段，然后根据提示修改，设置建议优先显示，并且可以通过「TAB」补全 snippet。 参考文档http://blog.csdn.net/maokelong95/article/details/54379046","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"}]},{"title":"Atom 自定义快捷键","slug":"Atom 自定义快捷键","date":"2017-05-28T15:09:28.000Z","updated":"2021-09-09T16:34:44.867Z","comments":true,"path":"2017/05/Atom 自定义快捷键/","link":"","permalink":"http://elickzhao.github.io/2017/05/Atom%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"用了很多的编辑器,但是编辑的快捷方式都不一样是个麻烦的事.Atom有因为有众多的插件,所以快捷键记不清,而且和自己喜欢用的不一样,更是平常事. 这时就需要自己定义快捷键了. Atom自己定义快捷键实在是方便.找到插件快捷键,他会提供个复制按钮.这是你只要复制,然后去setting里的Keybindings,然后点击用户键盘映射,就会出现个文件,把刚才复制的粘贴到这里.然后修改成自己想要的快捷键就行了.真的很方便.以后要是不要了删除就行了,又恢复到默认了.","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"}]},{"title":"打算写一个nodejs发送请求 做的一些准备","slug":"打算写一个nodejs发送请求 做的一些准备","date":"2017-05-19T12:44:43.000Z","updated":"2021-09-09T16:34:45.669Z","comments":true,"path":"2017/05/打算写一个nodejs发送请求 做的一些准备/","link":"","permalink":"http://elickzhao.github.io/2017/05/%E6%89%93%E7%AE%97%E5%86%99%E4%B8%80%E4%B8%AAnodejs%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%20%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87/","excerpt":"","text":"如何从零开始写一个 Chrome 扩展？手把手教你开发chrome扩展一：开发Chrome Extenstion其实很简单node.js 操作Cookiesnodejs怎么设置cookie？Chrome浏览器查看cookie","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"草稿","slug":"草稿","permalink":"http://elickzhao.github.io/tags/%E8%8D%89%E7%A8%BF/"}]},{"title":"新一代laravel配合vue的框架","slug":"新一代laravel配合vue的框架","date":"2017-05-13T12:58:36.000Z","updated":"2021-09-09T16:34:45.672Z","comments":true,"path":"2017/05/新一代laravel配合vue的框架/","link":"","permalink":"http://elickzhao.github.io/2017/05/%E6%96%B0%E4%B8%80%E4%BB%A3laravel%E9%85%8D%E5%90%88vue%E7%9A%84%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Notadd官方文档git仓库模块的安装插件安装 理念不错的,不过现在还是测试版.问题多多啊.git上的下载下来无法安装.等以后版本成熟的时候再看一下吧","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"图片素材网站设计参考大收集","slug":"图片素材网站大收集","date":"2017-04-26T14:29:18.000Z","updated":"2021-09-09T16:34:45.588Z","comments":true,"path":"2017/04/图片素材网站大收集/","link":"","permalink":"http://elickzhao.github.io/2017/04/%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99%E5%A4%A7%E6%94%B6%E9%9B%86/","excerpt":"","text":"国外优秀图片:http://www.gettyimages.ca/ 酷站网老牌图片网http://www.zcool.com.cn/ 免费图片国外的 不错https://pixabay.com/ 超过389883 张免费照片和图片 (这次不知为啥打不开)cn.freeimages.com/ 提图网http://699pic.com/ 千图网http://www.58pic.com/ 昵图网www.nipic.com 包图网http://888pic.com/ 素材天下http://www.sucaitianxia.com/ 各种psd很不错http://cn.365psd.com/ 另一种意义上的图片素材网站 堆糖https://www.duitang.com/people/?user_id=1726301847#!favalbum 花瓣http://huaban.com/ UE设计平台http://www.uehtml.com/ UI中国http://www.ui.cn/ 卖模版可以参考网页http://maimuban.com/ ps字体下载网站http://www.ps123.net/ 网页设计资源库http://reeoo.com/ 日本区域网站设计集合http://www.4db.cc/ [设计师必备灵感来源地]https://www.behance.net/ 求字体 字体网站","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"百度网盘失效连接恢复","slug":"百度网盘失效连接恢复","date":"2017-04-17T14:59:33.000Z","updated":"2021-09-09T16:34:45.712Z","comments":true,"path":"2017/04/百度网盘失效连接恢复/","link":"","permalink":"http://elickzhao.github.io/2017/04/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%A4%B1%E6%95%88%E8%BF%9E%E6%8E%A5%E6%81%A2%E5%A4%8D/","excerpt":"","text":"看到图片了吗出现的是你来晚了对吧 链接是http://pan.baidu.com/share/link?shareid=76297&amp;uk=3238350839 获取”uk=”后边的数字3238350839这个是关键啊 这是百度的默认网盘分享主页 http://pan.baidu.com/share/home?uk=189904483 把上面那个数字3238350839替换到尾部即可，由此得到。http://pan.baidu.com/share/home?uk=3238350839 看到了吧分享者的主页都出来了，就可以找到你要下载的东西了 还有一种方法就是用百度搜索 把你要下载的名字比如“频频 site:pan.baidu.com” 复制到百度里面OK就很多了（这个前提条件是这个资源能有别人转存了） 以上两种方法你掌握了基本没有找不到的东西 还用一种方法是用胖次网的的网盘解析,不过这需要长连接.短链接是不行的必须转换","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"在线工具箱大总结","slug":"在线工具箱大总结","date":"2017-04-13T13:10:37.000Z","updated":"2021-09-09T16:34:45.603Z","comments":true,"path":"2017/04/在线工具箱大总结/","link":"","permalink":"http://elickzhao.github.io/2017/04/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%A4%A7%E6%80%BB%E7%BB%93/","excerpt":"","text":"在线工具箱-大全在线工具箱开发工具箱前端网工具箱不知名网站工具箱 RGB颜色查询对照表配色网配色表快速获取网站配色和字体 大数据导航在线工具前端工具导航seeseed 图像文件在线编辑工具在线应用图标生成工具gif制作与格式互换微信小编,产品,设计师工具箱PDF制作等工具箱API在线文档站在工具箱前端工具库程序员工具箱 overapi.com 各种语言的API非常好查找有点像larvel那个linux命令大全","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"手机APP开发真机测试难题","slug":"手机APP开发真机测试难题 ","date":"2017-04-12T15:08:39.000Z","updated":"2021-09-09T16:34:45.658Z","comments":true,"path":"2017/04/手机APP开发真机测试难题 /","link":"","permalink":"http://elickzhao.github.io/2017/04/%E6%89%8B%E6%9C%BAAPP%E5%BC%80%E5%8F%91%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95%E9%9A%BE%E9%A2%98%20/","excerpt":"","text":"因为手机开发设计到屏幕大小问题,所以测试一直是个难题.对于安卓手机更是如此. 最近发现了个好网站:腾讯优测 不仅可以自动化测试并提出报告.而且可以模拟真机测试.当然热门机型是需要花钱的.不过也有很多免费机型,这样测试不同屏幕大小就有很好的依据. 当然还有更多功能,比如漏洞分析等等,当然也是要花钱的.如果有一定经费,花点钱也是值得的. 好就先记录这些吧.","categories":[],"tags":[{"name":"APP","slug":"APP","permalink":"http://elickzhao.github.io/tags/APP/"}]},{"title":"Hostinger免费空间使用","slug":"Hostinger免费空间使用","date":"2017-04-09T14:53:17.000Z","updated":"2021-09-09T16:34:44.929Z","comments":true,"path":"2017/04/Hostinger免费空间使用/","link":"","permalink":"http://elickzhao.github.io/2017/04/Hostinger%E5%85%8D%E8%B4%B9%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Hostinger其实去年就已经注册使用了,不过时间一长就给忘记了.今天又看到头条有人介绍,才又想起来.上去一看帐号还在不过测试的网站已经没了.也是都一年时间了. 先把注册地址留下吧,省着以后忘记了注册连接 这个网站去年使用的时候还可以,今年使用有点小卡,不过完全可以接受.再次激活一年的时间.以后可以用这个空间测试一些东西了.","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://elickzhao.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"更新hots的作用与方法","slug":"更新hots的作用与方法","date":"2017-04-07T14:39:30.000Z","updated":"2021-09-09T16:34:45.678Z","comments":true,"path":"2017/04/更新hots的作用与方法/","link":"","permalink":"http://elickzhao.github.io/2017/04/%E6%9B%B4%E6%96%B0hots%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E6%96%B9%E6%B3%95/","excerpt":"","text":"下面引用老D博客的解释 修改hosts相关说明： 注：Google、Gmail、维基百科、Twitter、Facebook等必须请用https 加密方式打开。（一般这些网站都是SSL加密链接）如谷歌学术：https://scholar.google.com/ 如果不喜欢用谷歌香港，可以以 https://www.google.com/ncr 方式访问，(No Country Redirect)禁止国别跳转。 另外可能有的地区&amp;网络（铁通、联通）hosts无法正常使用，这个不是你我能左右的！ 老D所提供的hosts仅限于学习使用，hosts里不会添加屏蔽广告条目，也不会劫持任何网站。 由于DNS污染太严重，YouTube只能打开网页，视频无法播放！还有就是YouTube的每个视频对应的地址都不一样，所以很抱歉。 麻烦别问我为什么修改hosts不能加载YouTube视频啦，我去年回答了不下500次。 特别提醒: 另外可能有的地区&amp;网络（铁通、联通）hosts无法正常使用，这个不是你我能左右的！建议不要使用国产浏览器，国产软件也是，特别是360，因为国产浏览器即使你使用https它也会强制你使用默认http，还有就是会上传用户数据，尽可能使用Chrome下载&amp;修改hosts安全软件可能会“报毒”（误报）你可以暂时退出或者添加信任即可！ 唉 我就属于联通用户,结果就用不了啊.真是倒霉啊.但还是保存下留着以后用吧 2017 Google hosts 持续更新","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"},{"name":"玩机技巧","slug":"玩机技巧","permalink":"http://elickzhao.github.io/tags/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"}]},{"title":"桌面整理小程序","slug":"桌面整理小程序","date":"2017-04-06T14:07:55.000Z","updated":"2021-09-09T16:34:45.688Z","comments":true,"path":"2017/04/桌面整理小程序/","link":"","permalink":"http://elickzhao.github.io/2017/04/%E6%A1%8C%E9%9D%A2%E6%95%B4%E7%90%86%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"有些东西啊 真是食之无味弃之可惜.这个桌面整理就是如此,感觉挺不错的.不过由于机器性能问题,好像用了也没什么意义.但是记录下吧,也许说不定哪天就有用呢 是吧. Fences: 国外一早出现的东西看着挺好看的,不过要收费 桔子桌面: 跟上面那个功能基本一样,就是国产的而且免费 下载地址:桔子桌面Fences","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"玩机技巧","slug":"玩机技巧","permalink":"http://elickzhao.github.io/tags/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"}]},{"title":"Everything无法搜索到文件","slug":"Everything无法搜索到文件","date":"2017-04-03T11:28:02.000Z","updated":"2021-09-09T16:34:44.908Z","comments":true,"path":"2017/04/Everything无法搜索到文件/","link":"","permalink":"http://elickzhao.github.io/2017/04/Everything%E6%97%A0%E6%B3%95%E6%90%9C%E7%B4%A2%E5%88%B0%E6%96%87%E4%BB%B6/","excerpt":"","text":"刚把电脑清理完灰尘,使用wox却找不到了cmder,还以为莫名其妙的给删了呢.结果重装以后,发现原来老的还在啊,再用wox搜其他exe程序,发现也没有了,这才想起应该Everything有问题了.找到Everything一搜结果真是如此,什么都搜不到了. 解决方法很简单,打开工具-&gt;选项-&gt;索引 然后点强制重建 就可以了.当然我在进来之前发现数据库路径是空的,所以又指了下路径.所以保险起见这两条都弄下. 参考文档 我的Everything搜索不到东西了！","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"电脑电源声音太吵解决方法","slug":"电脑电源声音太吵解决方法","date":"2017-04-02T15:26:15.000Z","updated":"2021-09-09T16:34:45.704Z","comments":true,"path":"2017/04/电脑电源声音太吵解决方法/","link":"","permalink":"http://elickzhao.github.io/2017/04/%E7%94%B5%E8%84%91%E7%94%B5%E6%BA%90%E5%A3%B0%E9%9F%B3%E5%A4%AA%E5%90%B5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"主要原因就是,使用时间太长,造成轴承机油过少,使得摩擦加剧,只要上点机油就ok了.其实添加机油感觉上很难,其实只要把 螺丝全拧下来,然后在风扇中间的小孔里滴上两滴就可以了.今天打开电源,我的天里面的会真是太多了.已经看不到电路板的颜色了.看来以后每年都应该打扫一下.现在滴上机油,又恢复了原来的安静了. ##参考文档电脑电源风扇噪音问题处理机箱噪音大怎么办？电源拆卸风扇加油教程","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"},{"name":"玩机技巧","slug":"玩机技巧","permalink":"http://elickzhao.github.io/tags/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"}]},{"title":"splice与slice的区别与应用","slug":"splice与slice的区别与应用","date":"2017-04-01T14:40:11.000Z","updated":"2021-09-09T16:34:45.391Z","comments":true,"path":"2017/04/splice与slice的区别与应用/","link":"","permalink":"http://elickzhao.github.io/2017/04/splice%E4%B8%8Eslice%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%BA%94%E7%94%A8/","excerpt":"","text":"slice(开始位置,结束位置) //选取元素 //返回选取元素splice(开始位置,要删除个数,替换元素[可选]) //删除一些元素 //不返回,会把原数组改变splice(开始位置,要删除个数,替换元素[可选]) 这个是删除后返回原数组 而slicen()根本不改变原数组 而是将选取赋予一个变量才行 var arr1 = arr.slicen(1,2); 运行结果 参考文档http://www.w3school.com.cn/tiy/t.asp?f=jseg_splicehttp://www.w3school.com.cn/tiy/t.asp?f=jseg_slice_array JavaScript splice() 方法JavaScript slice() 方法","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"SSR老技术 新学问....","slug":"SSR老技术 新学问","date":"2017-03-31T14:50:21.000Z","updated":"2021-09-09T16:34:45.031Z","comments":true,"path":"2017/03/SSR老技术 新学问/","link":"","permalink":"http://elickzhao.github.io/2017/03/SSR%E8%80%81%E6%8A%80%E6%9C%AF%20%E6%96%B0%E5%AD%A6%E9%97%AE/","excerpt":"","text":"这网上的学问真是无穷无尽啊.SSR应该流行一段了,不过我却是个新学生.最近捣鼓路由才发现这个.其实也不能这么说,原来也知道SS科学上网,不过都是要花钱的,所以没在意.这个SSR是SS的升级版.据说还可以用于手机上网免流量.真是好神奇啊,不知道如何实现的.不过看了几个帖子后发现,好像2016还可以,2017 好像已经全屏蔽了,谁知道呢.我也没去试.搜了一圈免费的已经不多了,最后终于找到一个 微笑网游加速器 还不错好像是每个月免费1G流量.而且看这样好像是说手机也能用,不过我也没这个需求就不试了.还有签到送流量,不过需要注册个外国通信软件比较麻烦,也懒得弄.反正我就看看资料1G应该也够用了. 据说还可以用路由来搭建SSR服务器(我现在的路由上只是客户端),好像是想通过这个来达到手机免流的作用,因为如果是梯子的话,必须用外国服务器.这个以后再说吧,毕竟没有需求. 至于如何设置SSR客户端挺简单的,看路由和微笑提供的信息,按着填写就好了.看着乱又多,其实也没什么. 应该就这些. 把文档记录一下吧. 参考文档免费分享20个自建的S-S R节点，新增kcptun，游戏udp，openv p n，免流端口献给小白-全网最详细的SSR免流教程 从0到1分享SSR免流完整教程工具集合。附带架设好的SSR服务器供小伙伴测试。手机端搭建SSR服务图文教程7p用SSRfan qiang 加免流！终于成功了！ Shadowsocks的简介 Shadowsocks是一款高性能的基于python开发的socks5代理，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。 优点在于它解决了GFW通过分析流量特征从而干扰的问题，这是它优于SSH和VPN翻墙的地方。 同时，不用像VPN一样全局加入到代 理，可以实现全局代理和分应用代理，或国内路由，也就是说他可以让需要用到代理的网站走代理，而国内的网站则正常走国内的线路，不会影响国内网站的速度。 相对VPN而言，Shadowsocks更稳定，连接速度更快，如果经常需要用Google查资料、刷Twitter、上Facebook、看Youtube，那么Shadowsocks更能满足您的需要。 参考文档老D博客携一枝红杏推专属「终身8折」优惠","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"},{"name":"SSR","slug":"SSR","permalink":"http://elickzhao.github.io/tags/SSR/"}]},{"title":"小米路由 与  斐讯K2 刷机教程","slug":"小米路由 与  斐讯K2 刷机教程","date":"2017-03-30T14:48:04.000Z","updated":"2021-09-09T16:34:45.630Z","comments":true,"path":"2017/03/小米路由 与  斐讯K2 刷机教程/","link":"","permalink":"http://elickzhao.github.io/2017/03/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%20%E4%B8%8E%20%20%E6%96%90%E8%AE%AFK2%20%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"小米路由root密码 1d942240使用winSCP连接小米路由的时候 必须选择 scp协议 不能用SFTP协议否则打不开, 但是默认的是SFTP所以要自己改一下. 更新小米路由rom为开发版 开启ssh支持 刷入Breed 进入breed 刷完后 必须把ip地址改为 1 网段下 192.168.1.22 然后按住reset当灯狂闪时撒开,并由浏览器进入192.168.1.1 设置多播,我这里可以多开4个 经测试能提升下载速度2m/s左右 不过看视频好像没啥改变 本来打算安装屏蔽广告 但想到这个路由也不用了 就以后再说 心得测试wifi的手机APP必须给与位置权限 要不就无法正常工作 搜索不到wif信号 参考文档[经验技巧] 【荣组出品】mini玩机第一步：开启路由ROOT权限，玩转小米mini路由6：刷不死Breed【2017-1-16】AR/QCA/MTK Breed，功能强大的多线程 Bootloader – breedAC1200HP华硕rom小米路由器mini如何刷PandoraBox固件？小米路由器mini刷潘多[2017-3-28]改华硕[N14U N54U]5G 2G的7620老毛子Padavan固件华硕固件下载地址PandoraBox潘多拉多拨教程（图文）免费提升网速 最新版PandoraBox潘多拉安装adbyby去广告插件图文详细教程！！ 斐讯K2 k2刷入breed好像不那么容易,不过在第一个参考文档里有个软件可以直接傻瓜刷入,当然现在可行,不知道以后如何.还有就是 改版官方固件 最新固件K2 V22.5.9.163 这个可以直接用 官方自带固件里的升级程序升级 升级后就自带breed了 但这个固件不能用breed升级,所以我没用,我现在用的是 V22.4.5.42 据说163稳定更好,先试试老的吧 不行再换. 刷入固件,现在用的是原版改 先试试这个吧.其他比如潘多拉也挺好因为我这里可以多播但界面丑点,华硕的就是挺漂亮功能多. 如果现在这个不稳定以后再换吧. 这个固件测试,还可以信号和稳定性,而且还有ssr虽然没钱买张号.但是有个问题啊,用了这个后我的游戏平台帐号显示异地登录,今天优酷帐号也提醒了.不是说去掉后门了么,奇怪.所以还是把他换了,换成华硕的了.其实真是原因搞不懂,因为百度浏览器有个万能马甲的插件也很可疑.所以两个都删了.华为这个也先试试看吧,不过这个华为这个网速可是增加了好多.现在测速下载7M/S 原来最多是4 一般是3啊 不知道是不是这个固件的事.先用这个看吧,这个功能的确是太丰富了. 刷入估计使用的breed里有个小程序 BreedEnter 挺好用的.有了它就不需要手动按住reset了. 他操作过程是拔掉路由电源-&gt;开启软件-&gt;点击开启-&gt;插上电源-&gt;等待提示,进入192.168.1.1 ##参考文档斐讯K2最新版刷机教程“免费” PHICOMM 斐讯 K2路由器 开箱（附刷OpenWrt开源固件，实战MWAN多宽带链路网速叠加)改版官方固件 163【2017-03-24】斐讯K1、K2官方固件定制版（去后门、加s s r、adbyby等）【V1.7】 原本改下载地址华硕下载地址 RT-AC54U-GPIO-1-PSG1208-64M_3.4.3.9-099.trx 这个是k2固件潘多拉固件 看看都用什么固件以后可以刷着换都说说大家斐讯K2都用的什么固件【资源整合】斐讯刷机固件资源整合帖【2017-4-5】还是待完善~添加了部分个人感受","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"},{"name":"玩机技巧","slug":"玩机技巧","permalink":"http://elickzhao.github.io/tags/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"}]},{"title":"三星note2 wifi无法搜索 刷机","slug":"三星note2 wifi无法搜索 刷机","date":"2017-03-28T14:32:45.000Z","updated":"2021-09-09T16:34:45.519Z","comments":true,"path":"2017/03/三星note2 wifi无法搜索 刷机/","link":"","permalink":"http://elickzhao.github.io/2017/03/%E4%B8%89%E6%98%9Fnote2%20wifi%E6%97%A0%E6%B3%95%E6%90%9C%E7%B4%A2%20%E5%88%B7%E6%9C%BA/","excerpt":"","text":"本来手机内存卡里有曾经下的rom,不过三星这个很奇怪.进入了recovery 却看不到sd卡,虽然上面写着sd卡,但是却是手机内存.这就很尴尬了,后来把rom复制到手机内存,开始安装.结果手机卡死在了logo界面,重启也一样.不晓得为什么,原本以为完蛋了.结果幸好刷机精灵还能连上,再次进入recovery,看到一行小字,在本界面可以连接刷机精灵 刷机.我擦,这太好了,因为在logo界面时曾试过,结果失败了.于是刷之,没想到挽救了这台三星.因为刷的是小米rom 里面一大堆垃圾,上次可能因为删了一些服务造成了wifi搜索不到.这次小心点,只是把垃圾软件删了,其他无用的服务就用360手机助手冻结了.希望这次不会再出问题了…","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"},{"name":"玩机技巧","slug":"玩机技巧","permalink":"http://elickzhao.github.io/tags/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"}]},{"title":"VSCode 常用快捷键","slug":"VSCode 常用快捷键","date":"2017-03-24T14:11:36.000Z","updated":"2021-09-09T16:34:45.053Z","comments":true,"path":"2017/03/VSCode 常用快捷键/","link":"","permalink":"http://elickzhao.github.io/2017/03/VSCode%20%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"常用General 按 Press 功能 Function Ctrl + Shift + P，F1 显示命令面板 Show Command Palette Ctrl + P 快速打开 Quick Open Ctrl + Shift + N 新窗口/实例 New window/instance Ctrl + Shift + W 关闭窗口/实例 Close window/instance 基础编辑 Basic editing 按 Press 功能 Function Ctrl+X 剪切行（空选定） Cut line (empty selection) Ctrl+C 复制行（空选定）Copy line (empty selection) Alt+ ↑ / ↓ 向上/向下移动行 Move line up/down Shift+Alt + ↓ / ↑ 向上/向下复制行 Copy line up/down Ctrl+Shift+K 删除行 Delete line Ctrl+Enter 在下面插入行 Insert line below Ctrl+Shift+Enter 在上面插入行 Insert line above Ctrl+Shift+\\ 跳到匹配的括号 Jump to matching bracket Ctrl+] / [ 缩进/缩进行 Indent/outdent line Home 转到行首 Go to beginning of line End 转到行尾 Go to end of line Ctrl+Home 转到文件开头 Go to beginning of file Ctrl+End 转到文件末尾 Go to end of file Ctrl+↑ / ↓ 向上/向下滚动行 Scroll line up/down Alt+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Shift+[ 折叠（折叠）区域 Fold (collapse) region Ctrl+Shift+] 展开（未折叠）区域 Unfold (uncollapse) region Ctrl+K Ctrl+[ 折叠（未折叠）所有子区域 Fold (collapse) all subregions Ctrl+K Ctrl+] 展开（未折叠）所有子区域 Unfold (uncollapse) all subregions Ctrl+K Ctrl+0 折叠（折叠）所有区域 Fold (collapse) all regions Ctrl+K Ctrl+J 展开（未折叠）所有区域 Unfold (uncollapse) all regions Ctrl+K Ctrl+C 添加行注释 Add line comment Ctrl+K Ctrl+U 删除行注释 Remove line comment Ctrl+/ 切换行注释 Toggle line comment Shift+Alt+A 切换块注释 Toggle block comment Alt+Z 切换换行 Toggle word wrap 导航 Navigation 按 Press 功能 Function Ctrl + T 显示所有符号 Show all Symbols Ctrl + G 转到行… Go to Line… Ctrl + P 转到文件… Go to File… Ctrl + Shift + O 转到符号… Go to Symbol… Ctrl + Shift + M 显示问题面板 Show Problems panel F8 转到下一个错误或警告 Go to next error or warning Shift + F8 转到上一个错误或警告 Go to previous error or warning Ctrl + Shift + Tab 导航编辑器组历史记录 Navigate editor group history Alt + ←/→ 返回/前进 Go back / forward Ctrl + M 切换选项卡移动焦点 Toggle Tab moves focus 搜索和替换 Search and replace 按 Press 功能 Function Ctrl + F 查找 Find Ctrl + H 替换 Replace F3 / Shift + F3 查找下一个/上一个 Find next/previous Alt + Enter 选择查找匹配的所有出现 Select all occurences of Find match Ctrl + D 将选择添加到下一个查找匹配 Add selection to next Find match Ctrl + K Ctrl + D 将最后一个选择移至下一个查找匹配项 Move last selection to next Find match Alt + C / R / W 切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word 多光标和选择 Multi-cursor and selection 按 Press 功能 Function Alt +单击 插入光标 Insert cursor Ctrl + Alt +↑/↓ 在上/下插入光标 Insert cursor above / below Ctrl + U 撤消上一个光标操作 Undo last cursor operation Shift + Alt + I 在选定的每一行的末尾插入光标 Insert cursor at end of each line selected Ctrl + I 选择当前行 Select current line Ctrl + Shift + L 选择当前选择的所有出现 Select all occurrences of current selection Ctrl + F2 选择当前字的所有出现 Select all occurrences of current word Shift + Alt + → 展开选择 Expand selection Shift + Alt + ← 缩小选择 Shrink selection Shift + Alt + （拖动鼠标） 列（框）选择 Column (box) selection Ctrl + Shift + Alt +（箭头键） 列（框）选择 Column (box) selection Ctrl + Shift + Alt + PgUp / PgDown 列（框）选择页上/下 Column (box) selection page up/down 丰富的语言编辑 Rich languages editing 按 Press 功能 Function Ctrl + 空格 触发建议 Trigger suggestion Ctrl + Shift + Space 触发器参数提示 Trigger parameter hints Tab Emmet 展开缩写 Emmet expand abbreviation Shift + Alt + F 格式化文档 Format document Ctrl + K , Ctrl + F 格式选定区域 Format selection F12 转到定义 Go to Definition Alt + F12 Peek定义 Peek Definition Ctrl + K F12 打开定义到边 Open Definition to the side Ctrl + . 快速解决 Quick Fix Shift + F12 显示引用 Show References F2 重命名符号 Rename Symbol Ctrl + Shift + . /， 替换为下一个/上一个值 Replace with next/previous value Ctrl + K , Ctrl + X 修剪尾随空格 Trim trailing whitespace Ctrl + K, M 更改文件语言 Change file language 编辑器管理 Editor management 按 Press 功能 Function Ctrl+F4, Ctrl+W 关闭编辑器 Close editor Ctrl+K F 关闭文件夹 Close folder Ctrl+| 拆分编辑器 Split editor Ctrl+ 1 / 2 / 3 聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group Ctrl+K Ctrl+ ←/→ 聚焦到上一个/下一个编辑器组 Focus into previous/next editor group Ctrl+Shift+PgUp / PgDown 向左/向右移动编辑器 Move editor left/right Ctrl+K ← / → 移动活动编辑器组 Move active editor group 文件管理 File management 按 Press 功能 Function Ctrl+N 新文件 New File Ctrl+O 打开文件… Open File… Ctrl+S 保存 Save Ctrl+Shift+S 另存为… Save As… Ctrl+K S 全部保存 Save All Ctrl+F4 关闭 Close Ctrl+K Ctrl+W 关闭所有 Close All Ctrl+Shift+T 重新打开关闭的编辑器 Reopen Ctrl+K 输入保持打开 Enter Keep Open Ctrl+Tab 打开下一个 Open next Ctrl+Shift+Tab 打开上一个 Open previous Ctrl+K P 复制活动文件的路径 Copy path of active file Ctrl+K R 显示资源管理器中的活动文件 Reveal active file in Explorer Ctrl+K O 显示新窗口/实例中的活动文件 Show active file in new window/instance 显示 Display 按 Press 功能 Function F11 切换全屏 Toggle full screen Shift+Alt+1 切换编辑器布局 Toggle editor layout Ctrl+ = / - 放大/缩小 Zoom in/out Ctrl+B 切换侧栏可见性 Toggle Sidebar visibility Ctrl+Shift+E 显示浏览器/切换焦点 Show Explorer / Toggle focus Ctrl+Shift+F 显示搜索 Show Search Ctrl+Shift+G 显示Git Show Git Ctrl+Shift+D 显示调试 Show Debug Ctrl+Shift+X 显示扩展 Show Extensions Ctrl+Shift+H 替换文件 Replace in files Ctrl+Shift+J 切换搜索详细信息 Toggle Search details Ctrl+Shift+C 打开新命令提示符/终端 Open new command prompt/terminal Ctrl+Shift+U 显示输出面板 Show Output panel Ctrl+Shift+V 切换Markdown预览 Toggle Markdown preview Ctrl+K V 从旁边打开Markdown预览 Open Markdown preview to the side 调试 Debug 按 Press 功能 Function F9 切换断点 Toggle breakpoint F5 开始/继续 Start/Continue Shift+F5 停止 Stop F11 / Shift+F11 下一步/上一步 Step into/out F10 跳过 Step over Ctrl+K Ctrl+I 显示悬停 Show hover 集成终端 Integrated terminal 按 Press 功能 Function Ctrl+` 显示集成终端 Show integrated terminal Ctrl+Shift+` 创建新终端 Create new terminal Ctrl+Shift+C 复制选定 Copy selection Ctrl+Shift+V 粘贴到活动端子 Paste into active terminal Ctrl+↑ / ↓ 向上/向下滚动 Scroll up/down Shift+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Home / End 滚动到顶部/底部 Scroll to top/bottom vscode: Visual Studio Code 常用快捷键 主命令框 F1 或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如：按一下 Backspace 会进入到 Ctrl+P 模式在 Ctrl+P 下输入 &gt; 可以进入 Ctrl+Shift+P 模式在 Ctrl+P 窗口下还可以:直接输入文件名，跳转到文件? 列出当前可执行的动作! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M跳转到行数，也可以 Ctrl+G 直接进入@ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入@ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入# 根据名字查找 symbol，也可以 Ctrl+T常用快捷键编辑器与窗口管理 打开一个新窗口： Ctrl+Shift+N关闭窗口： Ctrl+Shift+W同时打开多个编辑器（查看多个文件）新建文件 Ctrl+N文件之间切换 Ctrl+Tab切出一个新的编辑器（最多 3 个） Ctrl+\\，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名左中右 3 个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+33 个编辑器之间循环切换 Ctrl+编辑器换位置， Ctrl+k然后按 Left或 Right 代码编辑 格式调整 代码行缩进 Ctrl+[ 、 Ctrl+]Ctrl+C 、 Ctrl+V 复制或剪切当前行/当前选中内容代码格式化： Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code上下移动一行： Alt+Up 或 Alt+Down向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down在当前行下边插入一行 Ctrl+Enter在当前行上方插入一行 Ctrl+Shift+Enter 光标相关 移动到行首： Home移动到行尾： End移动到文件结尾： Ctrl+End移动到文件开头： Ctrl+Home移动到定义处： F12定义处缩略图：只看一眼而不跳转过去 Alt+F12移动到后半个括号： Ctrl+Shift+]选择从光标到行尾： Shift+End选择从行首到光标处： Shift+Home删除光标右侧的所有字： Ctrl+Delete扩展/缩小选取范围： Shift+Alt+Left 和 Shift+Alt+Right多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up同时选中所有匹配： Ctrl+Shift+LCtrl+D 下一个匹配的也被选中 (在 sublime 中是删除当前行，后面自定义快键键中，设置与 Ctrl+Shift+K 互换了)回退上一个光标操作： Ctrl+U 重构代码 找到所有的引用： Shift+F12同时修改本文件中所有匹配的： Ctrl+F12重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose 查找替换 查找 Ctrl+F查找替换 Ctrl+H整个文件夹中查找 Ctrl+Shift+F 显示相关 全屏：F11zoomIn/zoomOut：Ctrl +/-侧边栏显/隐：Ctrl+B显示资源管理器 Ctrl+Shift+E显示搜索 Ctrl+Shift+F显示 Git Ctrl+Shift+G显示 Debug Ctrl+Shift+D显示 Output Ctrl+Shift+U 其他自动保存：File -&gt; AutoSave ，或者 Ctrl+Shift+P，输入 auto 修改默认快捷键打开默认键盘快捷方式设置：File -&gt; Preferences -&gt; Keyboard Shortcuts，或者：Alt+F -&gt; p -&gt; k 修改 keybindings.json： // Place your key bindings in this file to overwrite the defaults[ // ctrl+space 被切换输入法快捷键占用 { “key”: “ctrl+alt+space”, “command”: “editor.action.triggerSuggest”, “when”: “editorTextFocus” }, // ctrl+d 删除一行 { “key”: “ctrl+d”, “command”: “editor.action.deleteLines”, “when”: “editorTextFocus” }, // 与删除一行的快捷键互换 { “key”: “ctrl+shift+k”, “command”: “editor.action.addSelectionToNextFindMatch”, “when”: “editorFocus” }, // ctrl+shift+/多行注释 { “key”:”ctrl+shift+/“, “command”: “editor.action.blockComment”, “when”: “editorTextFocus” }, // 定制与 sublime 相同的大小写转换快捷键，需安装 TextTransform 插件 { “key”: “ctrl+k ctrl+u”, “command”: “uppercase”, “when”: “editorTextFocus” }, { “key”: “ctrl+k ctrl+l”, “command”: “lowercase”, “when”: “editorTextFocus” }]前端开发必备插件PostCSS SortingstylelintstylefmtESLintjavascript standard formatbeautifyBabel ES6/ES7Debugger for ChromeAdd jsdoc commentsjavascript(ES6) code snippetsvueweexReactjs code snippetsReact Native ToolsNpm IntellisenseInstant MarkdownMarkdown ShortcutsTextTransform 自定义设置参考vscode 自定义配置参考： { “editor.fontSize”: 18, “files.associations”: { “.es”: “javascript”, “.es6”: “javascript” }, // 控制编辑器是否应呈现空白字符 “editor.renderWhitespace”: true, // 启用后，将在保存文件时剪裁尾随空格。 “files.trimTrailingWhitespace”: true, // File extensions that can be beautified as javascript or JSON. “beautify.JSfiles”: [ “”, “es”, “es6”, “js”, “json”, “jsbeautifyrc”, “jshintrc” ]} 参考文档学会用好 Visual Studio Code","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"}]},{"title":"新一代代码编辑器 VSCode","slug":"新一代代码编辑器 VSCode","date":"2017-03-20T12:26:56.000Z","updated":"2021-09-09T16:34:45.675Z","comments":true,"path":"2017/03/新一代代码编辑器 VSCode/","link":"","permalink":"http://elickzhao.github.io/2017/03/%E6%96%B0%E4%B8%80%E4%BB%A3%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8%20VSCode/","excerpt":"","text":"这是微软做的一个开源编辑器,微软居然也开源了,还是比较令人神奇的. 这个编辑器的最主要特点就是小巧,当然也是相对说的,当然还是不如sublime,不过经过这么多年,这个已经不在流行. 最近用Atom,HBuilder这两个都不错. 不过Atom我装了过多的插件,打开比较慢,虽然一开始是比较轻巧的.不过Atom的优点就是配置可以云备份,这样不用每个机器都弄一遍了,还有就是插件众多,想要什么都有.但还有个问题是不能单独打开一个文件(这个可能需要设置,但是我也懒得找了),每次打开一个文件都把整个目录,都加载进来又慢又无意义,我只想编辑这个文件而已.一般大的项目我都用phpstorm了 虽然这个又大又慢.但功能全啊 HBuilder是国内开发的,这个特别适合前端开发,速度特别快,尤其适应他们那套快捷方式,比其他任何编辑器都快.所以一般前端,我喜欢用HBuilder. VSCode是最近才发现的,是通过白鹭引擎发现的,白鹭引擎的编辑器就是那VSCode改出来的,于是下载下来看了下.VSCode比较小巧,而且可以单独打开一个文件,最主要的是他的代码提示比Atom好很多,当然也许Atom我没找到对的插件,而且还能使用其他编辑器的快捷方式,免得你上手不适应.总之很可爱,而且也有很多插件,虽然也会慢一些但至少比Atom快很多了.所以以后试试这个吧 VSCode中文官网","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"}]},{"title":"心灵终结中文报错解决","slug":"心灵终结中文报错解决","date":"2017-03-16T13:45:51.000Z","updated":"2021-09-09T16:34:45.653Z","comments":true,"path":"2017/03/心灵终结中文报错解决/","link":"","permalink":"http://elickzhao.github.io/2017/03/%E5%BF%83%E7%81%B5%E7%BB%88%E7%BB%93%E4%B8%AD%E6%96%87%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/","excerpt":"","text":"心灵终结如果安装了中文补丁,就会出现无法载入任务的错误,从第一关开始打一直打下去没问题,如果出去后再选择任务就会报错. 解决这个问题的方法是: 调整gamemd.exe的兼容性（一般来说调成XP是能解决的，不行的话就试试其他的兼容模式）。 右键-&gt;属性-&gt;兼容性-&gt;调成Xp的就好了.","categories":[],"tags":[{"name":"玩机技巧","slug":"玩机技巧","permalink":"http://elickzhao.github.io/tags/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"}]},{"title":"2017-3-11日志","slug":"2017-3-11日志","date":"2017-03-11T13:07:11.000Z","updated":"2021-09-09T16:34:44.857Z","comments":true,"path":"2017/03/2017-3-11日志/","link":"","permalink":"http://elickzhao.github.io/2017/03/2017-3-11%E6%97%A5%E5%BF%97/","excerpt":"","text":"今天星期六,去打球了.不过这个身体真是好差啊,经过春节的腐败和养膘,现在跑一下心脏都有点不舒服了.看来得加强锻炼了.还有就是该死的斗鱼,那个手机号破解快500多了,速度已经快了一点了,不过还有那么多,不过总有个不好的感觉,感觉这些都测完了也未必要找到,有种这么一种不详的预感..今天就记录这些吧,给我爸做的那个程序要尽快弄了… 打完球第二天,浑身好酸啊,基本睡了一天呢. 不运动真实不行啊.还有今天老丈母娘也回来了,这一天基本啥也没干…. 不开心啊不开心.等了一晚上的注册,结果时间错过了.不过也算了,吾爱破解那里的东西也未必是什么好东西.比如这次下的迅雷,根本不好使,虽然显示是会员其实一点没加速… 还有就是资金不够了,真是麻烦啊.而且又有很多花销,好愁人啊….","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://elickzhao.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"白鹭Egret HTML5 游戏及手机程序开发系统","slug":"白鹭Egret HTML5 游戏及手机程序开发系统","date":"2017-03-10T13:56:47.000Z","updated":"2021-09-09T16:34:45.707Z","comments":true,"path":"2017/03/白鹭Egret HTML5 游戏及手机程序开发系统/","link":"","permalink":"http://elickzhao.github.io/2017/03/%E7%99%BD%E9%B9%ADEgret%20HTML5%20%E6%B8%B8%E6%88%8F%E5%8F%8A%E6%89%8B%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"简介Egret是个开发套件,他内部有很多开发相关的软件.第一眼看到很懵的.所以这里先简单介绍下. 说明Egret Engine2D/3D: 白鹭引擎包含了白鹭时代研发的遵循HTML5标准的游戏引擎。他包括 2D / 3D 渲染核心、GUI体系、音频管理、资源管理等游戏引擎的常用模块。通过使用白鹭引擎，开发者可以尽可能的不用关注浏览器的底层实现，解决HTML5游戏性能问题及碎片化问题，灵活地满足开发者开发2D或3D游戏的需求。 Egret Wing: 主要开发代码的IDE,也可以开发游戏界面,并且也可以开发手机程序界面.所以有个项目叫做EUI,这个就是用于开发界面的项目. 有多个项目类型可以选择,最迷惑的就是游戏项目和EUI项目 仔细看下面所带的库不一样.EUI项目带有EUI编辑器,就是可以可视化编辑诸如按钮,面板之类的组件.他这里的组件不是那css绘制出来的,使用图片等组合起来的,所以可视化开发会很容易,但不知道速度上有没有优势. 经验: 在新建EUI模版的时候,不能用 new作为文件名字,注意是小写开头的.否则会无法使用可视化编辑器,可能是关键字冲突造成的. 所以只能用 New.exml. 游戏项目 可以通过修改 egretProperties.json 增加 &#123; &quot;name&quot;:&quot;eui&quot; &#125; 这一项来支持 EUI 可视编辑.不过 因为资源里resource缺少EUI组件的资源,所以备用的组件都不显示.这是因为是上面说的组件都是图片组合的.所以游戏项目就算这么改了 意义也不大.","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"},{"name":"App","slug":"App","permalink":"http://elickzhao.github.io/tags/App/"}]},{"title":"制作局部动态图","slug":"制作局部动态图","date":"2017-03-08T15:22:19.000Z","updated":"2021-09-09T16:34:45.548Z","comments":true,"path":"2017/03/制作局部动态图/","link":"","permalink":"http://elickzhao.github.io/2017/03/%E5%88%B6%E4%BD%9C%E5%B1%80%E9%83%A8%E5%8A%A8%E6%80%81%E5%9B%BE/","excerpt":"","text":"##简介为了做兔子的动态桌面以前弄了个视频,不过还不是特别满意,因为算不上循环.后来发现可以做局部动态图.这是个完美方案,所以学习了下.一开始打算用ps做.而且为了做这个,还特意升级了ps.结果发现教程实在太老,而且看不明白.虽然在知道大体意思.设一个视频为静态,放在前景.并扣空,显示后景动态视频.可是上面所说的剪切和一些工具都找不到在哪里.毕竟ps还是很大很专业的,你要不知道在哪里,真不好找.后来发现了Cliplets.这是专门做这个东西的.简单易用,下面就简单说下怎么用. ##使用 导入.导入只能导入10秒的视频,过大的视频会让你自己剪切. 右边为各个图层,最开始的为静态图层,会有个still选项,这是告诉你他是静态并一直显示.此外还有loop,mirror,play选项. loop: 默认生成的动态图层为loop,也就是单循环,这适合单次动画结尾与开头不影响的片段. mirror: 镜像,一般情况下这个用多,因为大多数片段结尾不能恢复到开头位置,用这个就可以第一段正序播放,第二段倒序播放恢复到初始位置. **注意:**图层的播放次数一定要偶数要不就起不到想要的效果了. play: 单次播放,不知道意义何在,这次使用时没有用到. 下面为图层播放次数.在整个视频播放时间段内,当前图层的播放次数.你可以拉伸加快活减慢播放速度.也可以单点片段,添加活减去播放次数.这里要提醒的是,loop 最后少一些播放次数,这样如果有位移,也不那么明显,而mirror上面已经说过了一定要复数,这里再次强调一下. 最上面为当期选取图层的原视频截取播放片段.这个因为最不好说所以放在了最后.每个图层可以选取视频的不同的播放时间段为循环基础,1图层和2图层的起始时间和结束时间可以是不同的.而且时长也可以自由掌握.所以这个软件真的很牛X. 参考文职Cliplets：可以制作局部动态图的软件Cliplets：轻松制作超动态Gif动画（微软出品）","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://elickzhao.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"软件","slug":"软件","permalink":"http://elickzhao.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"photoshop cc 2017 下载与破解","slug":"photoshop cc 2017 下载与破解","date":"2017-03-07T12:24:55.000Z","updated":"2021-09-09T16:34:45.349Z","comments":true,"path":"2017/03/photoshop cc 2017 下载与破解/","link":"","permalink":"http://elickzhao.github.io/2017/03/photoshop%20cc%202017%20%E4%B8%8B%E8%BD%BD%E4%B8%8E%E7%A0%B4%E8%A7%A3/","excerpt":"","text":"百度网盘下载地址: https://pan.baidu.com/s/1geMv2pH#list/path=%2F%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB%2FPS2017&amp;parentPath=%2F%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB 安装教程: https://pan.baidu.com/share/link?shareid=480414926&amp;uk=623581790 Adobe photoshop CC 2017破解版(软件+破解+图文教程):链接：http://pan.baidu.com/s/1kUELMKn 密码：2zvd 原帖地址:http://www.52pojie.cn/thread-550381-1-1.html","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://elickzhao.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"软件","slug":"软件","permalink":"http://elickzhao.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"Postman发送带cookie的http请求","slug":"Postman发送带cookie的http请求","date":"2017-03-03T13:28:49.000Z","updated":"2021-09-09T16:34:45.019Z","comments":true,"path":"2017/03/Postman发送带cookie的http请求/","link":"","permalink":"http://elickzhao.github.io/2017/03/Postman%E5%8F%91%E9%80%81%E5%B8%A6cookie%E7%9A%84http%E8%AF%B7%E6%B1%82/","excerpt":"","text":"Postman是chrome上一个非常好用的http客户端插件，可惜由于chrome安全的限制，发不出带cookie的请求。如果想要发送带cookie的请求，需要开启Interceptor： 这个Interceptor还需要到chrome应用商店下载 Postman Interceptor 扩展程序。现在能发送带cookie的http请求。发送cookie时，在header中添加key-value，key固定为Cookie，value是cookie具体的k=v，例如： 需要注意的是，发送带cookie的时候必须得开着chrome浏览器。","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"chrome","slug":"chrome","permalink":"http://elickzhao.github.io/tags/chrome/"},{"name":"postman","slug":"postman","permalink":"http://elickzhao.github.io/tags/postman/"}]},{"title":"2017-9-3-2日志","slug":"2017-3-2日志","date":"2017-03-02T14:59:50.000Z","updated":"2021-09-09T16:34:44.859Z","comments":true,"path":"2017/03/2017-3-2日志/","link":"","permalink":"http://elickzhao.github.io/2017/03/2017-3-2%E6%97%A5%E5%BF%97/","excerpt":"","text":"今天终于把锅和冰箱弄完了,终于可以写我爸那个股票程序.而且已经到了三月,很多麻烦的事都要来了,一个一个解决吧,还能如何呢.而且看看能不能找到一个满意的工作 呵呵.难!!!! 今天去打球了 不过没碰到房东 看来只有明天给他打电话了 今天给房东打电话了,结果却没来,这人也是心大啊,收钱都不积极. 今天终于把房费交了,居然没涨价,真是意外收获啊……不过今天弄ps做视频却没成功,还得重装ps.因为原来用那个是绿色精简版的.重装又费了好大劲,以前2015cc已经安装不上了,又下了个新的.百度网盘客户端真是越来越坑了.看来以后只能用火狐的插件下载百度云盘的连接了,这样下的快.","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://elickzhao.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"2017-2-26日志","slug":"2017-2-26日志","date":"2017-02-26T15:04:21.000Z","updated":"2021-09-09T16:34:44.854Z","comments":true,"path":"2017/02/2017-2-26日志/","link":"","permalink":"http://elickzhao.github.io/2017/02/2017-2-26%E6%97%A5%E5%BF%97/","excerpt":"","text":"今天修了一天的锅,这个破东西还真是费劲啊.昨晚有了点新的思路,这里整理下. 一. 现在直播平台是比较挣钱的,能从每个主播抽成30%,这真是太挣了,尤其那些打擦边球的直播.一晚上就好多钱.所以呢,现在做一个平台,或者经营一个平台实在太好了.要做只能做安卓APP这种的.因为网站平台手续繁琐,而且监管太强.还有就是,连方维都出直播平台了,没想到居然搞起来了. 二.一个小说思路,类似回到未来.穿越抗战题材的,结合了重返狼穴,日本野心家回到过去,妄图改变历史.中国特种兵只身前往. 嗯 就是以上这些内容了 有空再加….. 对了 那天看到个文章用vue做了个网易云音乐,感觉可以参考下,然后用这个改一下listen 1,然后看看用邮箱做一个到那里都能听的播放器,哦对了我想用gits 就是这个同步插件的东西保存,因为这个可以保存json格式,而歌曲保存也是json格式的. 今天只能点点点了…………","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://elickzhao.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"sync-setting 无法同步问题","slug":"sync-setting 无法同步问题","date":"2017-02-23T09:11:39.000Z","updated":"2021-09-09T16:34:45.405Z","comments":true,"path":"2017/02/sync-setting 无法同步问题/","link":"","permalink":"http://elickzhao.github.io/2017/02/sync-setting%20%E6%97%A0%E6%B3%95%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/","excerpt":"","text":"有一段时间没用Atom了,结果再打开的时候,sync-setting报了这个错误.sync-settings: Error retrieving your settings. (Bad credentials) 同步设置：检索设置错误。（坏凭据）. 原来是太长时间没有用,所以token已经过期了,只要去Github上重新申请个token放到设置里就好了. 申请token如果忘记了,看这里.Atom 编辑器配置sync-setting","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"Git","slug":"Git","permalink":"http://elickzhao.github.io/tags/Git/"}]},{"title":"2017-2-20日志","slug":"2017-2-20日志","date":"2017-02-20T08:57:02.000Z","updated":"2021-09-09T16:34:44.856Z","comments":true,"path":"2017/02/2017-2-20日志/","link":"","permalink":"http://elickzhao.github.io/2017/02/2017-2-20%E6%97%A5%E5%BF%97/","excerpt":"","text":"今天回北京了,又一大堆的事等着啊,房子啊 工作啊.真不知道2017会是什么样子啊.习惯了安逸就不愿意改变啊.无论是工作中,还是在家待着总不愿意变啊.今年会如何啊,不过钱已经光了,必须去干活了.但还是应该自己写点东西,你看方维已经搞出来了,真没想到.哎 走着看吧 世事无常谁能说清呢…","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://elickzhao.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"直播导航网站设想","slug":"直播导航网站设想","date":"2017-02-19T15:12:11.000Z","updated":"2021-09-09T16:34:45.715Z","comments":true,"path":"2017/02/直播导航网站设想/","link":"","permalink":"http://elickzhao.github.io/2017/02/%E7%9B%B4%E6%92%AD%E5%AF%BC%E8%88%AA%E7%BD%91%E7%AB%99%E8%AE%BE%E6%83%B3/","excerpt":"","text":"这两天突然有个构想,其实原因也很简单,现在直播网站多了,但是我喜欢的主播,有可能在不同的直播平台,而且我也不知道他今天直播的内容是否有趣,我也不能每次都切换平台去看,比较麻烦,所以有了这个念头.如果有一个主播导航网站的话,是不是就可以解决这个问题了.就如同当年的hao123.今天发了这个网站 http://www.zhiboqiang.com/ 他的想法跟我大致一样,不过他是把高人气的全部放到主页.可能通过抓取把上线的高人气主播放在一起.这个跟我想的有点不太一样,我是想打开直接在本网站就能看,他那个是直接跳转到那个网站了.看到闪酷网做的那个电视频道的直播,就是利用直播源,然后播放到自己的网站.不知道这种会给服务器带来多大压力,如果压力太大的话,就只能想刚才看到那个网站那样来弄了,不过那个效果的确不好.我还想到一个功能就是当某个主播人气上升过快,就有滚动提示,不过现在想想那样需要不能挺的扫描网站,不知道这样是不是也会很耗服务器性能,以后有空想想.","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://elickzhao.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"老年Mp3,听书机、听戏机等加密内存卡的破解","slug":"老年Mp3,听书机、听戏机等加密内存卡的破解","date":"2017-02-18T12:36:30.000Z","updated":"2021-09-09T16:34:45.721Z","comments":true,"path":"2017/02/老年Mp3,听书机、听戏机等加密内存卡的破解/","link":"","permalink":"http://elickzhao.github.io/2017/02/%E8%80%81%E5%B9%B4Mp3,%E5%90%AC%E4%B9%A6%E6%9C%BA%E3%80%81%E5%90%AC%E6%88%8F%E6%9C%BA%E7%AD%89%E5%8A%A0%E5%AF%86%E5%86%85%E5%AD%98%E5%8D%A1%E7%9A%84%E7%A0%B4%E8%A7%A3/","excerpt":"","text":"简介今天老姨拿来他的随身音乐播放机的内存卡,想要导出歌曲来.不过打开来看结果发现里面空空如野,即使打开隐身也没有东西,但是空间确实占了.而且发现了一个加密软件,估计就是加密软件加密后隐身了.这里就简单写下操作方法,看不懂就看下面图文. 操作一 打开隐身权限,并且系统文件隐身也得打开,就会发下一个Thumbs.ms 的文件夹,所有音乐就藏在这里不过现在看不到. 二 下载7-zipr解压软件,然后打开这个目录就会发现新的目录,一直打开到底就发现了音乐. 三 用7-zip的复制或者移动都可以,把音乐导入到电脑里. 四 要把音乐导入TF卡的时候,只要把7-zip里显示的音乐地址复制后,然后用7-zip的复制或者移动,把目标地址粘贴到里面,因为一般的文件管理器是看不到这个目录的很麻烦. 五 据说可以格式化TF卡,然后就可以随意用了,但是我担心播放机有固定地址,如果改了怕无法播放音乐,所以没动,以后有机会再尝试吧 参考文档http://jingyan.baidu.com/article/47a29f24311a10c0142399f7.html","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"玩机技巧","slug":"玩机技巧","permalink":"http://elickzhao.github.io/tags/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"}]},{"title":"vuex学习小记","slug":"vuex学习小记 ","date":"2017-02-15T14:15:53.000Z","updated":"2021-09-09T16:34:45.449Z","comments":true,"path":"2017/02/vuex学习小记 /","link":"","permalink":"http://elickzhao.github.io/2017/02/vuex%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%20/","excerpt":"","text":"先记录下 还没仔细看完, 以后有新的心得,再补充. vuex官方文档vue+vuex构建单页应用vuex入门实例(1/3)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"单机js小程序数据库选择 SqLite与MongoDB之间","slug":"单机js小程序数据库选择 SqLite与MongoDB之间","date":"2017-02-08T13:21:07.000Z","updated":"2021-09-09T16:34:45.571Z","comments":true,"path":"2017/02/单机js小程序数据库选择 SqLite与MongoDB之间/","link":"","permalink":"http://elickzhao.github.io/2017/02/%E5%8D%95%E6%9C%BAjs%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E6%8B%A9%20SqLite%E4%B8%8EMongoDB%E4%B9%8B%E9%97%B4/","excerpt":"","text":"打算用vue开发个单机小程序,于是这个数据库选择就是个问题了.看到这个小程序 notepad 他是用的 localStorage 不过这个存储有大小限制 不太适合我的要求.于是,就看到了SqLite与MongoDB, 这两个各有优点,确实不好选. MongoDB: 这个与Node.js联系紧密,速度很快,不过据说特别占空间,而且好像是运行在内存中,如果要保存在硬盘还需要特别操作,没用过所以具体如何不清楚. SqLite: 小巧精悍,据说一般用于手机程序和小程序,但是他是单线程用于硬盘,所以速度比不上MongoDB,但是占用空间小,而且可以使用sql语句,所以用起来比较简单. 经过考虑,原本打算用SqLite因为这个比较符合我的要求,但是因为从来没接触过MongoDB,所以这次就用MongoDB尝试下.不好用的情况下,就换回SqLite.","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://elickzhao.github.io/tags/MongoDB/"},{"name":"sqlite","slug":"sqlite","permalink":"http://elickzhao.github.io/tags/sqlite/"}]},{"title":"js,node与MongoDB使用","slug":"js,node与MongoDB使用","date":"2017-02-03T13:39:40.000Z","updated":"2021-09-09T16:34:45.189Z","comments":true,"path":"2017/02/js,node与MongoDB使用/","link":"","permalink":"http://elickzhao.github.io/2017/02/js,node%E4%B8%8EMongoDB%E4%BD%BF%E7%94%A8/","excerpt":"","text":"下面参考文档第一个,有详细的增删改查的方法,因为我暂时还没使用过所以先不写心得了.这里值得一提的是:原始的使用方法很是繁琐,这里有个推荐的插件是 Mongoose,这里安装也很简单,和其他node模块一样. npm install mongoose --save.可以尝试下.更多的mongoose使用看这里 ongoose文档.这篇文章也不错 Mongoose学习参考文档——基础篇 参考文档MongoDB的应用从零开始学习Node.js例子八 使用SQLite3和MongoDBMongoDB 教程","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://elickzhao.github.io/tags/MongoDB/"},{"name":"NoSql","slug":"NoSql","permalink":"http://elickzhao.github.io/tags/NoSql/"}]},{"title":"Yarn 更快的js套件管理 替换NPM","slug":"Yarn 更快的js套件管理 替换NPM","date":"2017-01-31T14:03:51.000Z","updated":"2021-09-09T16:34:45.085Z","comments":true,"path":"2017/01/Yarn 更快的js套件管理 替换NPM/","link":"","permalink":"http://elickzhao.github.io/2017/01/Yarn%20%E6%9B%B4%E5%BF%AB%E7%9A%84js%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%20%E6%9B%BF%E6%8D%A2NPM/","excerpt":"","text":"新一代戰神 Yarn 終於在昨天出爐了，Yarn 跟 Npm 一樣都是 JavaScript 套件版本管理工具，但是 Npm 令人詬病的是安裝都是非常的慢，快取機制用起來效果也不是很好，所以 Yarn 的出現解決了這些問題，透過 Yarn 安裝過的套件都會在家目錄產生 Cache (目錄在 ~/.yarn-cache/)，也就是只要安裝過一次，下次砍掉 node_modules 目錄重新安裝都會從 Cache 讀取。 安装 如果也就安装了npm 那么很简单 npm install -g yarn 如果没有安装npm,而且不想用npm了,那只有去官网下载安装包.下载地址：https://yarnpkg.com/latest.msi 不过被墙的厉害,所以需要有些准备. 现在官网可以访问了,而且速度很快并且有中文,搜索包也快很多. https://yarnpkg.com/zh-Hans/ 以前说那个下载的安装程序,这次尝试了,不过安装特别讨厌,并没有自动把命令放到环境变量里.而且安装位置也不好.所以还是用 npm 安装吧 比较简单 在强调一些搜索包真是太方便了,全是中文https://yarnpkg.com/zh-Hans/packages ##yarn更换下载源 // 查看下载源 yarn config get registry // 更换为淘宝源 yarn config set registry https 虽然原来的源还不错,不过下载些被墙了的和大的插件还是比较慢,所以换了淘宝.不过淘宝这个源不太稳定,还是怎么回事.有时说插件都安装成功了,不过使用的时候就报错.npm 就不会 搞不懂啊. 命令行对比官网原文链接|npm | Yarn || ——– | —– | —- ||npm install | yarn install ||(N/A) |yarn install –flat||(N/A) |yarn install –har||(N/A) |yarn install –no-lockfile||(N/A) |yarn install –pure-lockfile||npm install [package] |(N/A)||npm install –save [package] |yarn add [package]||npm install –save-dev [package] |yarn add [package] [–dev/-D]||(N/A) |yarn add [package] [–peer/-P]||npm install –save-optional [package] |yarn add [package] [–optional/-O]||npm install –save-exact [package] |yarn add [package] [–exact/-E]||(N/A) |yarn add [package] [–tilde/-T]||npm install –global [package] |yarn global add [package]||npm rebuild |yarn install –force||npm uninstall [package] |(N/A)||npm uninstall –save [package] |yarn remove [package]||npm uninstall –save-dev [package] |yarn remove [package]||npm uninstall –save-optional [package] |yarn remove [package]||npm cache clean |yarn cache clean||rm -rf node_modules &amp;&amp; npm install |yarn upgrade| 参考文档Yarn的安装与使用详细介绍","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"}]},{"title":"hexo迁移别的电脑步骤","slug":"hexo迁移别的电脑步骤","date":"2017-01-29T14:08:17.000Z","updated":"2021-09-09T16:34:45.169Z","comments":true,"path":"2017/01/hexo迁移别的电脑步骤/","link":"","permalink":"http://elickzhao.github.io/2017/01/hexo%E8%BF%81%E7%A7%BB%E5%88%AB%E7%9A%84%E7%94%B5%E8%84%91%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"其实吧,没什么.把整个目录拷贝过来,然后注意一下工具是否完整.git,hexo-cli,npm与node的版本别过低.最后就是一定要生成ssh公钥并加到github里,要不hexo d 是不能自动提交的.关于生成公钥看这里应用TortoiseGit为github账号添加SSH keys","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"hexo","slug":"hexo","permalink":"http://elickzhao.github.io/tags/hexo/"}]},{"title":"js前端插件大总结","slug":"js前端插件大总结","date":"2017-01-16T14:36:41.000Z","updated":"2021-09-09T16:34:45.225Z","comments":true,"path":"2017/01/js前端插件大总结/","link":"","permalink":"http://elickzhao.github.io/2017/01/js%E5%89%8D%E7%AB%AF%E6%8F%92%E4%BB%B6%E5%A4%A7%E6%80%BB%E7%BB%93/","excerpt":"","text":"vue-markdown-loader vue插件 转换md文件成网页Github地址 TheaterJS 打字输入效果的插件Github地址 cooking 快速简易配置webpa 让你快速开始开发前端官方文档Github地址 Layer layer是一款近年来备受青睐的web弹层组件官方网站 SweetAlert2 强大的纯Js模态消息对话框插件 DEMO展示github地址 pNotify JavaScript 的消息提醒插件 官网暂时打不开先用这个吧github地址 Moment.js JavaScript 日期处理类库 中国官网github地址 FlipClock.js 一个好看的时钟 官方网站演示github地址","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"不错的前台框架 总结 Semantic UI,slicy,Amaze ui 等等","slug":"不错的前台框架 总结 Semantic UI,slicy,Amaze ui 等等","date":"2017-01-15T14:07:43.000Z","updated":"2021-09-09T16:34:45.526Z","comments":true,"path":"2017/01/不错的前台框架 总结 Semantic UI,slicy,Amaze ui 等等/","link":"","permalink":"http://elickzhao.github.io/2017/01/%E4%B8%8D%E9%94%99%E7%9A%84%E5%89%8D%E5%8F%B0%E6%A1%86%E6%9E%B6%20%E6%80%BB%E7%BB%93%20Semantic%20UI,slicy,Amaze%20ui%20%E7%AD%89%E7%AD%89/","excerpt":"","text":"IView: 是用vue2开发的前端框架,拿来搭建后台非常省事.官方网站 layui: 国产复古框架.目前刚开发还有点问题,不过以后可以看看.这个相对简单,开发小东西比较适合.官方网站 Element: 网站快速成型工具.放在这里不知道合不合适,这是个’饿了吗’做的基于vue.js 2.0的前端框架,所有东西都被做成了组件了. 相关文档:Element官网 QMUI Web: 一个旨在提高 UI 开发效率 快速产生项目 UI 的前端框架.这是QQ的一个前端UI还没仔细看过 相关文档:QMUI Web官网 Semantic UI: 新进小生,看起来很美.而且组件丰富,感觉更简单容易上手.还没用过,以后尝试下.而且他的文档也特别详细 这个好像IE9以下兼容不好 相关文档:Semantic UI中国官网 materialscss: 这是新发现的极好的,google出的,简单大气,做些产品的官网十分好.而且他的效果是立体的不是普通的UI那样非常爽.而且和vue.js配合的很好中文官网Material Design 设计原型 根据这个做的上面的框架配合vue.js的组件 Amaze ui: 这个框架和bootstrap很神似,不过他的好处是中文文档详细,比较是中国自己的玩意么.兼容IE8 相关文档:妹子官网 拼图pintuer: 这个使用过,主要跟妹子UI差不多,颜色很靓丽.最主要原因他有套免费的后台代码.拼图官网 H-ui: 这个关注他的主要原因也是因为有个后台模版,而且这个模版比拼图那个更好.有空可以利用这个和laravel结合做一个东西.这个后台模版更接近操控后台,比如收银等,因为页面很朴实,不像网上后台.而且这个框架不支持手机页面官方网站 zui: 还不错替代bootstrap好方案,简单易学.兼容也还可以,配合一些其他插件 相关文档:官方网站 切图框架slicy: 这个框架虽然比较小众,但是有个好处就是即兼容IE6~IE9,又能做到手机和pc的响应式布局 相关文档:切图官网 bootstrap: 这个好像没什么比较多说了,人人都知道 相关文档:中国官网内容很丰富 Foundation: 这个貌似在中国用的很少,知道是干啥的就行了 相关文档:Foundation简介 UIkit: 很早就接触到的框架,但是一直没用过.好像他的特色是很小. 相关文档:官方网站","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"},{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"前台框架","slug":"前台框架","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E5%8F%B0%E6%A1%86%E6%9E%B6/"}]},{"title":"laravel核心理解 ServiceProvider(服务提供者) Container(容器) Facades(门面)","slug":"laravel核心理解 ServiceProvider(服务提供者) Container(容器) Facades(门面)","date":"2017-01-13T14:33:21.000Z","updated":"2021-09-09T16:34:45.268Z","comments":true,"path":"2017/01/laravel核心理解 ServiceProvider(服务提供者) Container(容器) Facades(门面)/","link":"","permalink":"http://elickzhao.github.io/2017/01/laravel%E6%A0%B8%E5%BF%83%E7%90%86%E8%A7%A3%20ServiceProvider(%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85)%20Container(%E5%AE%B9%E5%99%A8)%20Facades(%E9%97%A8%E9%9D%A2)/","excerpt":"时间紧迫先简单说明下 服务提供者: 是绑定服务到容器的工具. 容器: 是laravel装载服务提供者提供的服务实例的集合或对象 门面: 使用这些服务的快捷方式.也就是静态方法. 注意: 如果一个类没有基于任何接口那么就没有必要将其绑定到容器。容器并不需要被告知如何构建对象，因为它会使用 PHP 的反射服务自动解析出具体的对象。(?后面这个明白意思,但不知道怎么做)","text":"时间紧迫先简单说明下 服务提供者: 是绑定服务到容器的工具. 容器: 是laravel装载服务提供者提供的服务实例的集合或对象 门面: 使用这些服务的快捷方式.也就是静态方法. 注意: 如果一个类没有基于任何接口那么就没有必要将其绑定到容器。容器并不需要被告知如何构建对象，因为它会使用 PHP 的反射服务自动解析出具体的对象。(?后面这个明白意思,但不知道怎么做) Provider (服务提供者)主要作用就是绑定服务到容器中,看下面例子. 在一个服务提供者中，可以通过 $this-&gt;app 变量访问容器，然后使用 bind 方法注册一个绑定，该方法需要两个参数，第一个参数是我们想要注册的类名或接口名称，第二个参数是返回类的实例的闭包 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Providers;use Riak\\Connection;use Illuminate\\Support\\ServiceProvider;class RiakServiceProvider extends ServiceProvider&#123; /** * 在容器中注册绑定。 * * @return void */ public function register() &#123; //这是5.3写法 $this-&gt;app-&gt;singleton(Connection::class, function ($app) &#123; return new Connection(config(&#x27;riak&#x27;)); &#125;); //5.2以前这么写 $this-&gt;app-&gt;singleton(&#x27;Riak\\Contracts\\Connection&#x27;, function ($app)&#123;...&#125; // Connection::class 返回的就是命名空间字符串(可以看另一个我的文章),所以跟5.2是一样的. //这里千万注意&#x27;Riak\\Contracts\\Connection&#x27;是个字符串,相当于在容器中定义了一个名字并把实例赋值给了这个名字. //并没有其他更高深的含义 //所以只要在 config/app 下的provider数组里 注册一下就可以使用了 &#125;&#125; 但是最经常用的方式是: 服务容器的一个非常强大的特性是其绑定接口到实现的能力。我们假设有一个 EventPusher 接口及其 RedisEventPusher 实现，编写完该接口的 RedisEventPusher 实现后，就可以将其注册到服务容器： 123//EventPusher 为契约接口//RedisEventPusher 为实现这个接口的redis工具$this-&gt;app-&gt;bind(&#x27;App\\Contracts\\EventPusher&#x27;, &#x27;App\\Services\\RedisEventPusher&#x27;); 这样做的妙处在于这里: 这段代码告诉容器当一个类需要 EventPusher 的实现时将会注入 RedisEventPusher，现在我们可以在构造器或者任何其它通过服务容器注入依赖的地方进行 EventPusher 接口的类型提示,就会把RedisEventPusher的实例传给类 还有个好处就是,当想要换掉EventPusher,很方便你不需要改别的地方的代码只要在provider把绑定类换掉就可以了,换成另一个实现了 EventPusher 类就ok了. 当然还有更强大一个接口绑定多个实现,然后根据条件选择使用的类,这个 laravel 也能做到. 1234567891011use App\\Contracts\\EventPusher;/** * 创建一个新的类实例 * * @param EventPusher $pusher * @return void */public function __construct(EventPusher $pusher)&#123; $this-&gt;pusher = $pusher;&#125; 绑定到容器后,就是注册到Provider,让 laravel 可以自动加载这次很简单 就是添加到 config/app 下的 Provider数组里 1234567891011 &#x27;providers&#x27; =&gt; [ /* * Laravel Framework Service Providers... */ Illuminate\\Auth\\AuthServiceProvider::class, Illuminate\\Broadcasting\\BroadcastServiceProvider::class, Illuminate\\Bus\\BusServiceProvider::class, Illuminate\\Cache\\CacheServiceProvider::class,.... ], 然后就是使用了其实上面已经说过了 使用最长用的方法就是 __construct()里注入 123456789101112131415161718use App\\Contracts\\EventPusher;/** * 创建一个新的类实例 * * @param EventPusher $pusher * @return void */public function __construct(EventPusher $pusher)&#123; $this-&gt;pusher = $pusher;&#125;public function test()&#123; //当然还可以手动调用 $fooBar = $this-&gt;app-&gt;make(&#x27;FooBar&#x27;); //其次，你可以以数组方式访问容器，因为其实现了 PHP 的 ArrayAccess 接口： $fooBar = $this-&gt;app[&#x27;FooBar&#x27;];&#125; 容器说明容器很简单 就是$this-&gt;app 或者帮助函数app()获得就是laravel实例 里面就是容器 门面说明有空具体写一下, 门面有两个情形,一种是Cache类的,一种是Config类的. Config比较简单就是实现了一个接口,然后关联一个服务. 而且好像是laravel自动加载的,不需要手动在config/app的数组里添加.但是Cache就不同了,他必须在config/app里手动添加.而且他还有一个服务提供者Provider,在容器里的’cache’其实首先指定的是这个Provider,并不像Config那么简单直接指向服务了. 这是门面类, 这里的’cache’是容器里的实例. 这个在Config/app的alias里. 但你会发现Cache绑定容器的Provider,帮的’cache’是个管理类. 但是Config却找不到这个Provider在哪里.他只有简单的继承了一个接口就完了. 12345678910class Cache extends Facade&#123; /** * 获取组件注册名称 * * @return string */ protected static function getFacadeAccessor() &#123; return &#x27;cache&#x27;; &#125;&#125;","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"npm 及 node.js 升级自己","slug":"Npm及 node.js 升级自己 ","date":"2017-01-12T04:38:53.000Z","updated":"2021-09-09T16:34:44.993Z","comments":true,"path":"2017/01/Npm及 node.js 升级自己 /","link":"","permalink":"http://elickzhao.github.io/2017/01/Npm%E5%8F%8A%20node.js%20%E5%8D%87%E7%BA%A7%E8%87%AA%E5%B7%B1%20/","excerpt":"","text":"npm 自身升级1npm -g install npm node.js 自身升级123456789# node有一个模块叫n（这名字可够短的。。。），是专门用来管理node.js的版本的。# 首先安装n模块：npm install -g n #升级node.js到最新稳定版n stable# n 后面也可以跟随版本号比如： n v0.10.26 有一次升级遇到问题,根本无法通过上面方法实现升级,而且会报错提示级别太低.这是唯一的办法是下载新的windows版本重载才行.还有就是 n这个程序好像只是在linux下才好使,windows下是没用的.","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"}]},{"title":"webpack的'Cannot find module 'webpacklibnodeNodeTemplatePlugin'问题","slug":"webpack的'Cannot find module 'webpacklibnodeNodeTemplatePlugin'问题","date":"2017-01-11T12:55:10.000Z","updated":"2021-09-09T16:34:45.469Z","comments":true,"path":"2017/01/webpack的'Cannot find module 'webpacklibnodeNodeTemplatePlugin'问题/","link":"","permalink":"http://elickzhao.github.io/2017/01/webpack%E7%9A%84'Cannot%20find%20module%20'webpacklibnodeNodeTemplatePlugin'%E9%97%AE%E9%A2%98/","excerpt":"","text":"第一步：npm config get prefix ，获取输出path C:\\Users\\jaxGu\\AppData\\Roaming\\npm加上\\node_modules用于第二步值 第二步：添加系统环境变量：NODE_PATH:C:\\Users\\jaxGu\\AppData\\Roaming\\npm\\node_modules 第三步：关掉命令行，重新打开。 参考文档『奇葩问题集锦』Cannot find module ‘webpack/lib/node/NodeTemplatePlugin’webpack的问题","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"webpack","slug":"webpack","permalink":"http://elickzhao.github.io/tags/webpack/"}]},{"title":"node.js中的path.resolve方法使用说明","slug":"node.js中的path.resolve方法使用说明","date":"2017-01-10T11:57:01.000Z","updated":"2021-09-09T16:34:45.323Z","comments":true,"path":"2017/01/node.js中的path.resolve方法使用说明/","link":"","permalink":"http://elickzhao.github.io/2017/01/node.js%E4%B8%AD%E7%9A%84path.resolve%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"方法说明：将参数 to 位置的字符解析到一个绝对路径里。 1path.resolve([from ...], to) 简介当使用插件不在标准路径的时候,可以使用这个函数方便的引入. 由于该方法属于path模块，使用前需要引入path模块（var path= require(“path”) ）接收参数：from 源路径to 将被解析到绝对路径的字符串 例子： 1234567891011121314151617path.resolve(&#x27;/foo/bar&#x27;, &#x27;./baz&#x27;) // returns &#x27;/foo/bar/baz&#x27; path.resolve(&#x27;/foo/bar&#x27;, &#x27;/tmp/file/&#x27;) // returns &#x27;/tmp/file&#x27; path.resolve(&#x27;wwwroot&#x27;, &#x27;static_files/png/&#x27;, &#x27;../gif/image.gif&#x27;) // if currently in /home/myself/node, it returns &#x27;/home/myself/node/wwwroot/static_files/gif/image.gif&#x27; node.js中的path.resolve方法使用说明","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"Velocity.js简单介绍","slug":"Velocity.js简单介绍","date":"2017-01-09T14:36:53.000Z","updated":"2021-09-09T16:34:45.061Z","comments":true,"path":"2017/01/Velocity.js简单介绍/","link":"","permalink":"http://elickzhao.github.io/2017/01/Velocity.js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"简介Velocity 是一个简单易用、高性能、功能丰富的轻量级JS动画库。它能和 jQuery 完美协作，并和$.animate()有相同的 API， 但它不依赖 jQuery，可单独使用。 Velocity 不仅包含了 $.animate() 的全部功能， 还拥有：颜色动画、转换动画(transforms)、循环、 缓动、SVG 动画、和 滚动动画 等特色功能。 它比 $.animate() 更快更流畅，性能甚至高于 CSS3 animation， 是 jQuery 和 CSS3 transition 的最佳组合，它支持所有现代浏览器，最低可兼容到 IE8 和 Android 2.3。 Velocity 目前已被数以千计的公司使用在自己的项目中，包括 WhatsApp, Tumblr, Windows, Samsung, Uber 等，这里 Libscore.com 统计了哪些站点正使用 velocity.js。 参数概述和基础写法Velocity 接收一组 css 属性键值对 (css map) 作为它的第一个参数，该参数作为动画效果的最终属性。第二个参数是可选参数 为动画的额外配置项。下面为参数的写法： 1234567891011121314151617$element.velocity(&#123; width: &quot;500px&quot;, // 动画属性 宽度到 &quot;500px&quot; 的动画 property2: value2 // 属性示例&#125;, &#123; /* Velocity 动画配置项的默认值 */ duration: 400, // 动画执行时间 easing: &quot;swing&quot;, // 缓动效果 queue: &quot;&quot;, // 队列 begin: undefined, // 动画开始时的回调函数 progress: undefined, // 动画执行中的回调函数（该函数会随着动画执行被不断触发） complete: undefined, // 动画结束时的回调函数 display: undefined, // 动画结束时设置元素的 css display 属性 visibility: undefined, // 动画结束时设置元素的 css visibility 属性 loop: false, // 循环 delay: false, // 延迟 mobileHA: true // 移动端硬件加速（默认开启）&#125;); 简单就说这些吧,具体看下面例子.更多的看参考文档,因为很难在简单篇幅里简单解释完全,以后遇到什么问题再补充,还有就是这里还需要一点 easing 的东西,这可以看以前的文章. 参考文档Velocity.js介绍Velocity.js中文文档Velocity ui 动作样式极棒的jquery动画切换引擎插件Velocity.js","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"jQuery Easing 简单讲解","slug":"jQuery Easing 简单讲解","date":"2017-01-08T14:58:30.000Z","updated":"2021-09-09T16:34:45.172Z","comments":true,"path":"2017/01/jQuery Easing 简单讲解/","link":"","permalink":"http://elickzhao.github.io/2017/01/jQuery%20Easing%20%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"简介( ′◔ ‸◔`) 以前看过这个,不过时间长了,就记不清了. easing就是模拟物理动作模型.从图片来看就更清楚了.http://www.runoob.com/jqueryui/api-easings.html在这里能看到,每个动作的演示,点击每个图片就能看到了 easing参数可选的值就有以下32种： linear swing easeInQuad easeOutQuad easeInOutQuad easeInCubic easeOutCubic easeInOutCubic easeInQuart easeOutQuart easeInOutQuart easeInQuint easeOutQuint easeInOutQuint easeInExpo easeOutExpo easeInOutExpo easeInSine easeOutSine easeInOutSine easeInCirc easeOutCirc easeInOutCirc easeInElastic easeOutElastic easeInOutElastic easeInBack easeOutBack easeInOutBack easeInBounce easeOutBounce easeInOutBounce 参考文档jQuery Easing 使用方法及其图解 官网动作演示帮助你更好理解javascript中easing功能的网站 - Easings.netjQuery UI API - Easings","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"jquery","slug":"jquery","permalink":"http://elickzhao.github.io/tags/jquery/"},{"name":"easing","slug":"easing","permalink":"http://elickzhao.github.io/tags/easing/"}]},{"title":"Nginx服务器端解决font字体文件跨域","slug":"Nginx服务器端解决font字体文件跨域","date":"2017-01-07T14:32:45.000Z","updated":"2021-09-09T16:34:44.989Z","comments":true,"path":"2017/01/Nginx服务器端解决font字体文件跨域/","link":"","permalink":"http://elickzhao.github.io/2017/01/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%A7%A3%E5%86%B3font%E5%AD%97%E4%BD%93%E6%96%87%E4%BB%B6%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"Nginx服务器端解决font字体文件跨域","categories":[],"tags":[{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}]},{"title":"Atom插件推荐","slug":"Atom插件推荐","date":"2017-01-06T14:48:56.000Z","updated":"2021-09-09T16:34:44.868Z","comments":true,"path":"2017/01/Atom插件推荐/","link":"","permalink":"http://elickzhao.github.io/2017/01/Atom%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"下面的文章都有具体介绍了,就不一一写了,感觉比较常用或者比较易忘的记录一下. sync-settings插件备份、按键绑定备份插件主页面安装主页已经写了,最核心的是需要注册一个gist用于同步的仓库,这个在Github主页里能找到,gist好像是一个用于文本同步的东西.这个是安装时的难点,使用就很简单了,把名字写上后,每次打开atom都会同步插件的. 今天在另一个电脑上安装了,看来还是的记录下才行,没想象中那么容易 安装只需要填入 Personal Access Token 和 Gist ID 就可以了Personal Access Token : 91c2f32691fee3e264df51417a3a8f40f7d7850bGist ID : b65042216cbcb67891be5dbcc34c0edf 使用这里差点弄错.如果是备份的话,就点扩展包里菜单的 sync-settings:backup恢复就用扩展包里菜单的 sync-settings:restore 所以在新装电脑中点 sync-settings:restore 就能同步了,千万不要点 sync-settings:backup 参考文档ATOM基础教程一ATOM插件推荐(4)Atom 基础教程","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"},{"name":"atom","slug":"atom","permalink":"http://elickzhao.github.io/tags/atom/"}]},{"title":"HTTP访问控制(CORS)","slug":"HTTP访问控制(CORS)","date":"2017-01-05T14:12:31.000Z","updated":"2021-09-09T16:34:44.922Z","comments":true,"path":"2017/01/HTTP访问控制(CORS)/","link":"","permalink":"http://elickzhao.github.io/2017/01/HTTP%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6(CORS)/","excerpt":"","text":"使用 Access-Control-Max-Age 来缓存 CORS 配置使用withCredentials发送跨域请求凭据Access-Control-Allow-Origin与跨域HTTP访问控制(CORS)","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"nginx 下装laravel","slug":"Nginx下装laravel ","date":"2017-01-04T15:14:51.000Z","updated":"2021-09-09T16:34:44.986Z","comments":true,"path":"2017/01/Nginx下装laravel /","link":"","permalink":"http://elickzhao.github.io/2017/01/Nginx%E4%B8%8B%E8%A3%85laravel%20/","excerpt":"","text":"nginx 配置时 一定要做路由转换,因为laravel使用的是简洁版路由.apache因为在public目录里有 .htaccess所以不用管了, nginx就得自己配置了. 把这句添加进去就哦了 123location / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; Laravel Nginx 除 / 外所有路由 404官方文档","categories":[],"tags":[{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"},{"name":"nginx","slug":"nginx","permalink":"http://elickzhao.github.io/tags/nginx/"}]},{"title":"ECMAScript 简介","slug":"ECMAScript 简介","date":"2017-01-03T14:37:37.000Z","updated":"2021-09-09T16:34:44.891Z","comments":true,"path":"2017/01/ECMAScript 简介/","link":"","permalink":"http://elickzhao.github.io/2017/01/ECMAScript%20%E7%AE%80%E4%BB%8B/","excerpt":"","text":"前言ECMAScript 6 简单来讲就是一个javascript的标准版本,和现用版本不是很相同.而且由于浏览器支持的不同,很多新写法都不支持.只有等标准化完成后,统一了才能更实用.现在一般的情况是用babel进行转化兼容使用,这个可以用webpace做到,不过最新可以用cooke做了. 参考文档ECMAScript的基础概念ECMAScript 6简介","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"webpack 配置选项详解","slug":"webpace 配置选项详解","date":"2017-01-02T13:13:05.000Z","updated":"2021-09-09T16:34:45.456Z","comments":true,"path":"2017/01/webpace 配置选项详解/","link":"","permalink":"http://elickzhao.github.io/2017/01/webpace%20%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"官方现在已经有了中文,而且文档比较完善了,参考还是看官方吧webpace官方网站 几个问题 webpack-dev-server 不会生成文件到 output 目录里 而是生成到内存里 webpack-dev-server 用命令行比Node.js Api方式简单太多了.Node.js Api方式还需要安装各种插件 webpack-dev-server 各种配置解释参考官方文档 特别全 以下都是旧文章了,可能用处不大了.React+Webpack快速上手指南Webpack 性能优化 （一）（使用别名做重定向）Webpack 入门指迷","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"http://elickzhao.github.io/tags/webpack/"}]},{"title":"2016最后一天的纪念","slug":"2016最后一天的纪念","date":"2016-12-31T14:12:52.000Z","updated":"2021-09-09T16:34:44.852Z","comments":true,"path":"2016/12/2016最后一天的纪念/","link":"","permalink":"http://elickzhao.github.io/2016/12/2016%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%E7%9A%84%E7%BA%AA%E5%BF%B5/","excerpt":"","text":"唉 2016就这命悄悄匆匆的走了.这一年,真是休息了一整年啊.工作上真是没啥建树啊,不过把车学了也算有点成绩了.唉,钱也花光了啊.明年要加倍努力才行了.唉,真是懒惰成性啊,有很多计划本应该完成的却没有完成啊.动手能力实在太弱了啊.今年唯一记忆的是,学车那段时间,虽然痛苦些,不过也蛮好玩的,尤其是考试的时候.明天就是新的一年了,要开始加油了!加油! 2016再见!","categories":[],"tags":[{"name":"心情随笔","slug":"心情随笔","permalink":"http://elickzhao.github.io/tags/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"},{"name":"日志","slug":"日志","permalink":"http://elickzhao.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"JWT简介","slug":"JWT简介","date":"2016-12-30T14:23:17.000Z","updated":"2021-09-09T16:34:44.951Z","comments":true,"path":"2016/12/JWT简介/","link":"","permalink":"http://elickzhao.github.io/2016/12/JWT%E7%AE%80%E4%BB%8B/","excerpt":"","text":"客户端 token 只存简单的数据，如 userId 。永不过期，除非服务端返回 403 状态码。 当 token 进来时，校验，解析出 userId ，从缓存（如 redis ）获得 userData ，若缓存存在，更新过期时间。 若缓存没有命中，从数据库加载返回同时存入缓存，设置过期时间。 基于安全考虑，可在 token 中再加入一个 version 字段，在第 2 步时校验该段。当改密码或其它需要将所有已登录的客户端重登时只需更新 version 字段，并清空缓存即可。以上，客户端无需主动刷新，也无需定期更换 token ，只有在服务端声明 token 无效时抛弃即可，同时里面也不会包含太多的敏感信息（ jwt 只是 base64 编码，随手都可以解析数据出来，不应将敏感数据放在此处），数据量少 token 相对也短些，对传输也有好处；服务端可完全控制 token 的有效性，在必要的情况下可自主 revoke 已颁发的 token 。 参考文档JWT 简介从零实现Lumen-JWT扩展包(序):前因Lumen上使用Dingo/Api做API开发时用JWT-Auth做认证的实现Laravel 5 中使用 JWT（Json Web Token） 实现基于API的用户认证什么是JWT – JSON WEB TOKEN使用json web token Laravel (Lumen) 中使用JWT-Auth刷新token的问题自定义中间件（Middleware）监听 Jwt-auth 身份认证（Laravel） Laravel实现dingo+JWT api接口之实战篇","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"极棒的jquery动画切换引擎插件Velocity.js","slug":"极棒的jquery动画切换引擎插件Velocity.js","date":"2016-12-29T14:24:49.000Z","updated":"2021-09-09T16:34:45.684Z","comments":true,"path":"2016/12/极棒的jquery动画切换引擎插件Velocity.js/","link":"","permalink":"http://elickzhao.github.io/2016/12/%E6%9E%81%E6%A3%92%E7%9A%84jquery%E5%8A%A8%E7%94%BB%E5%88%87%E6%8D%A2%E5%BC%95%E6%93%8E%E6%8F%92%E4%BB%B6Velocity.js/","excerpt":"","text":"Velocity.js是一款jquery动画引擎插件，它拥有与jquery中的$.animate()相同的API，还打包了颜色动画，转换，循环，easing效果，类动画、滚动等功能，因此大家可以像使用$.animate()方法一样使用velocity，您可以快速的上手velocity.js。简单点说：Velocity就是实现页面元素中的飞入，飞出，旋转、颜色变换，esaing效果的jquery动画插件。 这个插件速度很快,但是还没具体用过,先记录一下,具体使用看下面文档吧.哦,对了,这个插件其实可以配合jquery一起用,不用jquery,单独使用也是可以的. 参考文档极棒的jquery动画切换引擎插件Velocity.js官方网站","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"centos 服务器加固","slug":"centos 服务器加固","date":"2016-12-28T14:36:47.000Z","updated":"2021-09-09T16:34:45.113Z","comments":true,"path":"2016/12/centos 服务器加固/","link":"","permalink":"http://elickzhao.github.io/2016/12/centos%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E5%9B%BA/","excerpt":"","text":"CentOS下SSH端口修改CentOS防火墙iptables的配置方法详解","categories":[],"tags":[{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}]},{"title":"H5+ 遇到的一些问题总结","slug":"H5+ 遇到的一些问题总结","date":"2016-12-27T15:03:35.000Z","updated":"2021-09-09T16:34:44.920Z","comments":true,"path":"2016/12/H5+ 遇到的一些问题总结/","link":"","permalink":"http://elickzhao.github.io/2016/12/H5+%20%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"chrome调试,必须在配置文件里打开调试的选项.遇到显示手机不显示页面,说明安卓4.4以下系统.白屏是因为必须翻墙 调用入口页面,也就是首页.可使用下面方法.12// 查找应用首页窗口对象var h=plus.webview.getWebviewById( plus.runtime.appid ); 预加载时,id和url都必须的设置.要不真机调试时不会出错.打包后会出现空页面.这次遇到的就是id忘记加了123456789101112mui.init(&#123; preloadPages:[ &#123; id:preload-page-id, url:prelaod-page-url, styles:&#123;&#125;,//窗口参数 extras:&#123;&#125;,//自定义扩展参数 subpages:[&#123;&#125;,&#123;&#125;]//预加载页面的子页面 &#125; ], preloadLimit:5//预加载窗口数量限制(一旦超出,先进先出)默认不限制&#125;); 类点击事件这么写,一定要先选类的外层,然后在选要点击的类.12345678910111213//html &lt;div class=&quot;mui-slider-item&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img src=&quot;img/start1.png&quot; id=&quot;_d1&quot;&gt; &lt;p class=&quot;jump&quot; &gt;&lt;/p&gt; &lt;/a&gt; &lt;/div&gt;//js// .on的第二个参数为选择器 与.addEventListener()不一样 .addEventListener第二个参数为回调函数了. mui(&#x27;.mui-slider-item&#x27;).on(&#x27;tap&#x27;,&#x27;.jump&#x27;,function()&#123; redirect(); &#125;); 子webview的监听一定要等到webview创建好后,并且显示了.才能创建监听否则会报错的.还有一定要写在 mui.plusReady(function() &#123;&#125;) 里否则也会报错 123456789101112131415mui.plusReady(function() &#123; currentWebview = plus.webview.currentWebview(); main = plus.webview.currentWebview().opener(); //currentWebview的监听只能写在这里 写在外面就会报错 currentWebview.addEventListener(&#x27;maskClick&#x27;, function()&#123; mui.fire(main, &quot;menu:swipeleft&quot;); &#125;);&#125;);//外面只能是整个窗口的监听,不过因为webview是嵌套的,//mask只是作用在当期webview,所以用window是不起作用的 window.addEventListener(&quot;swipeleft&quot;, closeMenu); //子页面没有创建,监听会报错//curSub.addEventListener(&#x27;maskClick&#x27;, closeMenu()); mask一些问题123456789101112131415161718192021222324252627//遮罩子页面 按照文档说法应该子页面也遮罩为啥我这个不行呢/** mask: (String 类型 )窗口的遮罩*用于设置Webview窗口的遮罩层样式，遮罩层会覆盖Webview中所有内容，包括子webview，* 并且截获webview的所有触屏事件，此时Webview窗口的点击操作会触发maskClick事件。* 字符串类型，可取值： rgba格式字符串，定义纯色遮罩层样式，* 如&quot;rgba(0,0,0,0.5)&quot;，表示黑色半透明； &quot;none&quot;，表示不使用遮罩层； 默认值为&quot;none&quot;，即无遮罩层。*///这是用的很笨的方法 在主页面里使用子页面遮罩// curSub.setStyle(&#123;// mask:&#x27;rgba(0,0,0,.3)&#x27;// &#125;) // 这个是当侧滑栏出现时,主页面绘制 mask,这个绘制的mask就能把apeend的子页面遮盖住 mainWebView.setStyle(&#123; left: &#x27;70%&#x27;, mask: &#x27;rgba(0,0,0,.3)&#x27;, transition: &#123; duration: 150 //动画持续时间 &#125; //但是这个绘制的mask不知道如何监听滑动,只能监听点击 //还有个生成mask的方法是这个 mask = mui.createMask(_closeMenu); // _closeMenu是回调函数,当点击时候如何操作 mask.show(); //显示遮罩 //这个遮罩支持滑动监听 而且默认关闭menu 但有个问题子页面不能遮罩上 mask.close(); //关闭遮罩","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"APP","slug":"APP","permalink":"http://elickzhao.github.io/tags/APP/"}]},{"title":"Babel 使用简介","slug":"Babel 使用简介","date":"2016-12-26T12:40:49.000Z","updated":"2021-09-09T16:34:44.871Z","comments":true,"path":"2016/12/Babel 使用简介/","link":"","permalink":"http://elickzhao.github.io/2016/12/Babel%20%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/","excerpt":"","text":"这个教程是单独使用,并不是和webpace配合的那种.这个视频讲的非常详细.但是这个视频比较早期了,所以有些东西已经不适用了.比如那个 browser.js 的位置,已经不在那里了.如果想用就用https://cdnjs.com/ 从外在引用好了.但是有个问题是报错了,不知道什么引起的.而且chrome浏览器已经支持一些方法了,根本不需要babel,IE是不行的. 参考教程官方网站","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"JS 数组的 push 与 concat 区别","slug":"JS 数组的 push 与 concat 区别","date":"2016-12-25T13:38:47.000Z","updated":"2021-09-09T16:34:44.935Z","comments":true,"path":"2016/12/JS 数组的 push 与 concat 区别/","link":"","permalink":"http://elickzhao.github.io/2016/12/JS%20%E6%95%B0%E7%BB%84%E7%9A%84%20push%20%E4%B8%8E%20concat%20%E5%8C%BA%E5%88%AB/","excerpt":"","text":"push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 12var a = [1,2,3,4];a.push(5); //a 现在是1,2,3,4,5 concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 123456var a = [1,2,3,4];var b = [5,6];var c = a.concat(b); // a,b 数组都不变，c变成了1,2,3,4,5,6//这里要注意是 c 变成了合并数组 不是 b , 所以这和push是有区别的 因为concat()会生成个副本这个特性,所以有人说可能速度会有一些影响,但我没测试过,不好说,这里记录下吧.他给出的解决方案是这样的. 12var arr1= [1,2,3]; arr1.push.apply(arr1,[4,5]); // 这时 arr1 就是 [1,2,3,4,5] 这个 apply() 也不是很懂,有空研究下. 先看看这个吧 Js apply方法详解 参考文档不用concat解决Javascript连接多个数组","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"使用dingo返回数据","slug":"使用dingo返回数据","date":"2016-12-19T15:22:35.000Z","updated":"2021-09-09T16:34:45.538Z","comments":true,"path":"2016/12/使用dingo返回数据/","link":"","permalink":"http://elickzhao.github.io/2016/12/%E4%BD%BF%E7%94%A8dingo%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/","excerpt":"简介使用dingo返回数据,一开始有点懵,现在开始有点明晰了. 详细方法一用Dingo的Transformer. 其实这两种写法都可以 用Transformer()更简洁和灵活一些.因为Transformer()不仅可以利用 return $ECUser-&gt;attributesToArray(); 将属性转换成数组还可以添加和转换数据库中没有的字段,还可以用 include 做类似关联表的作用,具体看这里: Dingo Transformers 的使用(Fractal)所以这个很灵活,可以在这个类里添加更多的操作,当然只是返回array的话,还是稍显麻烦因为还得建立个文件. 补充:Dingo返回数据几种形式: Responding With An Array 响应一个数组return $this-&gt;response-&gt;array($user-&gt;toArray()); Responding With A Single Item 响应一个元素return $this-&gt;response-&gt;item($user, new UserTransformer); Responding With A Collection Of Items 响应一个元素集合return $this-&gt;response-&gt;collection($users, new UserTransformer); Responding With Paginated Items 分页响应return $this-&gt;response-&gt;paginator($users, new UserTransformer); 更多看这里……..","text":"简介使用dingo返回数据,一开始有点懵,现在开始有点明晰了. 详细方法一用Dingo的Transformer. 其实这两种写法都可以 用Transformer()更简洁和灵活一些.因为Transformer()不仅可以利用 return $ECUser-&gt;attributesToArray(); 将属性转换成数组还可以添加和转换数据库中没有的字段,还可以用 include 做类似关联表的作用,具体看这里: Dingo Transformers 的使用(Fractal)所以这个很灵活,可以在这个类里添加更多的操作,当然只是返回array的话,还是稍显麻烦因为还得建立个文件. 补充:Dingo返回数据几种形式: Responding With An Array 响应一个数组return $this-&gt;response-&gt;array($user-&gt;toArray()); Responding With A Single Item 响应一个元素return $this-&gt;response-&gt;item($user, new UserTransformer); Responding With A Collection Of Items 响应一个元素集合return $this-&gt;response-&gt;collection($users, new UserTransformer); Responding With Paginated Items 分页响应return $this-&gt;response-&gt;paginator($users, new UserTransformer); 更多看这里…….. 123456$cat = Category::where([[&#x27;parent_id&#x27;, $cid], [&#x27;is_show&#x27;, 1]])-&gt;select(&#x27;cat_id&#x27;, &#x27;cat_name&#x27;, &#x27;parent_id&#x27;, &#x27;style&#x27;)-&gt;orderBy(&#x27;sort_order&#x27;)-&gt;get();//用dingo的response就是省了加json头这个步骤了//看来不仅如此啊 加上返回的是一个数组 data[&#123;取出的数据&#125;] 如果不用就返回&#123;取出的数据&#125;return $this-&gt;response-&gt;collection($cat, new CategoryTransformer()); 方法二直接用array开发是更快一些,因为不用去建立文件.这里是利用的Dingo的reponse并不是laravel的,所以要看清 123// 这里返回一定要是toArray()$wallet = ECUser::where(&#x27;user_id&#x27;,$id)-&gt;select(&#x27;user_money&#x27;,&#x27;pay_points&#x27;)-&gt;first()-&gt;toArray();return $this-&gt;response-&gt;array($wallet); 方法三完全用laravel来返回 json, 不用插件来做. 12345$wallet = ECUser::where(&#x27;user_id&#x27;,$id)-&gt;select(&#x27;user_money&#x27;,&#x27;pay_points&#x27;)-&gt;first()-&gt;toArray();//上面那个用的是dingo的response和下面这个不一样,下面的是laravel的//这两个是有区别的 dingo的只有array()没有json, laravel的正好相反,有json()没有array() 但他们的结果是一样的return response()-&gt;json($wallet);","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"},{"name":"dingo","slug":"dingo","permalink":"http://elickzhao.github.io/tags/dingo/"}]},{"title":"Dingo Transformers 的使用(Fractal)","slug":"Dingo Transformers 的使用(Fractal)","date":"2016-12-18T14:47:45.000Z","updated":"2021-09-09T16:34:44.882Z","comments":true,"path":"2016/12/Dingo Transformers 的使用(Fractal)/","link":"","permalink":"http://elickzhao.github.io/2016/12/Dingo%20Transformers%20%E7%9A%84%E4%BD%BF%E7%94%A8(Fractal)/","excerpt":"","text":"Post 123456789101112131415public function index($postId)&#123; $post = $this-&gt;postRepository-&gt;find($postId); if (! $post) &#123; return $this-&gt;response-&gt;errorNotFound(); &#125; // 研究一下cursor，这里应该无限下拉 $comments = $this-&gt;postCommentRepository -&gt;where([&#x27;post_id&#x27; =&gt; $postId]) -&gt;paginate(); return $this-&gt;response-&gt;paginator($comments, new PostCommentTransformer());&#125; 这里主要需要说明的是, include的用法. include 的作用是,把附加信息带上.比如你要查询post的评论.你只需要 http://jwt.cc/api/posts?include=user 带上个参数就可以了.而不需要多加个路由. 这个参数不是随便起的,必须先定义.这个方便是方便,不过还是有点疑问.就是缓存需要怎么做呢.所以这次追求速度就把这个方法舍弃了还有就是带参数那个不知道怎么请求 public function includeComments(Post $post, ParamBag $params = null) 补充:最近又看了一遍,又有了更全面的认识.他这里做到的表关联,其实还是用的laravel表关联. $post-&gt;user其实就是表关联方法,就在model里.经过测试 include 必须是关联表,因为我用 return 返回原表数据格式报错了.看来一个表只能一种转换格式,不能有多个格式,这是问题啊.比如我一个页面有图片字段,另一个页面没有.就不能通过多个格式返回来操作,只能是舍弃多的那个字段,不过要是区别很大的话就还是比较麻烦. PostTransformers 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace ApiDemo\\Transformers;use ApiDemo\\Models\\Post;use League\\Fractal\\TransformerAbstract;class PostTransformer extends TransformerAbstract&#123; // 在这里定义 include protected $availableIncludes = [&#x27;user&#x27;, &#x27;comments&#x27;]; public function transform(Post $post) &#123; return $post-&gt;attributesToArray(); &#125; //请求方式 //http://jwt.cc/api/posts?include=user //返回结果,就是把user信息添加到结果里了// &#123;// &quot;data&quot;: [// &#123;// &quot;id&quot;: 1,// &quot;user_id&quot;: 1,// &quot;title&quot;: &quot;测试个标题&quot;,// &quot;content&quot;: &quot;简单内容测试&quot;,// &quot;created_at&quot;: &quot;2016-10-20 08:57:09&quot;,// &quot;user&quot;: &#123;// &quot;data&quot;: &#123;// &quot;id&quot;: 1,// &quot;email&quot;: &quot;xwiwi@tom.com&quot;,// &quot;name&quot;: &quot;elick&quot;,// &quot;avatar&quot;: null,// &quot;created_at&quot;: &quot;2016-10-20 08:48:10&quot;,// &quot;updated_at&quot;: &quot;2016-10-20 08:48:10&quot;,// &quot;deleted_at&quot;: null// &#125;// &#125;// &#125;, ...... public function includeUser(Post $post) &#123; // 这句就是model实例,其中的user方法. 看下面post的model return $this-&gt;item($post-&gt;user, new UserTransformer()); &#125; // 带参数这个还不不对,如何用url传参还没弄明白 public function includeComments(Post $post, ParamBag $params = null) &#123; $limit = 10; if ($params) &#123; $limit = (array) $params-&gt;get(&#x27;limit&#x27;); $limit = (int) current($limit); &#125; $comments = $post-&gt;comments()-&gt;limit($limit)-&gt;get(); $total = $post-&gt;comments()-&gt;count(); return $this-&gt;collection($comments, new PostCommentTransformer())-&gt;setMeta([&#x27;total&#x27; =&gt; $total]); &#125;&#125; Post 123456789101112131415161718192021namespace ApiDemo\\Models;use Illuminate\\Database\\Eloquent\\SoftDeletes;class Post extends BaseModel&#123; use SoftDeletes; protected $casts = [&#x27;extra&#x27; =&gt; &#x27;array&#x27;]; public function user() &#123; return $this-&gt;belongsTo(&#x27;ApiDemo\\Models\\User&#x27;); &#125; public function comments() &#123; return $this-&gt;hasMany(&#x27;ApiDemo\\Models\\PostComment&#x27;); &#125;&#125; 官方文档Github说明","categories":[],"tags":[{"name":"laravel dingo","slug":"laravel-dingo","permalink":"http://elickzhao.github.io/tags/laravel-dingo/"}]},{"title":"vue2 组件传递数据 props一些小改变","slug":"vue2 组件传递数据 props一些小改变","date":"2016-12-17T14:15:52.000Z","updated":"2021-09-09T16:34:45.447Z","comments":true,"path":"2016/12/vue2 组件传递数据 props一些小改变/","link":"","permalink":"http://elickzhao.github.io/2016/12/vue2%20%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%20props%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%94%B9%E5%8F%98/","excerpt":"","text":"vue 和 vue2 在 props 使用上面有些不同,在 vue2 里,模版传递过去的值,必须在 html 标签里,否则不显示.而vue使用时没有这个限制.还有就是 &lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt; 必须用双引号,单引号可能会出现问题.再有就是 这个表示的是传递一个字符串,如果要传vue内data数据,必须绑定 &lt;pic-list v-bind:items=&quot;items&quot;&gt;&lt;/pic-list&gt;,这样才可以传递其他类型的数据. 例子","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"cooking 简介 安装与使用","slug":"cooking 简介 安装与使用","date":"2016-12-15T14:56:11.000Z","updated":"2021-09-09T16:34:45.130Z","comments":true,"path":"2016/12/cooking 简介 安装与使用/","link":"","permalink":"http://elickzhao.github.io/2016/12/cooking%20%E7%AE%80%E4%BB%8B%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"cooking 更易上手的前端构建工具 cooking可以简单的配置一个webpace,而且中文文档很详细,的确是比配置webpace更简单.呵呵,接触构建工具比较晚. 发现一个比一个容易,gulp,webpace,cooking.新东西就是好啊. 简单安装首先确保是在 NPM 3+, Node 4+, Python 2.7+ 环境下运行 第一步：安装 cooking 命令行工具 npm i cooking-cli -g 第二步：使用创建项目 cooking create my-project vue 第三步：开始开发 cd my-project &amp;&amp; cooking watch 后续：打包、测试等 cooking build # or cooking run test cooking-clig 升级后真是好多了,不仅配置简单了,而且你缺什么都会有提示,所以按着提示走,很快就能建立个项目 官方文档用 cooking 搭建一个简单又优雅的 Vue 项目开发环境 (入门篇)Github仓库","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"vue + webpack 学习简介","slug":"vue + webpack 学习简介","date":"2016-12-14T15:34:24.000Z","updated":"2021-09-09T16:34:45.424Z","comments":true,"path":"2016/12/vue + webpack 学习简介/","link":"","permalink":"http://elickzhao.github.io/2016/12/vue%20+%20webpack%20%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一些经验自动刷新问题:用 vue-cli 建立的vue项目,配合 webpack 测试时, webpack 可以自动更新浏览器输出结果,但是 vue.js 的数据修改,是不会显示在浏览器中的,必须手动刷新才行.比如下面例子 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125; hi 你好&lt;/h1&gt; &lt;!-- 在这里修改就会立马显示 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; // note: changing this line won&#x27;t causes changes // with hot-reload because the reloaded component // preserves its current state and we are modifying // its initial state. msg: &#x27;Hello World! hi 你好&#x27; //修改这里浏览器不会自动刷新 &#125; &#125;&#125;&lt;/script&gt; Vue.js + webpack 项目实践Vue.js——60分钟webpack项目模板快速入门一小时包教会 —— webpack 入门指南","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://elickzhao.github.io/tags/webpack/"}]},{"title":"js中的 ~ 运算符","slug":"js中的 ~ 运算符","date":"2016-12-11T14:31:54.000Z","updated":"2021-09-09T16:34:45.216Z","comments":true,"path":"2016/12/js中的 ~ 运算符/","link":"","permalink":"http://elickzhao.github.io/2016/12/js%E4%B8%AD%E7%9A%84%20~%20%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"今天遇到这个 !~id.indexOf(&#39;category-detail&#39;) 以前没碰到过,不是很理解.后来一查明白了,这是位移运算符. 运算符就是完成操作的一系列符号，它有七类：赋值运算符 =,+=,-=,*=,/=,%=,&lt;&lt;=,&gt;&gt;=,|=,&amp;=、算术运算符 +,-,*,/,++,--,%、比较运算符 &gt;,&lt;,&lt;=,&gt;=,==,===,!=,!==、逻辑运算符 ||,&amp;&amp;,!、条件运算 ?:、位移运算符 |,&amp;,&lt;&lt;,&gt;&gt;,~,^字符串运算符 +。 看下面例子更容易理解些,就不用多解释了","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"Windows 系统下设置Nodejs NPM全局路径","slug":"Windows 系统下设置Nodejs NPM全局路径","date":"2016-12-10T14:11:45.000Z","updated":"2021-09-09T16:34:45.068Z","comments":true,"path":"2016/12/Windows 系统下设置Nodejs NPM全局路径/","link":"","permalink":"http://elickzhao.github.io/2016/12/Windows%20%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%AE%BE%E7%BD%AENodejs%20NPM%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84/","excerpt":"","text":"前言我因为手动安装npm造成系统里存在两个npm,而nodejs自带npm全局包位置不是很喜欢,所以手动改一下.下面是文章里写的办法,我用命令可以改,不知道他为啥非得改文件. 第二次安装这次安装也出现了下面文章说的使用命令安装不上的问题,通过命令查看配置文件 npm config ls -l 原来是 C:\\Program Files 这个空格的问题.使用命令后,用户配置文件C:\\Users\\elick\\.npmrc里面记录的就是C:\\Program没有后面的目录了.所以我直接改了用户配置文件,而没想下面文章写的改写全局配置.我安装的路径C:\\Program Files\\nodejs 这个路径里node_modules就是放npm的默认位置,而且全局的命令也在这个目录下,所以更新npm就直接替换了.所以想来这个应该就是默认配置目录 简单说明查看配置命令npm config ls -l Windows下的Nodejs npm路径是appdata，很不爽，想改回来，但是在cmd下执行以下命令也无效 npm config set cache “C:\\Program Files\\nodejs\\node_cache” npm config set prefix “C:\\Program Files\\nodejs” 最后在nodejs的安装目录中找到node_modules\\npm.npmrc文件 修改如下即可： prefix = D:\\nodejs\\node_globalcache = D:\\nodejs\\node_global 参考文档Windows 系统下设置Nodejs NPM全局路径","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"}]},{"title":"laravel 一些经验","slug":"laravel 一些经验","date":"2016-12-09T13:06:18.000Z","updated":"2021-09-09T16:34:45.244Z","comments":true,"path":"2016/12/laravel 一些经验/","link":"","permalink":"http://elickzhao.github.io/2016/12/laravel%20%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C/","excerpt":"Route::auth(); 5.2新加的用于生成auth路由 Auth::guard($guard) 试图从本地缓存中获取保护 官方直译是这么写的 但还是不明白啥意思 而且这也是5.2新加的有点懂这个guard了 主要用这个机制应对同一应用不同登录验证 比如前台用户登录和后台管理员登录 就可以放在两个表里然后配置不同的guard 5.2和5.1的Auth部分变化很大,两个config/auth.php配置就有很大区别 5.2把单独Auth/Guard 类 拆成了三个,SessionGuard和TokenGuard,GuardHelpers.GuardHelpers主要是共有方法,另外两个是根据不同驱动,也就是登录信息保存方法.同时也就是根据pc和移动的登录验证分成了两个类. laravel是区分大小写的,即使在windows下如果url路径写错(大小写不一致),也会造成找不到页面错误 TaskRepository 分担查询数据库内容的工作 其实放到model也可以 不过这样解耦 以后方便改吧 1234567RouteServiceProvider --&gt; $router-&gt;model(&#x27;task&#x27;,&#x27;App\\Task&#x27;); #路由绑定模型 还得需要前边 路由的配合Route::delete(&#x27;tasks/&#123;task&#125;&#x27;,&#x27;TaskController@destroy&#x27;); #再说明一次 task是指第一个参数 也就是起得名字AuthServiceProvider --&gt; protected $policies = [ &#x27;App\\Model&#x27; =&gt; &#x27;App\\Policies\\ModelPolicy&#x27;, &#x27;App\\Task&#x27; =&gt; &#x27;App\\Policies\\TaskPolicy&#x27;, ]; 关联策略的 策略是用于检查是否有权限进行这个操作 1234public function destroy(User $user, Task $task)&#123; return $user-&gt;id === $task-&gt;user_id;&#125; 1$this-&gt;authorize(&#x27;destroy&#x27;,$task); 调用策略验证 同名功能 其实可以不用第一个参数 默认策略必须在AuthServiceProvider这个支持者里进行设定才能应用 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\Providers;use App\\Post;use App\\Policies\\PostPolicy;use Illuminate\\Contracts\\Auth\\Access\\Gate as GateContract;use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;class AuthServiceProvider extends ServiceProvider&#123; /** * The policy mappings for the application. *应用策略映射 * @var array */ protected $policies = [ &#x27;App\\Model&#x27; =&gt; &#x27;App\\Policies\\ModelPolicy&#x27;, //放在这里直接映射了 下面就不用在boot里挨个写了 那样太凌乱了 Post::class=&gt;PostPolicy::class, ]; /** * Register any application authentication / authorization services. * * @param \\Illuminate\\Contracts\\Auth\\Access\\Gate $gate * @return void */ public function boot(GateContract $gate) &#123; parent::registerPolicies($gate); //定义权限 $gate-&gt;define(&#x27;update-post&#x27;,function($user,$post)&#123; return $user-&gt;id === $post-&gt;user_id; &#125;); //也可以这么写 //$gate-&gt;define(&#x27;update-post&#x27;, &#x27;PostPolicy@update&#x27;); &#125;","text":"Route::auth(); 5.2新加的用于生成auth路由 Auth::guard($guard) 试图从本地缓存中获取保护 官方直译是这么写的 但还是不明白啥意思 而且这也是5.2新加的有点懂这个guard了 主要用这个机制应对同一应用不同登录验证 比如前台用户登录和后台管理员登录 就可以放在两个表里然后配置不同的guard 5.2和5.1的Auth部分变化很大,两个config/auth.php配置就有很大区别 5.2把单独Auth/Guard 类 拆成了三个,SessionGuard和TokenGuard,GuardHelpers.GuardHelpers主要是共有方法,另外两个是根据不同驱动,也就是登录信息保存方法.同时也就是根据pc和移动的登录验证分成了两个类. laravel是区分大小写的,即使在windows下如果url路径写错(大小写不一致),也会造成找不到页面错误 TaskRepository 分担查询数据库内容的工作 其实放到model也可以 不过这样解耦 以后方便改吧 1234567RouteServiceProvider --&gt; $router-&gt;model(&#x27;task&#x27;,&#x27;App\\Task&#x27;); #路由绑定模型 还得需要前边 路由的配合Route::delete(&#x27;tasks/&#123;task&#125;&#x27;,&#x27;TaskController@destroy&#x27;); #再说明一次 task是指第一个参数 也就是起得名字AuthServiceProvider --&gt; protected $policies = [ &#x27;App\\Model&#x27; =&gt; &#x27;App\\Policies\\ModelPolicy&#x27;, &#x27;App\\Task&#x27; =&gt; &#x27;App\\Policies\\TaskPolicy&#x27;, ]; 关联策略的 策略是用于检查是否有权限进行这个操作 1234public function destroy(User $user, Task $task)&#123; return $user-&gt;id === $task-&gt;user_id;&#125; 1$this-&gt;authorize(&#x27;destroy&#x27;,$task); 调用策略验证 同名功能 其实可以不用第一个参数 默认策略必须在AuthServiceProvider这个支持者里进行设定才能应用 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\Providers;use App\\Post;use App\\Policies\\PostPolicy;use Illuminate\\Contracts\\Auth\\Access\\Gate as GateContract;use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;class AuthServiceProvider extends ServiceProvider&#123; /** * The policy mappings for the application. *应用策略映射 * @var array */ protected $policies = [ &#x27;App\\Model&#x27; =&gt; &#x27;App\\Policies\\ModelPolicy&#x27;, //放在这里直接映射了 下面就不用在boot里挨个写了 那样太凌乱了 Post::class=&gt;PostPolicy::class, ]; /** * Register any application authentication / authorization services. * * @param \\Illuminate\\Contracts\\Auth\\Access\\Gate $gate * @return void */ public function boot(GateContract $gate) &#123; parent::registerPolicies($gate); //定义权限 $gate-&gt;define(&#x27;update-post&#x27;,function($user,$post)&#123; return $user-&gt;id === $post-&gt;user_id; &#125;); //也可以这么写 //$gate-&gt;define(&#x27;update-post&#x27;, &#x27;PostPolicy@update&#x27;); &#125; 如果要指定一个表seed迁移的话命令这么写如果是新添加的表增加内容 一定要用这个–class 要不有可能无法添加进去内容artisan db:seed --class=RoleTableSeeder一定要加 –class 要不无法添加的数据库内 工厂模式也很简单 只要在工厂文件里ModelFactory不断定义要迁移的表就可以了 然后在seed文件里就可以使用factory(App\\Models\\Role::class,10)-&gt;create();了 Fnaker常用表详细地址 12345678910&#x27;title&#x27; =&gt; $faker-&gt;text(5), //最大为5的随机字母&#x27;content&#x27; =&gt; $faker-&gt;realText(), //默认为200的完整意义的话&#x27;desc&#x27; =&gt; $faker-&gt;realText(10), //10就是10个字符了 很难有完整意义了&#x27;user_id&#x27; =&gt; $faker-&gt;numberBetween(1,4), //限定最小最大值的随机数字&#x27;status&#x27; =&gt; $faker-&gt;numberBetween(0,1)&#x27;name&#x27; =&gt; $faker-&gt;country //国家名&#x27;name&#x27; =&gt; $faker-&gt;name, //人名&#x27;email&#x27; =&gt; $faker-&gt;email, //电子邮件&#x27;content&#x27; =&gt; &#x27;comment &#x27;.$faker-&gt;randomDigitNotNull, //个位数 没有空 随机&#x27;item_type&#x27; =&gt; &#x27;App\\Model\\\\&#x27;.$faker-&gt;randomElement([&#x27;Post&#x27;,&#x27;Video&#x27;]) //限定元素 随机","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"vue-admin 启动服务器测试报错 require not define 解决","slug":"vue-admin 启动服务器测试报错 require not define 解决","date":"2016-12-05T14:05:53.000Z","updated":"2021-09-09T16:34:45.434Z","comments":true,"path":"2016/12/vue-admin 启动服务器测试报错 require not define 解决/","link":"","permalink":"http://elickzhao.github.io/2016/12/vue-admin%20%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%8B%E8%AF%95%E6%8A%A5%E9%94%99%20require%20not%20define%20%E8%A7%A3%E5%86%B3/","excerpt":"","text":"原因就是chart.js需要Chart.bundle.js支持. 不过 vue-admin 把chart.js设置成不解析依赖的了,所以就会报错.这个配置就在 79 行. webpace.base.conf.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var path = require(&#x27;path&#x27;)var config = require(&#x27;../config&#x27;)var utils = require(&#x27;./utils&#x27;)var projectRoot = path.resolve(__dirname, &#x27;../&#x27;)module.exports = &#123; entry: &#123; app: &#x27;./src/main.js&#x27; &#125;, output: &#123; path: config.build.assetsRoot, publicPath: config.build.assetsPublicPath, filename: &#x27;[name].js&#x27; &#125;, resolve: &#123; extensions: [&#x27;&#x27;, &#x27;.js&#x27;, &#x27;.vue&#x27;], fallback: [path.join(__dirname, &#x27;../node_modules&#x27;)], alias: &#123; &#x27;src&#x27;: path.resolve(__dirname, &#x27;../src&#x27;), &#x27;assets&#x27;: path.resolve(__dirname, &#x27;../src/assets&#x27;), &#x27;components&#x27;: path.resolve(__dirname, &#x27;../src/components&#x27;) &#125; &#125;, resolveLoader: &#123; fallback: [path.join(__dirname, &#x27;../node_modules&#x27;)] &#125;, module: &#123; preLoaders: [ &#123; test: /\\.vue$/, loader: &#x27;eslint&#x27;, include: projectRoot, exclude: /node_modules/ &#125;, &#123; test: /\\.js$/, loader: &#x27;eslint&#x27;, include: projectRoot, exclude: /node_modules/ &#125; ], loaders: [ &#123; test: /\\.vue$/, loader: &#x27;vue&#x27; &#125;, &#123; test: /\\.js$/, loader: &#x27;babel&#x27;, include: projectRoot, // /node_modules\\/(?!vue-bulma-.*)/ exclude: new RegExp(`node_modules\\\\$&#123;path.sep&#125;\\(\\?\\!vue-bulma-.*\\)`) &#125;, &#123; test: /\\.json$/, loader: &#x27;json&#x27; &#125;, &#123; test: /\\.html$/, loader: &#x27;vue-html&#x27; &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &#x27;url&#x27;, query: &#123; limit: 10000, name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;) &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &#x27;url&#x27;, query: &#123; limit: 10000, name: utils.assetsPath(&#x27;fonts/[name].[hash:7].[ext]&#x27;) &#125; &#125; ], //忽略已知文件解析 noParse: [ // /chart\\.js/, //我去这个真的好使了,看这个插件还是有依赖的,所以不能忽略 /handsontable\\.(full\\.)?js/, /plotly\\.js/ ], &#125;, eslint: &#123; formatter: require(&#x27;eslint-friendly-formatter&#x27;) &#125;, vue: &#123; loaders: utils.cssLoaders() &#125;&#125; 参考文档Uncaught ReferenceError : require is not defined - Chart.js","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"php 类(class)的趣味理解","slug":"php 类(class)的趣味理解","date":"2016-12-03T14:43:22.000Z","updated":"2021-09-09T16:34:45.363Z","comments":true,"path":"2016/12/php 类(class)的趣味理解/","link":"","permalink":"http://elickzhao.github.io/2016/12/php%20%E7%B1%BB(class)%E7%9A%84%E8%B6%A3%E5%91%B3%E7%90%86%E8%A7%A3/","excerpt":"","text":"类是什么类是抽象的一个定义,只是定义不能用.class.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php //枪的类class gun&#123; // 弹匣不同的枪有不同弹匣和装弹数量 protected $magazine =&#x27;&#x27;; //初始化弹夹,也就是给抢上弹夹 public function __construct(int $magazine=0) &#123; $this-&gt;magazine = $magazine; &#125; //开火,单发点射.消耗弹夹子弹量. public function fire()&#123; $this-&gt;magazine--; &#125; public function getMagazine()&#123; return $this-&gt;magazine; &#125;&#125;&lt;!--more--&gt;//游戏开始 先买一把AWP//echo &#x27;I am AWP&#x27;; //有趣带 , 的 echo 前面不能有 echo 否则不显示$AWP = new gun(10);echo &quot;Use AWP\\n&quot;,$AWP-&gt;getMagazine(),&quot;\\n&quot;;$AWP-&gt;fire();echo $AWP-&gt;getMagazine(),&quot;\\n&quot;;//再买一把AK$AK47 = new gun(30);echo &quot;Use AK\\n&quot;,$AK47-&gt;getMagazine(),&quot;\\n&quot;;$AK47-&gt;fire();$AK47-&gt;fire();$AK47-&gt;fire();echo $AK47-&gt;getMagazine(),&quot;\\n&quot;; 运行命令 php class.php 得输出结果 1234567Use AWP109Use AK3027 从上面的例子可以看出,类和类的实例是一个什么样的关系.类就是一项事物的抽象总结.他是个概念,不能用于实际操作,只是定义了一类物品统一的属性与功能.上面枪类的属性就是弹夹,功能就是开火.而实例呢就是真家伙了.利用类枪类这个图纸,做出了AWP和AK.这两个是两个家伙,虽然有共同的属性和方法,但是他们的确是两个家伙,所以开火以后剩余的子弹数是不一样的.所以说为什么类是个图纸,如果两个地方用到类,属性是同一个那岂不完蛋.所以要记住,类是图纸,实例才是工具","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"}]},{"title":"一个计算php页面运行时间的函数","slug":"一个计算php页面运行时间的函数","date":"2016-12-02T14:46:40.000Z","updated":"2021-09-09T16:34:45.484Z","comments":true,"path":"2016/12/一个计算php页面运行时间的函数/","link":"","permalink":"http://elickzhao.github.io/2016/12/%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97php%E9%A1%B5%E9%9D%A2%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B0/","excerpt":"","text":"代码片段 1234567891011121314/*@ 计算php程序运行时间*/function microtime_float()&#123;list($usec, $sec) = explode(” “, microtime());return ((float)$usec + (float)$sec);&#125;//开始计时，放在头部$starttime = microtime_float();//结束计时，放在最底部$runtime = number_format((microtime_float() – $starttime), 4).&#x27;s&#x27;;//输出echo ‘RunTime:&#x27;.$runtime;","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"laravel 数据库查询优化","slug":"laravel 数据库查询优化","date":"2016-12-01T15:28:44.000Z","updated":"2021-09-09T16:34:45.255Z","comments":true,"path":"2016/12/laravel 数据库查询优化/","link":"","permalink":"http://elickzhao.github.io/2016/12/laravel%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/","excerpt":"","text":"1234567891011121314151617// 使用 Cache::remember 缓存结果是个不错的选择,能大大优化访问速度 $cid = &#x27;分类ID&#x27;; $cat = Cache::remember(&#x27;cat-&#x27; . $cid, Carbon::now()-&gt;addMinutes(60), function () use ($cid) &#123; return Category::where([[&#x27;parent_id&#x27;, $cid], [&#x27;is_show&#x27;, 1]]) -&gt;select(&#x27;cat_id&#x27;, &#x27;cat_name&#x27;, &#x27;parent_id&#x27;, &#x27;style&#x27;) -&gt;orderBy(&#x27;sort_order&#x27;) -&gt;get(); &#125;); $allCat = Cache::remember(&#x27;allCat&#x27;, Carbon::now()-&gt;addHour(3), function () &#123; return Category::where(&#x27;is_show&#x27;, 1) -&gt;select(&#x27;cat_id&#x27;, &#x27;cat_name&#x27;, &#x27;parent_id&#x27;) -&gt;orderBy(&#x27;sort_order&#x27;) -&gt;get() -&gt;toArray(); &#125;); Laravel 5 性能优化技巧使用 OpCache 提升 PHP 5.5+ 程序性能大数据量高并发的数据库优化使用 Laravel 的服务容器来优化读写数据库中的 optionsLaravel大量数据库查询导致php进程内存耗尽","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"Nginxconflicting server name  0.0.0.080, ignored","slug":"Nginxconflicting server name  0.0.0.080, ignored","date":"2016-11-29T15:13:56.000Z","updated":"2021-09-09T16:34:44.983Z","comments":true,"path":"2016/11/Nginxconflicting server name  0.0.0.080, ignored/","link":"","permalink":"http://elickzhao.github.io/2016/11/Nginxconflicting%20server%20name%20%200.0.0.080,%20ignored/","excerpt":"","text":"Nginx:conflicting server name * 0.0.0.0:80, ignored在编写了nginx配置文件后，重启nginx时出现如下警告: 12345[jh@VM_84_179_centos conf.d]$ sudo /etc/init.d/nginx restartnginx: [warn] conflicting server name &quot;blog.jianghang.name&quot; on 0.0.0.0:80, ignoredStopping nginx: [ OK ]Starting nginx: nginx: [warn] conflicting server name &quot;blog.jianghang.name&quot; on 0.0.0.0:80, ignored [ OK ] 这一般是由于技术员的粗心造成的。原因是blog.jianghang.name这个域名出现了两次甚至多次，把同一个域名解析到了不同的目录。一般将配置文件单独分离出来容易出现这个错误。接下来就是解决办法：1.查询哪些文件里面包含了 blog.jianghang.name字段 。使用grep命令，该命令实例如下： 1sudo grep -r blog.jianghang.name /etc/nginx/conf.d/ 参数 -r 是指明确要求搜索子目录，此处的目录就是/etc/nginx/conf.d/ ，因为我知道配置文件都是在这个目录下，所以用了 -r 参数。如果不知道具体目录，可以用 * 代替，其实就是正则表达式啦。这里不细讲。找到了出现 blog.jianghang.name 的文件之后，就将设置不正确的地方该正确吧。 记住一个域名只能有一个对应的目录，一个目录可以有多个对应的域名。","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}]},{"title":"laravel 修改用户验证为MD5加密方式","slug":"laravel 修改用户验证为MD5加密方式","date":"2016-11-28T15:00:16.000Z","updated":"2021-09-09T16:34:45.247Z","comments":true,"path":"2016/11/laravel 修改用户验证为MD5加密方式/","link":"","permalink":"http://elickzhao.github.io/2016/11/laravel%20%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81%E4%B8%BAMD5%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F/","excerpt":"真是被这个搞的头都大了.绕来绕去的,到现在AUTH和GUARD倒地是如何分工的,还是不太明白.算了先说怎么弄的吧. 解决方案一 简单粗暴现在用的就是这个方法,也是很多无奈.因为用的JWT插件,一改的话得改很多,而且怎么都得动源代码,不是laravel就是JWT的 所以索性就最简单粗暴吧 Illuminate\\Auth\\EloquentUserProvider 123456789101112131415// 114行左右/** * Validate a user against the given credentials. * * @param \\Illuminate\\Contracts\\Auth\\Authenticatable $user * @param array $credentials * @return bool */public function validateCredentials(UserContract $user, array $credentials)&#123; $plain = $credentials[&#x27;password&#x27;]; //XXX 自己修改的 md5验证, 这是最快捷的方式,虽然存在隐患,以后再解决吧 return md5($plain) == $user-&gt;getAuthPassword(); //return $this-&gt;hasher-&gt;check($plain, $user-&gt;getAuthPassword());&#125;","text":"真是被这个搞的头都大了.绕来绕去的,到现在AUTH和GUARD倒地是如何分工的,还是不太明白.算了先说怎么弄的吧. 解决方案一 简单粗暴现在用的就是这个方法,也是很多无奈.因为用的JWT插件,一改的话得改很多,而且怎么都得动源代码,不是laravel就是JWT的 所以索性就最简单粗暴吧 Illuminate\\Auth\\EloquentUserProvider 123456789101112131415// 114行左右/** * Validate a user against the given credentials. * * @param \\Illuminate\\Contracts\\Auth\\Authenticatable $user * @param array $credentials * @return bool */public function validateCredentials(UserContract $user, array $credentials)&#123; $plain = $credentials[&#x27;password&#x27;]; //XXX 自己修改的 md5验证, 这是最快捷的方式,虽然存在隐患,以后再解决吧 return md5($plain) == $user-&gt;getAuthPassword(); //return $this-&gt;hasher-&gt;check($plain, $user-&gt;getAuthPassword());&#125; 解决方案二 看似高大上第二种方法就是实现 Hasher 接口,然后替换掉原来的 BcryptHasher 这个类,用自己的加密解密方式.这个方法的好处是哪天又要改回来很简单.但有个问题,这TMD不是还是得该源代码,那天要升级 lumen 还是有问题,靠. 12345678910111213141516171819202122namespace Illuminate\\Contracts\\Hashing;interface Hasher&#123; public function make($value, array $options = []); public function check($value, $hashedValue, array $options = []); public function needsRehash($hashedValue, array $options = []);&#125;//实现这个接口很简单 public function validateCredentials(UserContract $user, array $credentials) &#123; $plain = $credentials[&#x27;password&#x27;]; //return md5($plain) == $user-&gt;getAuthPassword(); //这里的 hasher 的就行了. 不过还是得改代码 return $this-&gt;hasher-&gt;check($plain, $user-&gt;getAuthPassword()); &#125; 解决方案三 完美解决 可惜我这次用不上这个方法是自己写个服务提供者,继承于 EloquentUserProvider 然后修改 validateCredentials 方法,这样即使升级也不怕了.完美!但是我用不了,靠.现在这个系统是结合了 dingo 和 jwt. 这个验证已经扩展了 jwt 已经没法再扩展了. 而且要改会改很多地方.唉…. 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php namespace App\\Providers;use Illuminate\\Auth\\EloquentUserProvider as BaseEloquentUserProvider;use Illuminate\\Contracts\\Auth\\Authenticatable;class EloquentUserProvider extends BaseEloquentUserProvider&#123; public function __construct($model) &#123; $this-&gt;model = $model; &#125; public function validateCredentials(Authenticatable $user, array $credentials) &#123; $plain = $credentials[&#x27;password&#x27;]; $authPassword = $user-&gt;getAuthPassword(); return $authPassword == md5($plain); &#125;&#125;//---//注册自定义登录验证方式//这段代码放在 AuthServiceProvider 的 boot 里,或者 lumen 的 app.php 里Auth::extend(&#x27;custom&#x27;, function() &#123; return new EloquentUserProvider(&#x27;User&#x27;);&#125;);//----//然后修改guard就好了// config/auth.php &#x27;guards&#x27; =&gt; [ &#x27;api&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;custom&#x27;, &#x27;provider&#x27; =&gt; &#x27;users&#x27;, ], ], 后记真心被这个 Dingo 和 JWT 搞懵了, 有很多乱码七糟的配置不知道是干什么的.跳来跳去的,太复杂了.下面这个就是, 看似是扩展驱动 jwt 但实际并不是. 扩展驱动,是在 Tymon\\JWTAuth\\Providers\\LumenServiceProvider 这个里, 在注册的时候,同时自己注册了很多东西,其中就包括 guard 的扩展驱动. 至于下面那个 Dingo\\Api\\Auth\\Auth 干什么用的,还是没搞懂. 12345678//jwt //这里是注册guards &gt; api &gt; driver 下面那个并不是 有点晕. 在 AbstractServiceProvider 73行$app-&gt;register(Tymon\\JWTAuth\\Providers\\LumenServiceProvider::class);// email 或者放在 provider里面$app-&gt;register(Illuminate\\Mail\\MailServiceProvider::class);app(&#x27;Dingo\\Api\\Auth\\Auth&#x27;)-&gt;extend(&#x27;jwt&#x27;, function ($app) &#123; return new Dingo\\Api\\Auth\\Provider\\JWT($app[&#x27;Tymon\\JWTAuth\\JWTAuth&#x27;]);&#125;); 最倒霉的是,做这个时候安装了一个 debugbar, 结果不报错 不显示.. 晕死了…. 这次一点心得就是,看来md5加密被抛弃了,现在用的是下面这个很简单,而且好像也很强壮 12345678//要加密的密码$passwod = 123456;//加密password_hash($passwod, PASSWORD_DEFAULT);//解密password_verify($password, $hash) // $hash 是加密后的字符串 参考文档请问 Laravel 5 如何更改密码为 md5 加密方式？Laravel5.1自带认证系统（Auth）改变加密方式带来的思考PHP处理密码的几种方式laravel 用户认证","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"dingo和jwt插件使用及中间件问题","slug":"dingo和jwt插件使用及中间件问题","date":"2016-11-26T15:42:54.000Z","updated":"2021-09-09T16:34:45.146Z","comments":true,"path":"2016/11/dingo和jwt插件使用及中间件问题/","link":"","permalink":"http://elickzhao.github.io/2016/11/dingo%E5%92%8Cjwt%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%97%AE%E9%A2%98/","excerpt":"简介在使用的时候,对一个中间件找不到位置.头疼不已,经过一顿寻找终于搞明白了,这里记录下,因为虽然注释了,不过几天后又蒙圈了.前后台一起搞真是玩自己啊. 详情1234567891011121314151617181920212223242526272829303132333435363738//routes // 这里用的中间件 并不是app.php里注册的那个 &#x27;auth&#x27; =&gt; App\\Http\\Middleware\\Authenticate::class, // 而是dinggo的api里的middleware就是Auth. 如果用app.php那个会无法验证过期的. // 这个注册和jwt一样 都是在 LumenServiceProvider 里完成的 所以不注意会找不到 $api-&gt;group([&#x27;middleware&#x27; =&gt; &#x27;api.auth&#x27;], function ($api) &#123; // USER // my detail $api-&gt;get(&#x27;user&#x27;, [ &#x27;as&#x27; =&gt; &#x27;user.show&#x27;, &#x27;uses&#x27; =&gt; &#x27;UserController@userShow&#x27;, ]); .......------------//app $app-&gt;routeMiddleware([ &#x27;auth&#x27; =&gt; App\\Http\\Middleware\\Authenticate::class, &#x27;cors&#x27; =&gt; App\\Http\\Middleware\\Cors::class, ]);------------// Dingo\\Api\\Provider\\LumenServiceProvider $this-&gt;app-&gt;routeMiddleware([ &#x27;api.auth&#x27; =&gt; Auth::class, &#x27;api.throttle&#x27; =&gt; RateLimit::class, &#x27;api.controllers&#x27; =&gt; PrepareController::class, ]);","text":"简介在使用的时候,对一个中间件找不到位置.头疼不已,经过一顿寻找终于搞明白了,这里记录下,因为虽然注释了,不过几天后又蒙圈了.前后台一起搞真是玩自己啊. 详情1234567891011121314151617181920212223242526272829303132333435363738//routes // 这里用的中间件 并不是app.php里注册的那个 &#x27;auth&#x27; =&gt; App\\Http\\Middleware\\Authenticate::class, // 而是dinggo的api里的middleware就是Auth. 如果用app.php那个会无法验证过期的. // 这个注册和jwt一样 都是在 LumenServiceProvider 里完成的 所以不注意会找不到 $api-&gt;group([&#x27;middleware&#x27; =&gt; &#x27;api.auth&#x27;], function ($api) &#123; // USER // my detail $api-&gt;get(&#x27;user&#x27;, [ &#x27;as&#x27; =&gt; &#x27;user.show&#x27;, &#x27;uses&#x27; =&gt; &#x27;UserController@userShow&#x27;, ]); .......------------//app $app-&gt;routeMiddleware([ &#x27;auth&#x27; =&gt; App\\Http\\Middleware\\Authenticate::class, &#x27;cors&#x27; =&gt; App\\Http\\Middleware\\Cors::class, ]);------------// Dingo\\Api\\Provider\\LumenServiceProvider $this-&gt;app-&gt;routeMiddleware([ &#x27;api.auth&#x27; =&gt; Auth::class, &#x27;api.throttle&#x27; =&gt; RateLimit::class, &#x27;api.controllers&#x27; =&gt; PrepareController::class, ]); 一点小启示通过dingo和jwt使用有一点小启示.就是服务提供者会在boot()里注册一些中间件或者扩展auth的guards驱动.看代码吧,说也说不清,估计过几天又会看不懂的. app.php 1234// dingo/api$app-&gt;register(Dingo\\Api\\Provider\\LumenServiceProvider::class);//jwt $app-&gt;register(Tymon\\JWTAuth\\Providers\\LumenServiceProvider::class); dingo/api 1234567891011121314151617181920212223Dingo\\Api\\Provider;class LumenServiceProvider extends DingoServiceProvider&#123; /** * Boot the service provider. * * @return void */ public function boot() &#123; parent::boot(); $this-&gt;app-&gt;configure(&#x27;api&#x27;);.... // 这里就是注册了中间件. $this-&gt;app-&gt;routeMiddleware([ &#x27;api.auth&#x27; =&gt; Auth::class, &#x27;api.throttle&#x27; =&gt; RateLimit::class, &#x27;api.controllers&#x27; =&gt; PrepareController::class, ]); &#125; jwt 123456789101112131415161718192021222324252627class LumenServiceProvider extends AbstractServiceProvider&#123; ....&#125;//主要看 AbstractServiceProvider// 73行 这里就是扩展auth 这样在auth配置里就可以使用driver的jwt /** * Extend Laravel&#x27;s Auth. * 注册扩展jwt * @return void */ protected function extendAuthGuard() &#123; $this-&gt;app[&#x27;auth&#x27;]-&gt;extend(&#x27;jwt&#x27;, function ($app, $name, array $config) &#123; $guard = new JwtGuard( $app[&#x27;tymon.jwt&#x27;], $app[&#x27;auth&#x27;]-&gt;createUserProvider($config[&#x27;provider&#x27;]), $app[&#x27;request&#x27;] ); $app-&gt;refresh(&#x27;request&#x27;, $guard, &#x27;setRequest&#x27;); return $guard; &#125;); &#125; config/auth 123456789101112131415&lt;?phpreturn [ &#x27;defaults&#x27; =&gt; [ &#x27;guard&#x27; =&gt; env(&#x27;AUTH_GUARD&#x27;, &#x27;api&#x27;), ], &#x27;guards&#x27; =&gt; [ &#x27;api&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;jwt&#x27;, //就是这个了,这就是上面注册的 &#x27;provider&#x27; =&gt; &#x27;users&#x27;, ], ],","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"JSON.parse()和JSON.stringify()","slug":"JSON.parse()和JSON.stringify()","date":"2016-11-25T14:32:11.000Z","updated":"2021-09-09T16:34:44.943Z","comments":true,"path":"2016/11/JSON.parse()和JSON.stringify()/","link":"","permalink":"http://elickzhao.github.io/2016/11/JSON.parse()%E5%92%8CJSON.stringify()/","excerpt":"","text":"parse用于从一个字符串中解析出json对象,如 var str = &#39;&#123;&quot;name&quot;:&quot;huangxiaojian&quot;,&quot;age&quot;:&quot;23&quot;&#125;&#39; 结果： 123456789JSON.parse(str)Objectage: &quot;23&quot;name: &quot;huangxiaojian&quot;__proto__: Object 注意：单引号写在{}外，每个属性名都必须用双引号，否则会抛出异常。 stringify()用于从一个对象解析出字符串，如 var a = &#123;a:1,b:2&#125; 结果： 1234JSON.stringify(a)&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&quot; 参考文档JSON.parse()和JSON.stringify() MDN JSON.parse()","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"服务器相关技术","slug":"YUM常用命令详解","date":"2016-11-20T14:32:46.000Z","updated":"2021-09-09T16:34:45.082Z","comments":true,"path":"2016/11/YUM常用命令详解/","link":"","permalink":"http://elickzhao.github.io/2016/11/YUM%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"yum是一个用于管理rpm包的后台程序，用python写成，可以非常方便的解决rpm的依赖关系。在建立好yum服务器后，yum客户端可以通过 http、ftp方式获得软件包，并使用方便的命令直接管理、更新所有的rpm包，甚至包括kernel的更新。它也可以理解为红旗环境下的apt管理工具。 以前写过一份[原]使用yum更新红旗Linux ，但其中提到的命令不是很完整，现再整理一下。 一、列举包文件 列出资源库中所有可以安装或更新的rpm包 yum list列出资源库中特定的可以安装或更新以及已经安装的rpm包 yum list perl //列出名为perl 的包yum list perl* //列出perl 开头的包列出资源库中所有可以更新的rpm包 yum list updates列出已经安装的所有的rpm包 yum list installed列出已经安装的但是不包含在资源库中的rpm包 yum list extras注:extras是repos.d中定义的资源列表名称 二、列举资源信息 列出资源库中所有可以安装或更新的rpm包的信息 yum info列出资源库中特定的可以安装或更新以及已经安装的rpm包的信息 yum info perl //列出perl 包信息yum info perl* //列出perl 开头的所有包的信息列出资源库中所有可以更新的rpm包的信息 yum info updates列出已经安装的所有的rpm包的信息 yum info installed列出已经安装的但是不包含在资源库中的rpm包的信息 yum info extras三、搜索 搜索匹配特定字符的rpm包 yum search perl //在包名称、包描述等中搜索搜索有包含特定文件名的rpm包 yum provides realplay四、管理包 安装rpm包 yum install perl //安装perl 包yum install perl* //安装perl 开头的包删除rpm包,包括与该包有倚赖性的包 yum remove perl* //会删除perl-* 所有包五、更新 检查可更新的rpm包 yum check-update更新所有的rpm包 yum update更新指定的rpm包,如更新kernel和kernel source yum update kernel kernel-source大规模的版本升级,与yum update不同的是,连旧的淘汰的包也升级 yum upgrade六、清空缓存 清除暂存中rpm包文件 yum clean packages清除暂存中rpm头文件 yum clearn headers清除暂存中旧的rpm头文件 yum clean oldheaders清除暂存中旧的rpm头文件和包文件 yum clearn或 yum clearn all七、其他 安装Livna.org rpms GPG key rpm –import http://rpm.livna.org/RPM-LIVNA-GPG-KEY检查GPG Key rpm -qa gpg-pubkey*显示Key信息 rpm -qi gpg-pubkey-a109b1ec-3f6e28d5删除Key rpm -e gpg-pubkey-a109b1ec-3f6e28d5","categories":[{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"css定位position学习","slug":"css定位position学习","date":"2016-11-19T15:05:46.000Z","updated":"2021-09-09T16:34:45.136Z","comments":true,"path":"2016/11/css定位position学习/","link":"","permalink":"http://elickzhao.github.io/2016/11/css%E5%AE%9A%E4%BD%8Dposition%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"简介 值 描述 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。 实例 额外 z-index在实际使用中,也经常遇到.虽然这个理解上没有问题,不过在实际情况中往往打不到想要的效果,不知道为什么. Z-indexZ-index可被用于将在一个元素放置于另一元素之后。Z-index上面的例子中的元素已经更改了Z-index。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"css伪类 first-child  伪元素   before","slug":"css伪类 first child  伪元素   before ","date":"2016-11-18T02:38:22.000Z","updated":"2021-09-09T16:34:45.132Z","comments":true,"path":"2016/11/css伪类 first child  伪元素   before /","link":"","permalink":"http://elickzhao.github.io/2016/11/css%E4%BC%AA%E7%B1%BB%20first%20child%20%20%E4%BC%AA%E5%85%83%E7%B4%A0%20%20%20before%20/","excerpt":"简介 在使用mui时,遇到 ul li 就会有下边框,可是又跟 border 没有关系, 只要去掉 position: relative 就可以了. 刚开始图省事就这么做了,可后面的问题多多.最后不得已翻看源码才知道,这个东西是拿伪类弄出来的.其实以前也见过,就是没仔细研究,这次遇到了,所以弄明白点了. 讲解先讲这两个,比较常见的. “:before” 伪元素可以在元素的内容前面插入新内容。“:after” 伪元素可以在元素的内容后面插入新内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*下面就是困扰我的那行代码,通过变形拉伸,露出页面底色,看上去就是绘制出一个横线.*/.mui-table-view&#123; position: relative; margin-top: 0; margin-bottom: 0; padding-left: 0; list-style: none; background-color: #fff;&#125;.mui-table-view:after&#123; position: absolute; right: 0; bottom: 0; left: 0; height: 1px; content: &#x27;&#x27;; -webkit-transform: scaleY(.5); transform: scaleY(.5); background-color: #c8c7cc;&#125;.mui-table-view:before&#123; position: absolute; top: 0; right: 0; left: 0; height: 1px; content: &#x27;&#x27;; -webkit-transform: scaleY(.5); transform: scaleY(.5); background-color: #c8c7cc;&#125;","text":"简介 在使用mui时,遇到 ul li 就会有下边框,可是又跟 border 没有关系, 只要去掉 position: relative 就可以了. 刚开始图省事就这么做了,可后面的问题多多.最后不得已翻看源码才知道,这个东西是拿伪类弄出来的.其实以前也见过,就是没仔细研究,这次遇到了,所以弄明白点了. 讲解先讲这两个,比较常见的. “:before” 伪元素可以在元素的内容前面插入新内容。“:after” 伪元素可以在元素的内容后面插入新内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*下面就是困扰我的那行代码,通过变形拉伸,露出页面底色,看上去就是绘制出一个横线.*/.mui-table-view&#123; position: relative; margin-top: 0; margin-bottom: 0; padding-left: 0; list-style: none; background-color: #fff;&#125;.mui-table-view:after&#123; position: absolute; right: 0; bottom: 0; left: 0; height: 1px; content: &#x27;&#x27;; -webkit-transform: scaleY(.5); transform: scaleY(.5); background-color: #c8c7cc;&#125;.mui-table-view:before&#123; position: absolute; top: 0; right: 0; left: 0; height: 1px; content: &#x27;&#x27;; -webkit-transform: scaleY(.5); transform: scaleY(.5); background-color: #c8c7cc;&#125; :first-child 伪类来选择元素的第一个子元素。:last-child 伪类来选择元素的最后一个子元素。:nth-last-child(3) 伪类来选择元素的倒数第三个子元素。 上面这俩很好理解,不展示例子了.关键的来了,如果又是第一个元素,又是元素之后改变如何写呢,看下面. 1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;title&gt;导航条&lt;/title&gt; &lt;style&gt; ul &#123; list-style-type: none; text-align: center; &#125; li &#123; display: inline; &#125; li:not(:last-child):after &#123; /*这里的 not 是除了最后一个以外,所有元素*/ content:&#x27; |&#x27;; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;One&lt;/li&gt; &lt;li&gt;Two&lt;/li&gt; &lt;li&gt;Three&lt;/li&gt; &lt;li&gt;Four&lt;/li&gt; &lt;li&gt;Five&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 这里是演示地址 更多的选择器,请看手册:CSS 选择器参考手册CSS 伪类 (Pseudo-classes)CSS 伪元素 (Pseudo-elements)算法组","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"在nginx下多个php版本共存 及php7 安装及出现的问题","slug":"在nginx下多个php版本共存 及php7 安装及出现的问题","date":"2016-11-15T15:19:32.000Z","updated":"2021-09-09T16:34:45.597Z","comments":true,"path":"2016/11/在nginx下多个php版本共存 及php7 安装及出现的问题/","link":"","permalink":"http://elickzhao.github.io/2016/11/%E5%9C%A8nginx%E4%B8%8B%E5%A4%9A%E4%B8%AAphp%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%20%E5%8F%8Aphp7%20%E5%AE%89%E8%A3%85%E5%8F%8A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"在nginx下多个php版本的时候,需要启动两个php-fpm,在配置时php7把当前服务的配置放在了usr/local/etc/php-fpm.d/下了,默认里面有个default,不过需要改成 www.conf 否则就会出现下面那个错误. 3.WARNING: Nothing matches the include pattern ‘/usr/local/etc/php-fpm.d/*.conf’ from /usr/local/etc/php-fpm.conf at line 125.ERROR:. No pool defined at least one pool section must be specified in config fileERROR: failed to post process the configurationERROR: FPM initialization failed solution: cp www.conf.default www.conf php.ini需要配置 1234#这里的.sock位置 需要 ps aux | grep -i mysql 命令查询pdo_mysql.default_socket=/var/lib/mysql/mysqld.sockmysql.default_socket =/var/lib/mysql/mysqld.sockmysqli.default_socket =/var/lib/mysql/mysqld.sock 否则出现下面报错SQLSTATE[HY000] [2002] No such file or directory 安装php7 主要看下面的 Linux环境PHP7.0安装 编译时出现的问题,主要会报错一些插件没有安装,主要看下面的 编译安装PHP 时遇到问题解决方法.这里每次出现的报错不会相同,主要看你的linux发行版环境而定. Linux环境Nginx安装多版本PHP编译安装PHP 时遇到问题解决方法.解决error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distributionLinux环境PHP7.0安装","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}]},{"title":"SQLSTATE[HY000] [2002] No such file or directory 报错处理","slug":"SQLSTATE[HY000] [2002] No such file or directory 报错处理","date":"2016-11-11T15:01:49.000Z","updated":"2021-09-09T16:34:45.026Z","comments":true,"path":"2016/11/SQLSTATE[HY000] [2002] No such file or directory 报错处理/","link":"","permalink":"http://elickzhao.github.io/2016/11/SQLSTATE[HY000]%20[2002]%20No%20such%20file%20or%20directory%20%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/","excerpt":"","text":"简介在装lumen时突然出现了这个错误,主要是因为多个版本php共存,新装的php7配置php.ini时,没有把*.default_socket设置上而造成无法连接数据库的问题. 解决 首先说明这个是在使用nginx时,必须使用php-fpm时出现的. 现在找到 socket 的位置. 使用命令 ps aux | grep -i mysql 看到如下结果 mysql 12388 0.0 0.2 390744 44636 pts/0 Sl 14:02 0:01 /opt/mysql/product/bin/mysqld –basedir=/opt/mysql/product –datadir=/opt/mysql/product/data –plugin-dir=/opt/mysql/product/lib/plugin –user=mysql –log-error=/opt/mysql/product/data/oracle1.err –pid-file=/opt/mysql/product/data/oracle1.pid –socket=/var/lib/mysql/mysqld.sock –port=3306 这就是位置 然后打开 php.ini 添加 /var/lib/mysql/mysqld.sock 默认为空 123// mysql.default_socket = // php7里已经没有了这个pdo_mysql.default_socket=/var/lib/mysql/mysqld.sock // 默认是空的,这个就是新添加的地址mysqli.default_socket =/var/lib/mysql/mysqld.sock 然后重启 php-fpm 就解决了. 扩展阅读 php7 以后就不实用mysql这个驱动了 而使用mysqlnd 所以你在phpinfo()里不会再看到mysql项 重启php-fpm 需要用 ps aux|grep php 命令查看 php-fpm 的 pid,然后 kill pid.这里注意啊 要是多个php-fpm一定要看配置文件位置,不要删错了. 参考文档YII2数据库操作出现类似Database Exception安装roundcube 时出现 “DSN (write): NOT OK(SQLSTATE[HY000] [2002] No such file or directory)”php7不支持mysql扩展，如何使用mysqlnd?","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"Chrome 控制台console的用法","slug":"Chrome 控制台console的用法","date":"2016-11-09T14:05:29.000Z","updated":"2021-09-09T16:34:44.879Z","comments":true,"path":"2016/11/Chrome 控制台console的用法/","link":"","permalink":"http://elickzhao.github.io/2016/11/Chrome%20%E6%8E%A7%E5%88%B6%E5%8F%B0console%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"大家都有用过各种类型的浏览器，每种浏览器都有自己的特色，本人拙见，在我用过的浏览器当中，我是最喜欢Chrome的，因为它对于调试脚本及前端设计调试都有它比其它浏览器有过之而无不及的地方。可能大家对console.log会有一定的了解，心里难免会想调试的时候用alert不就行了，干嘛还要用console.log这么一长串的字符串来替代alert输出信息呢，下面我就介绍一些调试的入门技巧，让你爱上console.log 先的简单介绍一下chrome的控制台，打开chrome浏览器，按f12就可以轻松的打开控制台","text":"大家都有用过各种类型的浏览器，每种浏览器都有自己的特色，本人拙见，在我用过的浏览器当中，我是最喜欢Chrome的，因为它对于调试脚本及前端设计调试都有它比其它浏览器有过之而无不及的地方。可能大家对console.log会有一定的了解，心里难免会想调试的时候用alert不就行了，干嘛还要用console.log这么一长串的字符串来替代alert输出信息呢，下面我就介绍一些调试的入门技巧，让你爱上console.log 先的简单介绍一下chrome的控制台，打开chrome浏览器，按f12就可以轻松的打开控制台 大家可以看到控制台里面有一首诗还有其它信息，如果想清空控制台，可以点击左上角那个来清空，当然也可以通过在控制台输入console.clear()来实现清空控制台信息。如下图所示 现在假设一个场景，如果一个数组里面有成百上千的元素，但是你想知道每个元素具体的值，这时候想想如果你用alert那将是多惨的一件事情，因为alert阻断线程运行，你不点击alert框的确定按钮下一个alert就不会出现。 下面我们用console.log来替换，感受一下它的魅力。 看了上面这张图，是不是认识到log的强大之处了，下面我们来看看console里面具体提供了哪些方法可以供我们平时调试时使用。 目前控制台方法和属性有： 1[&quot;$$&quot;, &quot;$x&quot;, &quot;dir&quot;, &quot;dirxml&quot;, &quot;keys&quot;, &quot;values&quot;, &quot;profile&quot;, &quot;profileEnd&quot;, &quot;monitorEvents&quot;, &quot;unmonitorEvents&quot;, &quot;inspect&quot;, &quot;copy&quot;, &quot;clear&quot;, &quot;getEventListeners&quot;, &quot;undebug&quot;, &quot;monitor&quot;, &quot;unmonitor&quot;, &quot;table&quot;, &quot;$0&quot;, &quot;$1&quot;, &quot;$2&quot;, &quot;$3&quot;, &quot;$4&quot;, &quot;$_&quot;] 下面我们来一一介绍一下各个方法主要的用途。 一般情况下我们用来输入信息的方法主要是用到如下四个 console.log 用于输出普通信息 console.info 用于输出提示性信息 console.error用于输出错误信息 console.warn用于输出警示信息 console.debug用于输出调试信息 用图来说话 console对象的上面5种方法，都可以使用printf风格的占位符。不过，占位符的种类比较少，只支持字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）四种。 12console.log(&quot;%d年%d月%d日&quot;,2011,3,26);console.log(&quot;圆周率是%f&quot;,3.1415926); %o占位符，可以用来查看一个对象内部情况 1234var dog = &#123;&#125;;dog.name = &quot;大毛&quot;;dog.color = &quot;黄色&quot;;console.log(&quot;%o&quot;, dog); console.dirxml用来显示网页的某个节点（node）所包含的html/xml代码12345678910111213141516171819202122232425&lt;body&gt; &lt;table id=&quot;mytable&quot;&gt; &lt;tr&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;A&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;bbb&lt;/td&gt; &lt;td&gt;aaa&lt;/td&gt; &lt;td&gt;ccc&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;111&lt;/td&gt; &lt;td&gt;333&lt;/td&gt; &lt;td&gt;222&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var mytable = document.getElementById(&#x27;mytable&#x27;); console.dirxml(mytable); &#125;&lt;/script&gt; console.group 输出一组信息的开头 console.groupEnd 结束一组输出信息 看你需求选择不同的输出方法来使用，如果上述四个方法再配合group和groupEnd方法来一起使用就可以输入各种各样的不同形式的输出信息。 哈哈，是不是觉得很神奇呀！ console.assert 对输入的表达式进行断言，只有表达式为false时，才输出相应的信息到控制台 console.count（这个方法非常实用哦）当你想统计代码被执行的次数 console.dir (这个方法是我经常使用的 可不知道比for in方便了多少) 直接将该DOM结点以DOM树的结构进行输出，可以详细查对象的方法发展等等 console.time 计时开始 console.timeEnd 计时结束（看了下面的图你瞬间就感受到它的厉害了） console.profile和console.profileEnd配合一起使用来查看CPU使用相关信息 在Profiles面板里面查看就可以看到cpu相关使用信息 console.timeLine和console.timeLineEnd配合一起记录一段时间轴 console.trace 堆栈跟踪相关的调试 上述方法只是我个人理解罢了。如果想查看具体API，可以上官方看看，具体地址为：https://developer.chrome.com/devtools/docs/console-api 下面介绍一下控制台的一些快捷键 方向键盘的上下键，大家一用就知晓。比如用上键就相当于使用上次在控制台的输入符号 **$_**命令返回最近一次表达式执行的结果，功能跟按向上的方向键再回车是一样的 上面的$_需要领悟其奥义才能使用得当，而$0~$4则代表了最近5个你选择过的DOM节点。 什么意思？在页面右击选择审查元素，然后在弹出来的DOM结点树上面随便点选，这些被点过的节点会被记录下来，而$0会返回最近一次点选的DOM结点，以此类推，$1返回的是上上次点选的DOM节点，最多保存了5个，如果不够5个，则返回undefined。 Chrome 控制台中原生支持类jQuery的选择器也就是说你可以用$加上熟悉的css选择器来选择DOM节点 copy通过此命令可以将在控制台获取到的内容复制到剪贴板 （哈哈 刚刚从控制台复制的body里面的html可以任意粘贴到哪 比如记事本 是不是觉得功能很强大） keys和values 前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组 说到这，不免想起console.table方法了 monitor &amp; unmonitor monitor(function)，它接收一个函数名作为参数，比如function a,每次a被执行了，都会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。而unmonitor(function)便是用来停止这一监听。 看了这张图，应该明白了，也就是说在monitor和unmonitor中间的代码，执行的时候会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。当解除监视（也就是执行unmonitor时）就不再在控制台输出信息了。 1234567$ // 简单理解就是 document.querySelector 而已。$$ // 简单理解就是 document.querySelectorAll 而已。$_ // 是上一个表达式的值$0-$4 // 是最近5个Elements面板选中的DOM元素，待会会讲。dir // 其实就是 console.dirkeys // 取对象的键名, 返回键名组成的数组values // 去对象的值, 返回值组成的数组 下面看一下console.log的一些技巧 1、重写console.log 改变输出文字的样式 2、利用控制台输出图片 3、指定输出文字的样式 最后说一下chrome控制台一个简单的操作，如何查看页面元素，看下图就知道了 你在控制台简单操作一遍就知道了，是不是觉得很简单！","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"winSCP 不允许拖拽问题","slug":"winSCP 不允许拖拽问题","date":"2016-11-03T04:30:08.000Z","updated":"2021-09-09T16:34:45.474Z","comments":true,"path":"2016/11/winSCP 不允许拖拽问题/","link":"","permalink":"http://elickzhao.github.io/2016/11/winSCP%20%E4%B8%8D%E5%85%81%E8%AE%B8%E6%8B%96%E6%8B%BD%E9%97%AE%E9%A2%98/","excerpt":"","text":"这个问题是因为windows上没有Shell扩展.解决办法是通过临时文件,再复制到目标文件夹内. 在winSCP里的 选项-&gt;选项 打开选项界面. 找到 拖拽 这个选项菜单,进行修改就ok了.","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"手机APP页面开发框架","slug":"手机APP页面开发框架","date":"2016-10-29T15:33:58.000Z","updated":"2021-09-09T16:34:45.666Z","comments":true,"path":"2016/10/手机APP页面开发框架/","link":"","permalink":"http://elickzhao.github.io/2016/10/%E6%89%8B%E6%9C%BAAPP%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/","excerpt":"前言 这里只总结了一些只针对APP页面开发的框架.像妹子UI,ZUI,semantic-ui等一些既能开发pc端页面,也能开发APP页面的框架,就不在这里记录了. 可以看这里 不错的前台框架 总结 Semantic UI,slicy,Amaze ui 等等 总结介绍MUI: 这是个新的UI,应该是国产的.而且还有一整套解决方案.而且有个不错的IDE,所以这个以后可以试试.后台用的是自己的 HTML5+替代手机浏览器内核也就是增强版,Native.js为调用手机硬件的js插件 参考文档MUI网站官方主网站 Ionic: 这个不光是个UI库 他和 AngularJS 结合特别深.所以可以算是一套APP解决方案.其他的 UI框架都必须用jquery,Zepto.js,React 等js框架才能使用. 参考文档官方网站 Ionic开发实战ionic 安装 | 菜鸟教程 framework7: 这个刚开是因为类似IOS原生页面受到瞩目,而且速度很快.现在也支持安卓,不过貌似不是那么特别好. 参考文档官方网站 Mint UI: 基于 Vue.js 的移动端组件库 这个可以快速开发不过就是太简单了 不够好看官方网站","text":"前言 这里只总结了一些只针对APP页面开发的框架.像妹子UI,ZUI,semantic-ui等一些既能开发pc端页面,也能开发APP页面的框架,就不在这里记录了. 可以看这里 不错的前台框架 总结 Semantic UI,slicy,Amaze ui 等等 总结介绍MUI: 这是个新的UI,应该是国产的.而且还有一整套解决方案.而且有个不错的IDE,所以这个以后可以试试.后台用的是自己的 HTML5+替代手机浏览器内核也就是增强版,Native.js为调用手机硬件的js插件 参考文档MUI网站官方主网站 Ionic: 这个不光是个UI库 他和 AngularJS 结合特别深.所以可以算是一套APP解决方案.其他的 UI框架都必须用jquery,Zepto.js,React 等js框架才能使用. 参考文档官方网站 Ionic开发实战ionic 安装 | 菜鸟教程 framework7: 这个刚开是因为类似IOS原生页面受到瞩目,而且速度很快.现在也支持安卓,不过貌似不是那么特别好. 参考文档官方网站 Mint UI: 基于 Vue.js 的移动端组件库 这个可以快速开发不过就是太简单了 不够好看官方网站 SUI Mobile: 阿里爸爸的框架,不过更新速度很慢,而且是仿照 Framework7 来搞的,所以不如直接用 Framework7. 参考文档官方网站 FrozenUI: 这个是新了解到的框架,不过好做最近不怎么更新了.也就了解下吧 参考文档官方网站 Planeui: 看着不错,不过已经停更一年了.看来也不能跟进了. 参考文档官方网站HTML5 跨终端响应式前端界面框架 Plane UI","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"},{"name":"APP","slug":"APP","permalink":"http://elickzhao.github.io/tags/APP/"}]},{"title":"一些想看的新玩意","slug":"一些想看的新玩意","date":"2016-10-28T14:48:52.000Z","updated":"2021-09-09T16:34:45.515Z","comments":true,"path":"2016/10/一些想看的新玩意/","link":"","permalink":"http://elickzhao.github.io/2016/10/%E4%B8%80%E4%BA%9B%E6%83%B3%E7%9C%8B%E7%9A%84%E6%96%B0%E7%8E%A9%E6%84%8F/","excerpt":"","text":"swoole， C扩展实现的PHP异步并行网络通信框架，可以重新定义PHP。过去PHP只能做Web项目，现在有了Swoole。任意服务器端程序都可以用PHP来写。swoole_framework，基于swoole扩展开发的一个开发框架php-webim，基于swoole实现的Web即时聊天工具，支持websocket+http comet长链接推送，可以发送文字内容和图片workerman，类似swoole，不过是纯PHP实现的，官网有很多示例项目。底层功能比swoole少一些，但相对简单，应用层面的功能比swoole丰富。zephir，这个有点厉害，可以用近似PHP的一种中间代码写程序，然后自动转为C++，并作为扩展来运行。可以解决PHP语言密集计算性能差的问题。redis-async，基于swoole扩展写的异步redis客户端，压测起来性能跟Go语言之类的差不多 123文／skywalker（简书作者）原文链接：http://www.jianshu.com/p/bba4239c7c03著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。 hprosehttp://www.hprose.com/https://www.oschina.net/p/hprose使用HPROSE 创建服务端、客户端简明教程PHP 混合 Go 协程并发","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"待读","slug":"待读","permalink":"http://elickzhao.github.io/tags/%E5%BE%85%E8%AF%BB/"}]},{"title":"apidoc安装与使用说明","slug":"apiDoc安装与使用说明","date":"2016-10-28T14:31:25.000Z","updated":"2021-09-09T16:34:45.099Z","comments":true,"path":"2016/10/apiDoc安装与使用说明/","link":"","permalink":"http://elickzhao.github.io/2016/10/apiDoc%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"安装很简单,全局安装这样就可以使用 apidoc 的命令了npm install apidoc -g 使用 首先必须在项目根目录建立个 apidoc.json 的配置文件.里面大概这么写. 1234567&#123; &quot;name&quot;: &quot;lumen-api-demo&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;description&quot;: &quot;LUMEN API DEMO&quot;, &quot;title&quot;: &quot;lumen api demo&quot;, &quot;url&quot; : &quot;http://jwt.cc/api&quot;&#125; 使用命令生成文档文件 apidoc -i app/Http/Controllers/Api/V1 -o public/apidoc @apiSuccess (Reponse 200) &#123;json&#125; [data=&#39;&quot;&quot;&#39;] 如果有数据返回 []就是可选项在表格显示中有提示 多个版本很简单 只要把注释里的@apiVersion 0.1.0修改一下就可以了. 使用生成命令时,记得一定要在版本的上一级目录才可以.apidoc -i app/Http/Controllers/Api -o public/apidoc 这里Api目录下面有 v1和v2两个目录.还有记得修改apidoc.json里的 version 要不默认显示的还是老版本 参数解释1234567891011121314151617181920212223242526272829303132333435363738@api &#123;method&#125; path [title] 只有使用@api标注的注释块才会在解析之后生成文档，title会被解析为导航菜单(@apiGroup)下的小菜单 method可以有空格，如&#123;POST GET&#125;@apiGroup name 分组名称，被解析为导航栏菜单@apiName name 接口名称，在同一个@apiGroup下，名称相同的@api通过@apiVersion区分，否者后面@api会覆盖前面定义的@api@apiDescription text 接口描述，支持html语法@apiVersion verison 接口版本，major.minor.patch的形式@apiIgnore [hint] apidoc会忽略使用@apiIgnore标注的接口，hint为描述@apiSampleRequest url 接口测试地址以供测试，发送请求时，@api method必须为POST/GET等其中一种@apiDefine name [title] [description] 定义一个注释块(不包含@api)，配合@apiUse使用可以引入注释块 在@apiDefine内部不可以使用@apiUse@apiUse name 引入一个@apiDefine的注释块@apiParam [(group)] [&#123;type&#125;] [field=defaultValue] [description]@apiHeader [(group)] [&#123;type&#125;] [field=defaultValue] [description]@apiError [(group)] [&#123;type&#125;] field [description]@apiSuccess [(group)] [&#123;type&#125;] field [description] 用法基本类似，分别描述请求参数、头部，响应错误和成功 group表示参数的分组，type表示类型(不能有空格)，入参可以定义默认值(不能有空格)@apiParamExample [&#123;type&#125;] [title] example@apiHeaderExample [&#123;type&#125;] [title] example@apiErrorExample [&#123;type&#125;] [title] example@apiSuccessExample [&#123;type&#125;] [title] example 用法完全一致，但是type表示的是example的语言类型 example书写成什么样就会解析成什么样，所以最好是书写的时候注意格式化，(许多编辑器都有列模式，可以使用列模式快速对代码添加*号)@apiPermission name name必须独一无二，描述@api的访问权限，如admin/anyone 参考文档官方网站Web API文档生成工具apidoc","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"}]},{"title":"js中let和var定义变量的区别 const 说明","slug":"js中let和var定义变量的区别 const 说明","date":"2016-10-27T14:33:41.000Z","updated":"2021-09-09T16:34:45.211Z","comments":true,"path":"2016/10/js中let和var定义变量的区别 const 说明/","link":"","permalink":"http://elickzhao.github.io/2016/10/js%E4%B8%ADlet%E5%92%8Cvar%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%20const%20%E8%AF%B4%E6%98%8E/","excerpt":"","text":"let 和 var 是一样的用于定义,最主要的是 let 是javascript 严格模式. 主要区别如下: 作用范围不一样, var是全局的, let是局部的. 而且使用严格模式,文件开头一定要声明 ‘use strict’; 否则会报错. 还有必须先声明再使用. 在同一作用域,重复声明会报错. 参考文档深入浅出ES6（十四）：let和const在JavaScript ES6中使用let和const定义变量","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"php 里面 class 用法","slug":"php 里面 class 用法","date":"2016-10-26T14:31:24.000Z","updated":"2021-09-09T16:34:45.359Z","comments":true,"path":"2016/10/php 里面 class 用法/","link":"","permalink":"http://elickzhao.github.io/2016/10/php%20%E9%87%8C%E9%9D%A2%20class%20%E7%94%A8%E6%B3%95/","excerpt":"","text":"自 PHP 5.5 起，关键词 class 也可用于类名的解析。使用 ClassName::class 你可以获取一个字符串，包含了类 ClassName 的完全限定名称。这对使用了 命名空间 的类尤其有用。 123456789101112131415namespace App\\Http\\Controllers\\Api\\V1;use ApiDemo\\Repositories\\Contracts\\UserRepositoryContract;## 当使用命名空间时 得到的结果是类文件所在位置 ??不过这个位置现在是不对的 可能我用法错误 var_dump(ApiDemo\\Repositories\\Contracts\\UserRepositoryContract::class);//&quot;App\\Http\\Controllers\\Api\\V1\\ApiDemo\\Repositories\\Contracts\\UserRepositoryContract&quot;## 当使用命名空间时 得到的是命名空间var_dump(UserRepositoryContract::class);// &quot;ApiDemo\\Repositories\\Contracts\\UserRepositoryContract&quot;","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"}]},{"title":"php 抽象类的用法 (abstract)","slug":"php 抽象类的用法 (abstract)","date":"2016-10-25T14:31:25.000Z","updated":"2021-09-09T16:34:45.355Z","comments":true,"path":"2016/10/php 抽象类的用法 (abstract)/","link":"","permalink":"http://elickzhao.github.io/2016/10/php%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95%20(abstract)/","excerpt":"抽象类(abstract),一般用于基类,所有的公共方法都可以放在里面,抽象类是不能被实例化的,只能被继承.而且抽象方法是必须被重写的,其他可以根据需要选择.这样你可以简单只写一个抽象方法,其他方法大家都有了,省着写了. 以下是官方说法 PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。","text":"抽象类(abstract),一般用于基类,所有的公共方法都可以放在里面,抽象类是不能被实例化的,只能被继承.而且抽象方法是必须被重写的,其他可以根据需要选择.这样你可以简单只写一个抽象方法,其他方法大家都有了,省着写了. 以下是官方说法 PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 例子:抽象类 BaseRepository 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpnamespace ApiDemo\\Repositories\\Eloquent;abstract class BaseRepository&#123; protected $model; public function __construct() &#123; $this-&gt;model = app()-&gt;make($this-&gt;model()); &#125; abstract public function model(); public function paginate($limit = null) &#123; return $this-&gt;model -&gt;paginate($limit); &#125; public function where(array $data) &#123; return $this-&gt;model-&gt;where($data); &#125; public function first() &#123; return $this-&gt;model-&gt;first(); &#125; public function find($id) &#123; return $this-&gt;model-&gt;find($id); &#125; public function create(array $attributes) &#123; $model = $this-&gt;model-&gt;newInstance($attributes); $model-&gt;save(); return $model; &#125; public function update($id, array $attributes) &#123; // 感觉不太对 $model = $this-&gt;model-&gt;find($id); $model-&gt;fill($attributes)-&gt;save(); return $model; &#125; public function destroy($id) &#123; return $this-&gt;model-&gt;destroy($id); &#125;&#125; 集成类 UserRepository 1234567891011121314&lt;?phpnamespace ApiDemo\\Repositories\\Eloquent;use ApiDemo\\Repositories\\Contracts\\UserRepositoryContract;class UserRepository extends BaseRepository implements UserRepositoryContract&#123; public function model() &#123; return &#x27;ApiDemo\\Models\\User&#x27;; &#125;&#125; 从上面可以看到,只要实现抽象方法 model() 就可以了.这样指定了表,一些相同查询方法,大家都可以用了. 参考文档官方网站","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"}]},{"title":"使用composer 报错提示 Failed to decode response zlib_decode() data error","slug":"使用composer 报错提示 zlib_decode() data error","date":"2016-10-24T14:37:31.000Z","updated":"2021-09-09T16:34:45.531Z","comments":true,"path":"2016/10/使用composer 报错提示 zlib_decode() data error/","link":"","permalink":"http://elickzhao.github.io/2016/10/%E4%BD%BF%E7%94%A8composer%20%E6%8A%A5%E9%94%99%E6%8F%90%E7%A4%BA%20zlib_decode()%20data%20error/","excerpt":"","text":"12Failed to decode response: zlib_decode(): data errorRetrying with degraded mode, check https://getcomposer.org/doc/articles/troubleshooting.md#degraded-mode for more info 网上有人说这个只要使用 composer selfupdate 就可以解决. 其实并不完全对.因为我是再使用 composer selfupdate 这个时提示这个错误的.其原因是因为权限不足造成的.我再 windows 下并没有使用 cmd 而是使用自己下载的 Cmder.所以会有权限的问题.同理 linux 下如果权限不足也会出现这个错误.","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"composer","slug":"composer","permalink":"http://elickzhao.github.io/tags/composer/"}]},{"title":"(laravel插件) laravel-backup 备份插件","slug":"[laravel插件] laravel-backup 备份插件","date":"2016-10-23T14:31:25.000Z","updated":"2021-09-09T16:34:45.096Z","comments":true,"path":"2016/10/[laravel插件] laravel-backup 备份插件/","link":"","permalink":"http://elickzhao.github.io/2016/10/[laravel%E6%8F%92%E4%BB%B6]%20laravel-backup%20%E5%A4%87%E4%BB%BD%E6%8F%92%E4%BB%B6/","excerpt":"","text":"插件地址https://packagist.org/packages/spatie/laravel-backup 安装及配置简介安装文档 https://docs.spatie.be/laravel-backup/v3/installation-and-setup 被墙了 配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;?phpreturn [ &#x27;backup&#x27; =&gt; [ /* * The name of this application. You can use this name to monitor * the backups. */ //&#x27;name&#x27; =&gt; env(&#x27;APP_URL&#x27;), //这个备份时的目录名,如果是服务器上域名是不错的不过本地的话改一下比较好 &#x27;name&#x27; =&gt; &#x27;elick blog&#x27;, &#x27;source&#x27; =&gt; [ //这个强大啊 还能备份文件 &#x27;files&#x27; =&gt; [ /* * The list of directories that should be part of the backup. You can * specify individual files as well. * 这个是目录迭代器 但是当迭代node_modules时会出错 所以注销了 * 这样也就无法备份文件系统了 明天可以试试把排除放在前面看看可不可以 * 排除放在前面也不可以，但是可以挨个指定目录或文件 * 没有这个迭代还不可以 只有排除是不行的 * node_modules还是不行 里面全是链接目录一层套一层的 也不知道怎么搞的 不知道其他项目node目录是不是也这样 */ &#x27;include&#x27; =&gt; [ //base_path(), base_path(&#x27;app&#x27;), // base_path(&#x27;artisan&#x27;), //目录和单个文件都是可以的 ], // * These directories will be excluded from the backup. // * You can specify individual files as well. &#x27;exclude&#x27; =&gt; [ base_path(&#x27;vendor&#x27;), base_path(&#x27;node_modules&#x27;), storage_path(), base_path(&#x27;.git&#x27;), base_path(&#x27;.idea&#x27;), ], /* * Determines if symlinks should be followed. */ &#x27;followLinks&#x27; =&gt; false, ], /* * The names of the connections to the databases that should be part of the backup. * Currently only MySQL- and PostgreSQL-databases are supported. */ &#x27;databases&#x27; =&gt; [ &#x27;mysql&#x27;, ], ], &#x27;destination&#x27; =&gt; [ /* * The disk names on which the backups will be stored. * 保存位置在这 * storage\\app\\http---localhost */ &#x27;disks&#x27; =&gt; [ &#x27;local&#x27;, //这个配置位置在 config/filesystems.php &#x27;backup&#x27;, //这个就是我自己加的 ], ], ], &#x27;cleanup&#x27; =&gt; [ /* * The strategy that will be used to cleanup old backups. * The youngest backup will never be deleted. */ &#x27;strategy&#x27; =&gt; \\Spatie\\Backup\\Tasks\\Cleanup\\Strategies\\DefaultStrategy::class, &#x27;defaultStrategy&#x27; =&gt; [ /* * The amount of days that all backups must be kept. */ &#x27;keepAllBackupsForDays&#x27; =&gt; 7, /* * The amount of days that all daily backups must be kept. */ &#x27;keepDailyBackupsForDays&#x27; =&gt; 16, /* * The amount of weeks of which one weekly backup must be kept. */ &#x27;keepWeeklyBackupsForWeeks&#x27; =&gt; 8, /* * The amount of months of which one monthly backup must be kept. */ &#x27;keepMonthlyBackupsForMonths&#x27; =&gt; 4, /* * The amount of years of which one yearly backup must be kept. */ &#x27;keepYearlyBackupsForYears&#x27; =&gt; 2, /* * After cleaning up the backups remove the oldest backup until * this amount of megabytes has been reached. */ &#x27;deleteOldestBackupsWhenUsingMoreMegabytesThan&#x27; =&gt; 5000, ], ], /* * In this array you can specify which backups should be monitored. * If a backup does not meet the specified requirements the * UnHealthyBackupWasFound-event will be fired. */ &#x27;monitorBackups&#x27; =&gt; [ [ &#x27;name&#x27; =&gt; env(&#x27;APP_URL&#x27;), &#x27;disks&#x27; =&gt; [&#x27;local&#x27;], &#x27;newestBackupsShouldNotBeOlderThanDays&#x27; =&gt; 1, &#x27;storageUsedMayNotBeHigherThanMegabytes&#x27; =&gt; 5000, ], /* [ &#x27;name&#x27; =&gt; &#x27;name of the second app&#x27;, &#x27;disks&#x27; =&gt; [&#x27;local&#x27;, &#x27;s3&#x27;], &#x27;newestBackupsShouldNotBeOlderThanDays&#x27; =&gt; 1, &#x27;storageUsedMayNotBeHigherThanMegabytes&#x27; =&gt; 5000, ], */ ], &#x27;notifications&#x27; =&gt; [ /* * This class will be used to send all notifications. */ &#x27;handler&#x27; =&gt; Spatie\\Backup\\Notifications\\Notifier::class, /* * Here you can specify the ways you want to be notified when certain * events take place. Possible values are &quot;log&quot;, &quot;mail&quot;, &quot;slack&quot;, * &quot;pushover&quot;, and &quot;telegram&quot;. * * Slack requires the installation of the maknz/slack package. * Telegram requires the installation of the irazasyed/telegram-bot-sdk package. */ &#x27;events&#x27; =&gt; [ &#x27;whenBackupWasSuccessful&#x27; =&gt; [&#x27;log&#x27;], &#x27;whenCleanupWasSuccessful&#x27; =&gt; [&#x27;log&#x27;], &#x27;whenHealthyBackupWasFound&#x27; =&gt; [&#x27;log&#x27;], &#x27;whenBackupHasFailed&#x27; =&gt; [&#x27;log&#x27;, &#x27;mail&#x27;], &#x27;whenCleanupHasFailed&#x27; =&gt; [&#x27;log&#x27;, &#x27;mail&#x27;], &#x27;whenUnhealthyBackupWasFound&#x27; =&gt; [&#x27;log&#x27;, &#x27;mail&#x27;], ], /* * Here you can specify how emails should be sent. */ &#x27;mail&#x27; =&gt; [ &#x27;from&#x27; =&gt; &#x27;your@email.com&#x27;, &#x27;to&#x27; =&gt; &#x27;your@email.com&#x27;, ], /* * Here you can specify how messages should be sent to Slack. */ &#x27;slack&#x27; =&gt; [ &#x27;channel&#x27; =&gt; &#x27;#backups&#x27;, &#x27;username&#x27; =&gt; &#x27;Backup bot&#x27;, &#x27;icon&#x27; =&gt; &#x27;:robot:&#x27;, ], /* * Here you can specify how messages should be sent to Pushover. */ &#x27;pushover&#x27; =&gt; [ &#x27;token&#x27; =&gt; env(&#x27;PUSHOVER_APP_TOKEN&#x27;), &#x27;user&#x27; =&gt; env(&#x27;PUSHOVER_USER_KEY&#x27;), &#x27;sounds&#x27; =&gt; [ &#x27;success&#x27; =&gt; env(&#x27;PUSHOVER_SOUND_SUCCESS&#x27;, &#x27;pushover&#x27;), &#x27;error&#x27; =&gt; env(&#x27;PUSHOVER_SOUND_ERROR&#x27;, &#x27;siren&#x27;), ], ], /* * Here you can specify how messages should be sent to Telegram Bot API. */ &#x27;telegram&#x27; =&gt; [ &#x27;bot_token&#x27; =&gt; env(&#x27;TELEGRAM_BOT_TOKEN&#x27;), &#x27;chat_id&#x27; =&gt; env(&#x27;TELEGRAM_CHAT_ID&#x27;), &#x27;async_requests&#x27; =&gt; env(&#x27;TELEGRAM_ASYNC_REQUESTS&#x27;, false), &#x27;disable_web_page_preview&#x27; =&gt; env(&#x27;TELEGRAM_DISABLE_WEB_PAGE_PREVIEW&#x27;, true), ], ],];","categories":[],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"},{"name":"laravel插件","slug":"laravel插件","permalink":"http://elickzhao.github.io/tags/laravel%E6%8F%92%E4%BB%B6/"}]},{"title":"(laravel插件) Api响应格式化插件 laravel5-fractal","slug":"[laravel插件] Api响应格式化插件 laravel5-fractal","date":"2016-10-21T14:31:25.000Z","updated":"2021-09-09T16:34:45.089Z","comments":true,"path":"2016/10/[laravel插件] Api响应格式化插件 laravel5-fractal/","link":"","permalink":"http://elickzhao.github.io/2016/10/[laravel%E6%8F%92%E4%BB%B6]%20Api%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%8F%92%E4%BB%B6%20laravel5-fractal/","excerpt":"","text":"简介这个插件用到的是 Fractal,并把它与 laravel 结合.使 larvel 响应请求时有美化的格式,不用每个都去手动改写.例如,数据库里的表名往往是简称或英文.但是你返回给程序时,最好直接就能用,而不用再一次进行操作,并且可以添加没有记录在数据库里的数据. 例子12345678910111213141516171819202122232425262728293031323334353637383940414243//从数据里读出的数据$books = [ [ &#x27;id&#x27; =&gt; &#x27;1&#x27;, &#x27;title&#x27; =&gt; &#x27;Hogfather&#x27;, &#x27;yr&#x27; =&gt; &#x27;1998&#x27;, &#x27;author_name&#x27; =&gt; &#x27;Philip K Dick&#x27;, &#x27;author_email&#x27; =&gt; &#x27;philip@example.org&#x27;, ], [ &#x27;id&#x27; =&gt; &#x27;2&#x27;, &#x27;title&#x27; =&gt; &#x27;Game Of Kill Everyone&#x27;, &#x27;yr&#x27; =&gt; &#x27;2014&#x27;, &#x27;author_name&#x27; =&gt; &#x27;George R. R. Satan&#x27;, &#x27;author_email&#x27; =&gt; &#x27;george@example.org&#x27;, ]];&lt;!--more--&gt;//模版public function transform($books)&#123; return [ &#x27;id&#x27; =&gt; (int) $book[&#x27;id&#x27;], &#x27;title&#x27; =&gt; $book[&#x27;title&#x27;], &#x27;year&#x27; =&gt; (int) $book[&#x27;yr&#x27;], // 把数据库不标准的命名改成可读性强的 &#x27;author&#x27; =&gt; [ // 整理在author下 数据库是没有这个层级关系的 &#x27;name&#x27; =&gt; $book[&#x27;author_name&#x27;], &#x27;email&#x27; =&gt; $book[&#x27;author_email&#x27;], ], &#x27;links&#x27; =&gt; [ // 连接这种东西就完全没必要存在数据库里 直接组合就成了 [ &#x27;rel&#x27; =&gt; &#x27;self&#x27;, &#x27;uri&#x27; =&gt; &#x27;/books/&#x27;.$book[&#x27;id&#x27;], ] ] ];&#125;// 这样返回就好了 就是有一定格式的数据了 省着写程序了return Fractal::collection($users, new UserTransformer); 使用 首先去建立个模版,使用命令 php artisan make:transformer 这个命令会建立一个目录 App\\Transfomers\\ 把所有的模版都放在下面 紧接着修改模版到你想输出的样式 12345678public function transform($user)&#123; return [ &#x27;id&#x27; =&gt; $user-&gt;user_id, &#x27;name&#x27; =&gt; &quot;&#123;$user-&gt;user_firstname&#125; &#123;$user-&gt;user_lastname&#125;&quot;, ... ];&#125; 2.0版 你可以直接用这个命令 生成对应model的模版 php artisan make:transformer UserTransformer -m User 填写数据使用模版 12345678910111213// 单个数据使用 item$user = User::find(1);return Fractal::item($user, new UserTransformer);// 多个数据使用 collection$users = User::get(); // $users = User::paginate();return Fractal::collection($users, new UserTransformer);// 如果想用数组这么写Fractal::collection($user, new UserTransformer)-&gt;getArray(); 参考文档Cyvelnet/laravel5-fractalFractal","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"前台工具小技巧 使用别人的工具 node","slug":"前台工具小技巧 使用别人的工具 node","date":"2016-10-20T14:31:14.000Z","updated":"2021-09-09T16:34:45.551Z","comments":true,"path":"2016/10/前台工具小技巧 使用别人的工具 node/","link":"","permalink":"http://elickzhao.github.io/2016/10/%E5%89%8D%E5%8F%B0%E5%B7%A5%E5%85%B7%E5%B0%8F%E6%8A%80%E5%B7%A7%20%E4%BD%BF%E7%94%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E5%B7%A5%E5%85%B7%20node/","excerpt":"","text":"最近一直在高前端,所以难免会在Github上用别人的工具.但是现在好多高前端都用一些高大上的东西,node什么的还好说,前段用gulp,最近又开始流行webpace,真是时代潮流不好追啊.而且有些人文档写的很简略,再加上中国的网络情况,有时你弄下来却是各种的不好使.真是头疼.这里总结下别人的东西怎么用. 先 npm install 把依赖都安装好 最好先用npm install 如果有装不上的 比如该死的 node-sass 在用cnpm install 因为这个总有莫名其妙的错误,而且下载下来的包特别的大,所以能用 npm 就用 npm 再有看看package.json 这里的 scripts 下面都是可运行命令 一般情况下在用webpace的时候 会有启动服务器的命令,这样直接就查看效果了 省着自己动手. UNMET PEER DEPENDENCY 如果出现这个错误 那是有的插件依赖版本不对.所以需要手动调整package.json,如果不行那就下载这个插件新的版本吧 今天又发现个事,好像最近 build 目录不再是生成目录了. dist是生成目录. build主要用于放置build时或者dev服务器的配置文件.以后需要注意下","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"}]},{"title":"Element UI 安装时的一点小问题","slug":"Element UI 安装时的一点小问题","date":"2016-10-19T14:34:16.000Z","updated":"2021-09-09T16:34:44.902Z","comments":true,"path":"2016/10/Element UI 安装时的一点小问题/","link":"","permalink":"http://elickzhao.github.io/2016/10/Element%20UI%20%E5%AE%89%E8%A3%85%E6%97%B6%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"Element 用到了 vue-markdown-loader 使 md 文件生成网页. 但是他在 webpace 启动时 把生成的网页缓存到了. vue-markdown-loader 目录下的 .cache 目录里. 但如果是windows系统的话.有可能因为权限问题无法创建 .开头文件造成错误. 所以 自己建立一个就好了","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://elickzhao.github.io/tags/JavaScript/"}]},{"title":"Atom 编辑器配置sync-setting","slug":"Atom 编辑器配置sync-setting","date":"2016-10-18T14:49:16.000Z","updated":"2021-09-09T16:34:44.865Z","comments":true,"path":"2016/10/Atom 编辑器配置sync-setting/","link":"","permalink":"http://elickzhao.github.io/2016/10/Atom%20%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AEsync-setting/","excerpt":"sync-settings简介sync-settings是一款备份插件，可以备份ATOM的全局设置、插件、按键绑定(keymaps)、界面样式、代码片段(snippets )、 init script。这样不管走到那里使用的Atom都是自己最熟悉的那个,这样省去了很多麻烦.","text":"sync-settings简介sync-settings是一款备份插件，可以备份ATOM的全局设置、插件、按键绑定(keymaps)、界面样式、代码片段(snippets )、 init script。这样不管走到那里使用的Atom都是自己最熟悉的那个,这样省去了很多麻烦. sync-settings配置 申请生成token和gist id 申请goken Select scopes 记住一定要把gist打上勾.要不无法找到 gist 创建新的gist 登陆github，点击Gist图标(使用gist功能需要翻墙)： 创建个gist项目,这个项目是私人或公开的都可以 成功创建后将会跳转到刚刚创建的gist项目浏览页面，url处昵称后面的字符即为gist id，粘贴到sync-settings的配置处即可 设置sync-setting 测试下是否正常 在文档编辑页面,按下全局命令搜索面板(Ctrl+shift+p) 搜索sync- ,会有可选项 sync-settings:backup – 这条命令是备份当前的配置 sync-settings:restore – 这条命令是回复配置,是直接覆盖的; sync-settings:view-backup – 这条是当你执行备份后到线上查询你的备份的,也就是到你的gist code里面 sync-settings:check-backup – 这条是查询最后一次是否正常 备份成功和失败都有一条信息提醒,看图. 参考文档Atom编辑器折腾记_(12)Sync-setttings(插件-备份神器)ATOM基础教程一sync-settings配置(11)","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"},{"name":"atom","slug":"atom","permalink":"http://elickzhao.github.io/tags/atom/"},{"name":"Git","slug":"Git","permalink":"http://elickzhao.github.io/tags/Git/"}]},{"title":"箭头函数 ()=>{....}","slug":"箭头函数","date":"2016-10-17T14:27:53.000Z","updated":"2021-09-09T16:34:45.719Z","comments":true,"path":"2016/10/箭头函数/","link":"","permalink":"http://elickzhao.github.io/2016/10/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"","text":"箭头函数 这是es6新建的 就是匿名函数的简写,当然还有些区别没有细研究. 第一个参数是本身的形参 123456789101112131415config.map(nav =&gt; &#123; if (nav.groups) &#123; nav.groups.map(group =&gt; &#123; group.list.map(page =&gt; &#123; addRoute(page); &#125;); &#125;); &#125; else if (nav.children) &#123; nav.children.map(page =&gt; &#123; addRoute(page); &#125;); &#125; else &#123; addRoute(nav); &#125; &#125;); 补充:有人说这种写法是匿名函数的简写,从下面这段看的确是这样. 123456789101112131415161718let change = ()=&gt; &#123; count++; if (count &gt;= textflowArr.length) &#123; count = 0; &#125; let textFlow = textflowArr[count]; // 切换描述内容 // Switch to described content textfield.textFlow = textFlow; let tw = egret.Tween.get(textfield); tw.to(&#123;&quot;alpha&quot;: 1&#125;, 200); tw.wait(2000); tw.to(&#123;&quot;alpha&quot;: 0&#125;, 200); tw.call(change, this);&#125;;change(); 匿名函数是什么样的. 123456789101112131415161718192021222324// 匿名函数//这里可以直接添加括号这样可以立即执行(function()&#123; ....&#125;)();--------------// 也可以赋值给个变量 留着以后执行var change = (function(count)&#123; count++; alert(count);&#125;);change(1); //咦 这个跟函数也没区别了啊,虽然change是个变量,但是使用的时候,跟函数是一样的啊//函数写法function change(count)&#123; count++; alert(count);&#125;change(1); //测试如下 参考文档:箭头函数知乎提问ECMAScript 2015 简易教程JavaScript中的匿名函数及函数的闭包","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"js创建对象","slug":"js创建对象","date":"2016-10-15T15:31:45.000Z","updated":"2021-09-09T16:34:45.221Z","comments":true,"path":"2016/10/js创建对象/","link":"","permalink":"http://elickzhao.github.io/2016/10/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940function bb()&#123; alert(&#x27;bb&#x27;);&#125;var b = new bb();function cc()&#123; return 1;&#125;var dd=function()&#123; return &quot;啊打&quot;; &#125;;function ee()&#123; this.name=&quot;李小龙&quot;; this.age=&quot;30&quot;; &#125;var e = new ee();console.log(typeof(aa));console.log(typeof(bb));console.log(typeof(b));console.log(typeof(cc));console.log(cc());console.log(typeof(dd));console.log(typeof(ee));console.log(typeof(e));//结果object functionobjectfunction1functionfunctionobject Javascript进阶之路-论对象的重要性 **** js中创建对象的几种方式示例介绍JS函数与面向对象","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"js中let和var定义变量的区别","slug":"js中let和var定义变量的区别","date":"2016-10-15T13:02:46.000Z","updated":"2021-09-09T16:34:45.214Z","comments":true,"path":"2016/10/js中let和var定义变量的区别/","link":"","permalink":"http://elickzhao.github.io/2016/10/js%E4%B8%ADlet%E5%92%8Cvar%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"let 和 var 是一样的用于定义,最主要的是 let 是javascript 严格模式. 主要区别如下: 作用范围不一样, var是全局的, let是局部的. 而且使用严格模式,文件开头一定要声明 ‘use strict’; 否则会报错. 还有必须先声明再使用. 在同一作用域,重复声明会报错. 参考文档","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://elickzhao.github.io/tags/JavaScript/"}]},{"title":"vue.js 中国好教程","slug":"vue.js 中国好教程","date":"2016-10-14T14:09:29.000Z","updated":"2021-09-09T16:34:45.439Z","comments":true,"path":"2016/10/vue.js 中国好教程/","link":"","permalink":"http://elickzhao.github.io/2016/10/vue.js%20%E4%B8%AD%E5%9B%BD%E5%A5%BD%E6%95%99%E7%A8%8B/","excerpt":"","text":"Vue.js教程浅谈Vue.jsvue.js学习笔记1 – 搭建vue.js本地开发框架vuejs-learn","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"laravel 引入css和js文件","slug":"laravel 引入css和js文件","date":"2016-10-13T10:52:50.000Z","updated":"2021-09-09T16:34:45.253Z","comments":true,"path":"2016/10/laravel 引入css和js文件/","link":"","permalink":"http://elickzhao.github.io/2016/10/laravel%20%E5%BC%95%E5%85%A5css%E5%92%8Cjs%E6%96%87%E4%BB%B6/","excerpt":"","text":"前言 一般情况下是不会有问题的,类似这样 bootstrap/css/bootstrap.min.css 或者 /bootstrap/css/bootstrap.min.css,当网站使用域名的时候后者不会出错,可是当使用本地测试时,是在http://localhost/Admin/public/admin/这样一个路径,就会出现加载位置出错. 说明 解决方法有几个 (没办法只能这么写,双括号 和 hexo冲突) 1234567891011121314## .env文件加入`APP_URL`参数 在模版里读取 env(&#x27;APP_URL&#x27;)&#123;&#123; env(&#x27;APP_URL&#x27;) &#125;&#125;&quot;/libs/font-awesome/4.5.0/css/font-awesome.min.css&quot;## 使用帮助函数 `asset()` 这个应该算是比较正统做法 但有个问题不知道在域名下是否正确,我没测试过&#123;&#123; asset(&#x27;/bootstrap/css/bootstrap.min.css&#x27;) &#125;&#125;## 还有他原本的形式是这样的&#123;&#123; URL::asset(&#x27;//netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css&#x27;) &#125;&#125;## 还有个一个HtmlBuilder 这个需要安装 `composer require illuminate/html 5.*` 然后这么使用&#123;!!Html::style(&#x27;css/style.css&#x27;)!!&#125;&#123;!!Html::script(&#x27;js/script.js&#x27;)!!&#125;## 这挺好不用自己写那么一长串了,这个5.1里我有,5.2还没有整理 参考文档Laravel5如何在*.blade.php引用css/js文件laravel加载js和css等资源Laravel 5 中使用 HtmlBuilder 及 URL::asset() 引入站内或站外的 css 和 js 文件","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"解决 Gravatar 被墙导致无法显示的问题","slug":"解决 Gravatar 被墙导致无法显示的问题","date":"2016-10-12T14:59:15.000Z","updated":"2021-09-09T16:34:45.733Z","comments":true,"path":"2016/10/解决 Gravatar 被墙导致无法显示的问题/","link":"","permalink":"http://elickzhao.github.io/2016/10/%E8%A7%A3%E5%86%B3%20Gravatar%20%E8%A2%AB%E5%A2%99%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"Gravatar Gravatar是Globally Recognized Avatar的缩写,是gravatar推出的一项服务，意为“全球通用头像”。如果在Gravatar的服务器上放置了你自己的头像，那么在任何支持Gravatar的blog或者留言本上留言时，只要提供你与这个头像关联的email地址，就能够显示出你的Gravatar头像来 使用未被墙的地址 目前一共收集到 7 个 Gravatar 官方地址，其中前 4 个被墙了，所以我们使用未被墙的地址作为替代： http://www.gravatar.comhttp://0.gravatar.comhttp://1.gravatar.comhttp://2.gravatar.comhttp://gravatar.comhttp://cn.gravatar.com 使用这个就好了https://secure.gravatar.com 参考文章4 种方法解决 Gravatar 被墙导致无法显示的问题","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"webpack 零基础教程","slug":"webpace 零基础教程","date":"2016-10-11T13:43:17.000Z","updated":"2021-09-09T16:34:45.462Z","comments":true,"path":"2016/10/webpace 零基础教程/","link":"","permalink":"http://elickzhao.github.io/2016/10/webpace%20%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","excerpt":"这套教材非常好 非常适合我.Webpack傻瓜式指南（一）Webpack傻瓜指南（二）开发和部署技巧Webpack傻瓜指南（三）和React配合开发 不过有个小问题: 里面的方法不能加括号app.appendChild(sub()); 这个应当这么写 app.appendChild(sub); 这个错误原因可能是他手误了 1234567891011121314151617181920//之前//只需要 sub//这个是CommonJS风格代码function generateText()&#123; var element = document.createElement(&#x27;h2&#x27;); element.innerHTML = &quot;Hello hddddaa world&quot;; return element;&#125;module.exports = generateText();--------------------------------------------------------------------//后面// 所以需要sub()//这个是ES6风格代码export default function() &#123; var element = document.createElement(&#x27;h2&#x27;); element.innerHTML = &quot;Hello h2 world hahaha&quot;; return element;&#125;","text":"这套教材非常好 非常适合我.Webpack傻瓜式指南（一）Webpack傻瓜指南（二）开发和部署技巧Webpack傻瓜指南（三）和React配合开发 不过有个小问题: 里面的方法不能加括号app.appendChild(sub()); 这个应当这么写 app.appendChild(sub); 这个错误原因可能是他手误了 1234567891011121314151617181920//之前//只需要 sub//这个是CommonJS风格代码function generateText()&#123; var element = document.createElement(&#x27;h2&#x27;); element.innerHTML = &quot;Hello hddddaa world&quot;; return element;&#125;module.exports = generateText();--------------------------------------------------------------------//后面// 所以需要sub()//这个是ES6风格代码export default function() &#123; var element = document.createElement(&#x27;h2&#x27;); element.innerHTML = &quot;Hello h2 world hahaha&quot;; return element;&#125; 这个教程又少写了一步:在解决jquery老插件无法引入jquery的方法时 1234567891011121314151617//先得引用才行 教程里没有提这个var webpack = require(&#x27;webpack&#x27;);... plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;Hello world app&#x27; &#125;), //new webpack.HotModuleReplacementPlugin(), //这是hot的一个插件 //webpack提供一个插件 把一个全局变量插入到所有的代码中 //这个就是插入jquery到所有文件中,应对jquery老的插件不支持引用 new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot;, &quot;window.jQuery&quot;: &quot;jquery&quot; &#125;) ], 配置hot时搜索的文档 顺便说下hot 现在的感觉是同步组件修改 比如vue 不用这个插件 vue组件修改 浏览器不自动更新 这是我现在这么理解的说说Webpack七周七种前端框架二: React 之 webpack 简介 其他WebPack常用功能介绍 –&gt; 这也是个很详细的文章webpack分离css单独打包一小时包教会 —— webpack 入门指南Webpack 中文指南 –&gt;手册包涵所有方面 但不是特别详细在node中使用babel6的一些简单分享 –&gt;因为使用 babel 和 babel-preset-es2015 一直报错 import 所以查了这个","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"http://elickzhao.github.io/tags/webpack/"}]},{"title":"NPM 安装 及 安装node-sass报错问题","slug":"NPM 安装 及 安装node-sass报错问题","date":"2016-08-01T12:40:53.000Z","updated":"2021-09-09T16:34:44.980Z","comments":true,"path":"2016/08/NPM 安装 及 安装node-sass报错问题/","link":"","permalink":"http://elickzhao.github.io/2016/08/NPM%20%E5%AE%89%E8%A3%85%20%E5%8F%8A%20%E5%AE%89%E8%A3%85node-sass%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/","excerpt":"","text":"这次安装是按照网上教程来的 不过好像有点老了 下次尝试新的 就是不用clone npm的git 因为看到现在下载的node.js里的node_modules里 就有了这个目录了 也许直接执行命令就好了 下载node.js安装 如果没有git的话下载git安装 或者直接下载git://github.com/isaacs/npm.git 压缩包也可以 git clone –recursive git://github.com/isaacs/npm.git 下载NPM 在NPM目录里 执行安装 node cli.js install npm -gf (-gf 为全局安装 如果安装其他包也可以使用这个命令) NPM -v 查看版本 是否安装成功 再次安装心得npm已经是附带安装,所以不用再像上面那样手动安装npm.不过默认安装的npm默认安装模块位置在C:\\Users\\elick\\AppData\\Roaming这个下面,不像手动安装是在nodejs目录里,而且自动安装的版本也比较低.所以选择手动安装也不错.不过必须先得写在已经安装好的npm npm uninstall npm 在windows下开发真是麻烦重重,还的需要安装python,还得需要安装c++.比如说要用node-sass 就得必须用这两个. 而要开发socket.io和ionic都需要这个 第三次安装有时网上克隆下来的项目,还是有错误问题.又一次遇到了node-sass,这次用cnpm居然就可以了.所以可能上次安装的问题也是因为这个,有机会下次测试下.","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"}]},{"title":"hexo 博客小技巧","slug":"hexo 博客小技巧","date":"2016-07-31T14:32:55.000Z","updated":"2021-09-09T16:34:45.167Z","comments":true,"path":"2016/07/hexo 博客小技巧/","link":"","permalink":"http://elickzhao.github.io/2016/07/hexo%20%E5%8D%9A%E5%AE%A2%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"hexo会把所有的MD文件转换成html文件.但是这样Github的Readme就没法展现了.我用的方法是把Readme.md 前面加了_变成_Readme.md,这样hexo就不会转换了,因为hexo默认过滤掉_开头文件或文件夹,除了_post.我把Readme.md直接扔到public文件夹.这样就不会转换成html文件了,这样就能是Github有Readme了.","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"JSFiddle 改写展示标签","slug":"JSFiddle 改写展示标签","date":"2016-07-30T13:34:19.000Z","updated":"2021-09-09T16:34:44.937Z","comments":true,"path":"2016/07/JSFiddle 改写展示标签/","link":"","permalink":"http://elickzhao.github.io/2016/07/JSFiddle%20%E6%94%B9%E5%86%99%E5%B1%95%E7%A4%BA%E6%A0%87%E7%AD%BE/","excerpt":"","text":"前言JSFiddle 是一个用于前端代码展示与分享的网站,可以在这里写代码并测试,同时写完后可以用连接分享在博客里展示给大家.在国内也有个类似网站 HCODE 简单讲解 原有的标签顺序狠不好,JS文件在前显示结果在后.所以要改一下,把结果放在前面. //jsfiddle.net/elick/s03Lk51x/embedded/result,js,html,css 其实很简单,embedded/后面这个结构就是标签顺序. 参考文档CnBlogs博文demo演示技巧比较：jsfiddle完胜类似jsfiddle的网站还有哪些？","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"后台管理模版大搜集 都是前后分离的","slug":"后台管理模版大搜集 都是前后分离的","date":"2016-07-25T08:27:42.000Z","updated":"2021-09-09T16:34:45.586Z","comments":true,"path":"2016/07/后台管理模版大搜集 都是前后分离的/","link":"","permalink":"http://elickzhao.github.io/2016/07/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%A8%A1%E7%89%88%E5%A4%A7%E6%90%9C%E9%9B%86%20%E9%83%BD%E6%98%AF%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84/","excerpt":"Vue Start Kit: 一个国内搞的用 Vue+Bulma UI 开发的后台模版.不过我在本地测试时报错 已经没问题了,必须用cnpm 安装node-sass才可以.Demo地址: http://vue-kit.gismall.com/","text":"Vue Start Kit: 一个国内搞的用 Vue+Bulma UI 开发的后台模版.不过我在本地测试时报错 已经没问题了,必须用cnpm 安装node-sass才可以.Demo地址: http://vue-kit.gismall.com/ CoPilot 完全可用的后台UI 这个是利用了 - AdminLTE - BootStrap 3 - Vue.js 搭建的,功能很完备,以后有需要可以用这个试试.Demo地址: http://copilot.mistergf.io/ MaterializeTemplate 这个是google出的比较大气,而且挺炫的有3D效果 这个用Materialize UI 构建的后台模版.不过这个有个问题他好像用了墙外的文件 所以必须用chrome浏览器看才行 hubuntu-ui 这个也很好看 不过这只有一页测试. 功能没那么全. 这个也是拿Materialize UI做的Demo地址: https://720kb.github.io/hubuntu-ui/# Semantic-Admin-Template 这是个产品后的后台,但全部是静态页,可以留着自己用php活vue做成动态的. 这个用的是 Semantic UI 一个比较潮流的UI 鲜艳活泼 idewall-admin 这是laravel+vue+AdminLTE 构建的,不过好像缩放有点小问题.后面会接着测试 MaterialAdmin 这个就是个简单测试型后台.这个也是拿Materialize UI做的 触享: 这个只能供学习之用,这个用的是vue-strap 也就是替换掉jq的bootstrap. 这两个使用Ant.Design构建的.只用作学习吧.因为都很简单**react-antd-admin-master ** , www-nodejs-ant-design-web-master这俩就给Github连接了,全放在360文件夹里了,以及上面所有的 360网盘地址:https://yunpan.cn/c6KwNXGRyEW3U 访问密码: a995","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"vue 学习小例子","slug":"vue 学习小例子","date":"2016-07-25T04:04:12.000Z","updated":"2021-09-09T16:34:45.431Z","comments":true,"path":"2016/07/vue 学习小例子/","link":"","permalink":"http://elickzhao.github.io/2016/07/vue%20%E5%AD%A6%E4%B9%A0%E5%B0%8F%E4%BE%8B%E5%AD%90/","excerpt":"一些总结吧 父组件和子组件之间通信用广播: vue可以用多种方法实现组件间沟通,比如用一个属性,不过这必须用上同步 :test.sync 要不然子组件的状态父组件不知道.但是这有个问题就是不利于解耦,捆绑太紧密了不能复用了,所以还是用广播.不过还是有个小小的疑问,如果两个同名事件怎么办呢?? 按文档里说是第一个,那可能是父组件加载子组件的顺序吧我想可能是这样的,如果存在同名的话,那就得手动调整顺序,我感觉最好不要同名. v-bind:fields=”columns” 绑定解释: 有时用简写就比较懵,简单记忆下: 如果原有属性就是绑定属性到vue属性.如果不是自带属性,那就是组件自定义的.比如 :fields=&quot;columns&quot; 这里就是一个. fields 子组件 : columns 父组件. 反正等号后面都是当前组件的.可以看下面例子.","text":"一些总结吧 父组件和子组件之间通信用广播: vue可以用多种方法实现组件间沟通,比如用一个属性,不过这必须用上同步 :test.sync 要不然子组件的状态父组件不知道.但是这有个问题就是不利于解耦,捆绑太紧密了不能复用了,所以还是用广播.不过还是有个小小的疑问,如果两个同名事件怎么办呢?? 按文档里说是第一个,那可能是父组件加载子组件的顺序吧我想可能是这样的,如果存在同名的话,那就得手动调整顺序,我感觉最好不要同名. v-bind:fields=”columns” 绑定解释: 有时用简写就比较懵,简单记忆下: 如果原有属性就是绑定属性到vue属性.如果不是自带属性,那就是组件自定义的.比如 :fields=&quot;columns&quot; 这里就是一个. fields 子组件 : columns 父组件. 反正等号后面都是当前组件的.可以看下面例子. 1234567891011121314151617181920212223242526&lt;!-- 绑定 attribute --&gt;&lt;img v-bind:src=&quot;imageSrc&quot;&gt;&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot;&gt;&lt;!-- 绑定 class --&gt;&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;&lt;/div&gt;&lt;!-- 绑定 style --&gt;&lt;div :style=&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;&lt;!-- 绑定到一个对象 --&gt; &lt;!-- 这个怎么用不太了解 --&gt; &lt;div v-bind=&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;&gt;&lt;/div&gt;&lt;!-- prop 绑定，&quot;prop&quot; 必须在 my-component 组件内声明 --&gt;&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;!-- 双向 prop 绑定 --&gt;&lt;my-component :prop.sync=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;!-- 单次 prop 绑定 --&gt;&lt;my-component :prop.once=&quot;someThing&quot;&gt;&lt;/my-component&gt; v-on:create-item=”createItem” 绑定事件监听器: 绑定默认动作,如果不是默认动作,就是自定义事件. @create-item=&quot;createItem&quot; 这样的写法是把动作绑定到一个方法里.如果没有绑定,就需要把 create-item写在events 属性里了详细看下面例子代码 123456789101112131415161718192021222324252627282930313233&lt;!-- 方法处理器 --&gt;&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click=&quot;doThat(&#x27;hello&#x27;, $event)&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter=&quot;onEnter&quot;&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13=&quot;onEnter&quot;&gt;&lt;!--在子组件上监听自定义事件（当子组件触发 “my-event” 时将调用事件处理器）：--&gt;&lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;&lt;!-- 内联语句 --&gt;&lt;my-component @my-event=&quot;handleThis(123, $arguments)&quot;&gt;&lt;/my-component&gt; 123456new Vue(&#123; el: &#x27;#app&#x27;, store: store, template: &#x27;&lt;App/&gt;&#x27;, //原来如此 这句相当于在 index.html里 #app容器里 添加了 组件&lt;App&gt;&lt;App/&gt; 就是下面那个 components: &#123;App&#125;&#125;) 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;notepad&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot;&gt; &lt;link href=&quot;favicon.ico&quot; rel=&quot;SHORTCUT ICON&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;App&gt;&lt;/App&gt; 这个和main.js里的template作用是一样的 如果在new vue()的时候写 这样更简洁些 不过不利于阅读而已 --&gt;&lt;/div&gt;&lt;!-- built files will be auto injected --&gt;&lt;/body&gt;&lt;/html&gt; this.dataList.$set($index, { … } 如何给数组修改数据:this.dataList[$index] = &#123; ... &#125; 这么写可以 不过不能刷新页面.所以要修改数组数据 就得这么写 this.dataList.$set(index, &#123; ... &#125;详细看下面例子详细代码 this.item = this.dataList[index]: 这个真好不说,还不是十分明白.但是下面的例子确实是这样的.如果赋值了 他们好像就是绑定了 因为在子组件修改时 父组件数据也同步变化了.根本不需要我再去写什么去修改这个dataList数组了.详细看下面例子代码吧 例子:","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"Atom 使用小技巧","slug":"Atom 使用小技巧","date":"2016-07-23T13:27:52.000Z","updated":"2021-09-09T16:34:44.863Z","comments":true,"path":"2016/07/Atom 使用小技巧/","link":"","permalink":"http://elickzhao.github.io/2016/07/Atom%20%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"Atom使用纪要Atom 编辑器快捷键列表汇总整理","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"}]},{"title":"linux各个发行版简介","slug":"linux各个发行版简介","date":"2016-07-22T14:30:42.000Z","updated":"2021-09-09T16:34:45.297Z","comments":true,"path":"2016/07/linux各个发行版简介/","link":"","permalink":"http://elickzhao.github.io/2016/07/linux%E5%90%84%E4%B8%AA%E5%8F%91%E8%A1%8C%E7%89%88%E7%AE%80%E4%BB%8B/","excerpt":"","text":"kali linux: 黑客专业系统 kali是基于Debian的Linux发行版， 设计用于数字取证和渗透测试 和 黑客攻防 相关文档:kali 中国论坛 Kali Linux渗透测试实战 1.1 Kali Linux简介 Kali Linux 1.0 新手折腾笔记 Tiny Core linux: 最小的linux 最主要用于docker 现在服务器上也有人用了 相关文档:麻雀虽小五脏俱全 最小Linux系统试用 Elementary OS: 最美linux,这的确不假.虽然很多都是仿照苹果系统,不过的确比ubuntu好看又好用. 相关文档:Elementary OS 中文版 - 号称最漂亮的 Linux 系统！基于 Ubuntu 的界面精美发行版百度贴吧是个好去处 Tails: 保护隐私最好的版本 相关文档:扫盲 Tails——专门强化隐匿性的 Linux 发行版Tails：专注于隐私保护的开源操作系统 RancherOS: 基于docker的linux发行版 处理内核以外全是docker运行的 所以也非常的小 相关文档:基于Docker的Linux发行版：RancherOS","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"}]},{"title":"svchost.exe占用cpu过高","slug":"svchost.exe占用cpu过高","date":"2016-07-21T14:40:24.000Z","updated":"2021-09-09T16:34:45.402Z","comments":true,"path":"2016/07/svchost.exe占用cpu过高/","link":"","permalink":"http://elickzhao.github.io/2016/07/svchost.exe%E5%8D%A0%E7%94%A8cpu%E8%BF%87%E9%AB%98/","excerpt":"","text":"今天发现cpu占用率一直很高,查看了进程发现是 svchost.exe 占用了太多的资源.一顿百度,也没明确是那个问题.不过经过360打完补丁以后,恢复正常了,下次还出现这个问题,也可以这样解决试试","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"php 隐藏下载地址","slug":"php 隐藏下载地址","date":"2016-07-19T15:38:37.000Z","updated":"2021-09-09T16:34:45.371Z","comments":true,"path":"2016/07/php 隐藏下载地址/","link":"","permalink":"http://elickzhao.github.io/2016/07/php%20%E9%9A%90%E8%97%8F%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/","excerpt":"","text":"php下载时不想让别人看到真实的下载地址?怎样隐藏下载文件的真实地址?首先要取得下载文件的URL，这里假设你通过PHP的操作取得文件的URL地址，变量为$URL代码如下： 123456$file_size = filesize($url); header(&quot;Content-type: application/octet-stream&quot;); header(&quot;Accept-Ranges: bytes&quot;); header(&quot;Accept-Length: $file_size&quot;);header(&quot;Content-Disposition: attachment; filename=&quot;.basename($url)); header(&quot;location: $url&quot;); 将上面代码加入PHP文件后，就可以隐藏真实的URL地址，当用户通过点击像http://localhost/soft.php?id=1这样的网址时，就可以下载了 上面代码还有另一个功能，就是强制浏览器保存文件，而不是在浏览器当中打开文件。 参考文档php,下载时不想让别人看到真实的下载地址?怎样隐藏下载文件的真实地址使用php隐藏下载文件的真实地址","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"}]},{"title":"非常火的js框架简介","slug":"非常火的js框架简介","date":"2016-07-18T14:32:39.000Z","updated":"2021-09-09T16:34:45.756Z","comments":true,"path":"2016/07/非常火的js框架简介/","link":"","permalink":"http://elickzhao.github.io/2016/07/%E9%9D%9E%E5%B8%B8%E7%81%AB%E7%9A%84js%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Vue.js: 轻量级js 数据驱动的组件，为现代化的 Web 界面而生.这类js框架都是应用比较大型功能类网站,有点类似webapp.或者单页面程序,比如我现在用的听歌浏览器插件. 他的做法是把某个功能开发成个组件,这个组件包括了模版,css,js,然后打包在一起.通过很多组件的组合,到达一个功能类网站,这样就非常的灵活了.这个主要针对pc端. 参考文档官方网站对比其它框架Vue.js：轻量高效的前端组件化方案 *Vue + webpack 项目实践Vue.js 源码学习笔记同时使用reactjs+redux/vuejs+vuex/vuejs开发的卖座网，方便大家做技术选型vue.js 由浅至深学习宝典 *使用node+vue.js实现SPA应用,解决了SPA应用的最大缺点SEO Vuex: 具体是做什么用的,现在还不是很了解.摘录别人一句话吧,Vuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构.总之是和vue.js十分密切的东西. 参考文档使用 Vuex + Vue.js 构建单页应用 – *Vuex源码阅读笔记Vuex + Firebase 构建 Notes App用 Vuex 构建一个笔记应用 Angular.js 这个不用多说了,现在最火的框架,不仅开发pc端也用来开发手机端.不过强大的功能,也带来很高的学习成本. 参考文档AngularJS 教程中国官网AngularJS快速开始 React: 也是JavaScript MVC 框架，用于构建用户界面的JAVASCRIPT库–官方如此说主要用作Web App开发,不过因为小,貌似也用于手机程序开发,不过好像效果也不太好,以后有空再查查. 参考文档React 入门实例教程一看就懂的ReactJs入门教程（精华版）React chinaFlux 这就像Vuex一样 就不另起一行了中国官网 webix: 组件库 非常爽,不过好东西一般都收费 呵呵.《近匠》Webix，跨浏览器的JavaScript UI组件库官方网站 Ember.js 大而全,受到vue作者称赞.不过速度也就显而易见了,而且学习成本也高.看来只能开发web app 参考文档Ember.js的一些学习总结Angular.js VS. Ember.js：谁将成为Web开发的新宠？ Backbone.js: 应该是比较老的一个JavaScript MVC 框架 现在好像没有那么火了. 参考文档中国官网 Meteor.js: 这个是完全脱离后台程序,基础构架是 Node.JS + MongoDB.但是他有个特点是用命令构建很多东西.但是实用性还是存疑. 参考文档Meteor 入门中文论坛Web开发者看过来，Meteor开发框架为你带来下一代高品质实时Web App开发的新模式 Aurelia: 新听说的 不太了解有什么优势 参考文档Aurelia logoJavaScript 客户端框架 Aurelia如何评价新出的Aurelia框架？ KnockoutJS 这个不怎么火 不过下面这个文章不错 参考文档前端开发框架Bootstrap和KnockoutJS","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"vue.js开发扩展插件Vue.js devtools安装使用","slug":"vue.js开发扩展插件Vue.js devtools安装使用","date":"2016-07-17T14:31:36.000Z","updated":"2021-09-09T16:34:45.441Z","comments":true,"path":"2016/07/vue.js开发扩展插件Vue.js devtools安装使用/","link":"","permalink":"http://elickzhao.github.io/2016/07/vue.js%E5%BC%80%E5%8F%91%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6Vue.js%20devtools%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"仓库在这里 重要提示: 一定要完整版,因为精简版会把开发部分去掉,所以不支持这个. 只支持chrome,所以去chrome商店去下载吧 安装完成后,必须进入chrome扩展工具选项里,找到vue-devtools把下面的 允许访问文件网址 勾选上 这样用F12打开开发工具栏,最后一项就能看到 vue-devtools的身影了.","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"}]},{"title":"替代cmd的程序cmder,Gow,PowerCMD,ConsoleZ等等","slug":"替代cmd的程序cmder,Gow,PowerCMD,ConsoleZ等等","date":"2016-07-15T15:23:27.000Z","updated":"2021-09-09T16:34:45.681Z","comments":true,"path":"2016/07/替代cmd的程序cmder,Gow,PowerCMD,ConsoleZ等等/","link":"","permalink":"http://elickzhao.github.io/2016/07/%E6%9B%BF%E4%BB%A3cmd%E7%9A%84%E7%A8%8B%E5%BA%8Fcmder,Gow,PowerCMD,ConsoleZ%E7%AD%89%E7%AD%89/","excerpt":"","text":"前言windows的cmd真的很恶心,今天突然发现一个替代他的好东西cmder.而且还模拟了一些linux命令真不错.后来发现cmder也很一般,只是外观很好看.于是有找了几个 GowGow 另一个替代 Cygwin 毕竟Cygwin有点大.Cygwin的替代品 Gow PowerCMD这个还没用过,不知道有没有linux命令.不过支持中文,而且功能还可以. PowerCMD——cmd的命令行工具 ConEmu这个很朴实,跟cmd差不多太多,只是多了标签.没有其他的那么功能多,而且没有linux命令.带标签的Windows终端 ConEmu ConsoleZ这个也很朴实,不过可以设置透明度的美化,支持中文.好像写错了功能很强大,只不过下面作者用的老版windows下使用体验更好的控制台——ConsoleZGithub仓库 MobaXterm这个不好说是替代cmd,更像替代putty,SecureCRT和Xshell的,因为有各种连接服务的模式MobaXterm：“十项全能”的远程终端登录软件 cmder好吧可爱的墙,这是1.3.0版 如果级别低了 就再下吧360网盘 https://yunpan.cn/cBtsI2Dbu8g5e 访问密码 dec9 算了新版本不支持中文还是用老版本吧.如果不合心就不用了,因为作者懒得支持中文.windows下cmd的替换工具cmder 快捷键 Tab manipulationCtrl + ` : Global Summon from taskbarWin + Alt + p : Preferences (Or right click on title bar)Ctrl + t : New tab dialog (maybe you want to open cmd as admin?)Ctrl + w : Close tabShift + Alt + number : Fast new tab: 1. CMD 2. PowerShellAlt + Enter : Fullscreen ShellShift + Up : Traverse up in directory structure (lovely feature!)End, Home, Ctrl : Traverse text as usual on WindowsCtrl + r : History searchShift + mouse : Select and copy text from bufferRight click / Ctrl + Shift + v : Paste text 官方网站拥抱cmder，和cmd说再见 Color Console这个也是特别简朴的,只是颜色漂亮点Color Console – 增强版命令行提示符","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"解决老浏览器兼容问题","slug":"解决老浏览器兼容问题","date":"2016-07-14T15:31:19.000Z","updated":"2021-09-09T16:34:45.738Z","comments":true,"path":"2016/07/解决老浏览器兼容问题/","link":"","permalink":"http://elickzhao.github.io/2016/07/%E8%A7%A3%E5%86%B3%E8%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言 现在框架都放弃了IE9以下的浏览器,不过中国的环境大家都知道的,没办法还是尽量满足吧. 简介禁用IE兼容模式 1234&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;... 提示IE7及更早的用户 12345&lt;body&gt; &lt;!--[if lt IE 8]&gt; &lt;div class=&quot;alert alert-danger&quot;&gt;您正在使用 &lt;strong&gt;过时的&lt;/strong&gt; 浏览器. 是时候 &lt;a href=&quot;http://browsehappy.com/&quot;&gt;更换一个更好的浏览器&lt;/a&gt; 来提升用户体验.&lt;/div&gt; &lt;![endif]--&gt; ... 兼容IE8用户 因为IE8及早期版本不支持HTML5标签，所以针对IE8浏览器，我们引入html5shiv来使得HTML5标签在IE8中也能使用。在HTML文档的script区域加入以下代码： 123&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;dist/lib/ieonly/html5shiv.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 因为IE8及早期版本同样不支持media query来实现响应式布局，我们同样可以通过条件注释引入respond.js来帮助ie实现该功能。 123&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;dist/lib/ieonly/respond.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 因为IE8及早期版本不支持Canvas，如果你的产品用到ZUI中的 图表 视图，则需要引入 ExplorerCanvas 来支持绘图功能。 123&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;dist/lib/ieonly/excanvas.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 参考文档兼容浏览器","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"js二维数组定义和初始化三种方法","slug":"js二维数组定义和初始化三种方法","date":"2016-07-07T13:41:23.000Z","updated":"2021-09-09T16:34:45.219Z","comments":true,"path":"2016/07/js二维数组定义和初始化三种方法/","link":"","permalink":"http://elickzhao.github.io/2016/07/js%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"前言 js的数组和php有些不同,他的定义方法,自定义下标只有一种方法 var arr[&#39;a&#39;] = 1,不能像php一样 $arr = [&#39;a&#39;=&gt;1],还有种没有下标的自定义方法 就是下面方法一那种方法 方法一：直接定义并且初始化，这种遇到数量少的情况可以用1var _TheArray = [[&quot;0-1&quot;,&quot;0-2&quot;],[&quot;1-1&quot;,&quot;1-2&quot;],[&quot;2-1&quot;,&quot;2-2&quot;]]","text":"前言 js的数组和php有些不同,他的定义方法,自定义下标只有一种方法 var arr[&#39;a&#39;] = 1,不能像php一样 $arr = [&#39;a&#39;=&gt;1],还有种没有下标的自定义方法 就是下面方法一那种方法 方法一：直接定义并且初始化，这种遇到数量少的情况可以用1var _TheArray = [[&quot;0-1&quot;,&quot;0-2&quot;],[&quot;1-1&quot;,&quot;1-2&quot;],[&quot;2-1&quot;,&quot;2-2&quot;]] 方法二：未知长度的二维数组1234567var tArray = new Array(); //先声明一维for(var k=0;k&lt;i;k++)&#123; //一维长度为i,i为变量，可以根据实际情况改变 tArray[k]=new Array(); //声明二维，每一个一维数组里面的一个元素都是一个数组；for(var j=0;j&lt;p;j++)&#123; //一维数组里面每个元素数组可以包含的数量p，p也是一个变量； tArray[k][j]=&quot;&quot;; //这里将变量初始化，我这边统一初始化为空，后面在用所需的值覆盖里面的值 &#125;&#125; 给定义的数组传入所需的值 1tArray[6][1]=5；//这样就可以将5的值传入到数组中，覆盖初始化的空 方法三：在这之前，以上两者方法都有问题，方法二，每次定义都初始化了，虽然后面可以动态修改，但是还是不方法所以我尝试了一种动态传入值到数组的方法 ps:一些在实践过程中遇到的数组有趣的现象本来以为二维数组可以像下面这样直接传入值 123for(var a=0;a&lt;i;a++)&#123;tArray[a]=(matArray[a],addArray[a]); //matArray[a]和addArray[a]是两个数组，这两个数组直接传入tArray[a]中&#125;; 结果是tArray[a]中收到的是后面一个数组的值，matArray[a]的内容被忽略的，如果换一个位置，matArray[a]在后面，则传入的是addArray[a]的值。 思考：简单的例子： 1234var a=[1,2];var b=[];b[0]=a;//把数组a作为b数组的元素传入b数组中alert(b[0][1]); //2 上面是最简单的二维数组，上面例子换种写法： 123456789var b=[];b[0]=[1,2];//把数组[1,2]作为b数组的元素传入b数组中alert(b[0][1]); //2 //可以看出上面的b[0]=[1,2]是可以用的for(var a=0;a&lt;i;a++)&#123;tArray[a]=[ matArray[a],addArray[a] ]; 上面例子中的（）修改为[] 就可以成功的组成一个二维数组了&#125;; 总结：方法三：123for(var a=0;a&lt;i;a++)&#123;tArray[a]=[ aArray[a],bArray[a],cArray[a]]; 还可以增加dArray[a],eArray[a]&#125;; 这种情况适用于已知几个数组，把他们组合成一个二维数组情况","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"laravel Middleware中间件解析","slug":"laravel Middleware中间件解析","date":"2016-07-05T17:57:26.000Z","updated":"2021-09-09T16:34:45.238Z","comments":true,"path":"2016/07/laravel Middleware中间件解析/","link":"","permalink":"http://elickzhao.github.io/2016/07/laravel%20Middleware%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90/","excerpt":"","text":":分割 要传递给中间件的参数,多个参数用,分割","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"CSS的float正确理解及overflowhidden 属性详细解释","slug":"CSS的float正确理解及overflowhidden 属性详细解释","date":"2016-07-03T11:01:18.000Z","updated":"2021-09-09T16:34:44.876Z","comments":true,"path":"2016/07/CSS的float正确理解及overflowhidden 属性详细解释/","link":"","permalink":"http://elickzhao.github.io/2016/07/CSS%E7%9A%84float%E6%AD%A3%E7%A1%AE%E7%90%86%E8%A7%A3%E5%8F%8Aoverflowhidden%20%E5%B1%9E%E6%80%A7%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A/","excerpt":"","text":"简单说明float原来一直以为float是平面的,浮动就是左右偏移在平面上运动,其实是错的,浮动是立体的,记得用火狐浏览器的debug工具,有一项就是能看到立体的样子.所以当设置浮动后,这个层的宽高就不在瘦父层级的限制了,因为他是立体的,他实际是飘在父层级上.所以需要清浮动才可以让他继续接受父层级的控制,这里就需要overflow:hidden overflow:hidden所以说 overflow:hidden 并不是我们原以为的简单只是把多出的内容隐藏,他还有个引申的功能就是清理浮动所以当你使用float的时候一定要加上这个,要不然容易造成margin的偏移,或者使用padding解决这个问题.或者是子层级不受控制超出了父层级. 参考文档CSS 的overflow:hidden 属性详细解释","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"js一些隐式写法 !0 !!0 viod 0","slug":"js一些隐式写法 !0 !!0 viod 0","date":"2016-07-01T15:28:45.000Z","updated":"2021-09-09T16:34:45.194Z","comments":true,"path":"2016/07/js一些隐式写法 !0 !!0 viod 0/","link":"","permalink":"http://elickzhao.github.io/2016/07/js%E4%B8%80%E4%BA%9B%E9%9A%90%E5%BC%8F%E5%86%99%E6%B3%95%20!0%20!!0%20viod%200/","excerpt":"","text":"前言最近看别人的框架遇到一些别人的写法,虽然很直白,但是以前没遇到过,还是有点懵.不知道这种写法是遵从那那些编写规则,反正记录一下已被后面查找. 简单说明123456789101112131415//其实这个很直白了 因为一般bool值 表示 ture 为 1 false 为 0!0 == true !!0 == false //但是 !0 === true 这是错的 恒等于 是不会转义类型的 所以 0 还是 int 型 所以不能与 bool 型相等//这些都是同理了!1 == false!!1 == true//这是设置 a 为 undefined , 如果用字符串代替会存在浏览器兼容问题//也可以在 return 时使用,表示返回空,只是执行操作.//具体看下面参考文档var a = viod 0; 参考文档在js中，为什么!0是true，!!0是false，!1是false，!!1是true，!-1是false，!!-1是trueJS void 0 解析","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"margin-top失效的解决","slug":"margin-top失效的解决","date":"2016-06-30T13:47:30.000Z","updated":"2021-09-09T16:34:45.299Z","comments":true,"path":"2016/06/margin-top失效的解决/","link":"","permalink":"http://elickzhao.github.io/2016/06/margin-top%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3/","excerpt":"前言今天遇到个很bug的问题.在chrome里当窗口很小的时候,一个div就会偏移,但是当用鼠标调正窗口,又会变好.而且只有在chrome下有这个问题,最后确认原来是margin-top失效的原因.再次说明: 上面那个问题,并没有因使用overflow:hiden而解决.只是放在火狐里这个bug不存在了.后来是通过删除了子容器的 float:left 解决的.但到底是哪里冲突还是不明白.但下面这些方法解决一些浮动漂移是有用的. 问题的解决正统说法: 1：“在CSS2.1中，水平的margin不会被折叠；垂直margin可能在一些盒模型中被折叠…”2： 当第一个层浮动，而第二个没浮动层的margin会被压缩，详见–浮动元素后非浮动元素的margin的处理。 一 如果是两个容器并列,一般出现问题,是因为第一个容器加了浮动,第二个没有加 所以造成第二个margin出问题.解决办法是在第二个容器前增加一个&lt;divstyle=&quot;clear:both;&quot;&gt;&lt;/div&gt;.像下面这样,或者给box2也增加float;","text":"前言今天遇到个很bug的问题.在chrome里当窗口很小的时候,一个div就会偏移,但是当用鼠标调正窗口,又会变好.而且只有在chrome下有这个问题,最后确认原来是margin-top失效的原因.再次说明: 上面那个问题,并没有因使用overflow:hiden而解决.只是放在火狐里这个bug不存在了.后来是通过删除了子容器的 float:left 解决的.但到底是哪里冲突还是不明白.但下面这些方法解决一些浮动漂移是有用的. 问题的解决正统说法: 1：“在CSS2.1中，水平的margin不会被折叠；垂直margin可能在一些盒模型中被折叠…”2： 当第一个层浮动，而第二个没浮动层的margin会被压缩，详见–浮动元素后非浮动元素的margin的处理。 一 如果是两个容器并列,一般出现问题,是因为第一个容器加了浮动,第二个没有加 所以造成第二个margin出问题.解决办法是在第二个容器前增加一个&lt;divstyle=&quot;clear:both;&quot;&gt;&lt;/div&gt;.像下面这样,或者给box2也增加float; 1234&lt;div style=&quot;background-color: red;&quot;&gt; &lt;div class=&quot;box1&quot; style=&quot;float:left;background-color: olive&quot;&gt;dddd&lt;/div&gt; &lt;div class=&quot;box2&quot; style=&quot;clear:both;margin-top:20px; background-color: rosybrown;&quot;&gt;eeee&lt;/div&gt; &lt;/div&gt; 二 还有一种情况是因为父容器而导致偏移,比如我遇到这个,我最后就是加了个overflow:hidden;.解决办法有一下三种: 给父容器box加overflow:hidden;属性 父容器box加border除none以外的属性 用父容器box的padding-top代替margin-top 参考文档 margin-top在chrome中的问题CSS中margin-top属性失效问题解决CSS 的overflow:hidden 属性详细解释","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"}]},{"title":"说明 -- RESTful架构","slug":"说明 RESTful架构 ","date":"2016-06-29T14:19:42.000Z","updated":"2021-09-09T16:34:45.746Z","comments":true,"path":"2016/06/说明 RESTful架构 /","link":"","permalink":"http://elickzhao.github.io/2016/06/%E8%AF%B4%E6%98%8E%20RESTful%E6%9E%B6%E6%9E%84%20/","excerpt":"","text":"简单来讲 就是用 http 各种动作来实现 应用分类书面点就是这个 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 一般情况下 URI 应为名词 但我理解为了清楚表示 其实动词也无所谓 这点没那么重要 laravel 就也使用了动词 详解 : http://www.ruanyifeng.com/blog/2011/09/restful","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"jquery增加css样式","slug":"jquery增加css样式","date":"2016-06-28T08:38:07.000Z","updated":"2021-09-09T16:34:45.185Z","comments":true,"path":"2016/06/jquery增加css样式/","link":"","permalink":"http://elickzhao.github.io/2016/06/jquery%E5%A2%9E%E5%8A%A0css%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"前言今天脑袋陷入了打结中,jquery改变样式.遇到一个什么情况,css是个元素样式,不是针对具体的某个类,并且后添加的样式,通过jquery无法找到,所以想改这个样式特别麻烦. 解决与思考 jquery只能选定出现在DOM上的元素来更改他的css样式.为什么这么说呢,css的写法是这样的,一般先是定义一个根类,然后在子类再去分别定义特殊属性.如果这样的话,jquery能选择操作子类的样式,却无法操作根类.这种情况很诡异,应该也不常见吧.例如下面 123456789101112131415&lt;!-- 我遇到的就是这个问题, jquery能操作pre_id这个具体的pre的css,却无法操作上面那个css,但是这个css,还是影响了后面动态生成的pre,而且jquery没法获得后添加的这个pre也是麻烦事,要不也可以改变后添加这个pre的也能解决--&gt;&lt;style&gt;.edit_body .tabs pre&#123;display:none;&#125;#pre_id&#123;display:block;&#125;&lt;/style&gt; 最后的解决办法: 12//利用jquery添加一段样式到html,然后去覆盖根样式.$(&#x27;&lt;style&gt;&#x27;).html(&#x27;.edit_body .tabs pre&#123;display:block;&#125;&#x27;).appendTo($(&#x27;.edit_body .tabs pre&#x27;)); 参考文档jquery如何创建style","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"js截取字符串到最后几位","slug":"js截取字符串到最后几位","date":"2016-06-26T13:29:41.000Z","updated":"2021-09-09T16:34:45.230Z","comments":true,"path":"2016/06/js截取字符串到最后几位/","link":"","permalink":"http://elickzhao.github.io/2016/06/js%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0%E6%9C%80%E5%90%8E%E5%87%A0%E4%BD%8D/","excerpt":"","text":"这里唯一要点是 substr() 是截取字符串,不过和php不同的是 第二个参数不能为负数,也就是不能倒着数.所以只能用字符串长度减去要减掉的长度,得到截取的位置 12var uri = &#x27;F:\\phpStudy\\WWW\\kod\\static\\js\\lib\\editormd\\css&#x27;;uri.substr(0,(uri.length-11))","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"ubuntu 个人安装软件 全局命令","slug":"ubuntu 个人安装软件 全局命令","date":"2016-06-25T13:58:09.000Z","updated":"2021-09-09T16:34:45.415Z","comments":true,"path":"2016/06/ubuntu 个人安装软件 全局命令/","link":"","permalink":"http://elickzhao.github.io/2016/06/ubuntu%20%E4%B8%AA%E4%BA%BA%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%20%E5%85%A8%E5%B1%80%E5%91%BD%E4%BB%A4/","excerpt":"","text":"前言 自己装了一个sublime text ,但是不能用命令行打开,所以才想起如何做. 简单说明 因为linux发行版本关系,每个版本软件安装位置都不是固定的,这点比windows差了点.想找到apt-get安装真的有点费劲,这个我还没找到.但是启动命令我找到了,在ubuntu下启动命令安装在 /usr/bin 下面. 例如我想用的sublime text,他就是 /usr/bin/subl 然后在把这个 拷贝到 /usr/sbin 下就可以是全局命令了.cp /usr/bin/subl /usr/sbin","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://elickzhao.github.io/tags/ubuntu/"}]},{"title":"JavaSript模块规范 AMD规范与CMD规范介绍","slug":"JavaSript模块规范  AMD规范与CMD规范介绍 ","date":"2016-06-24T15:35:33.000Z","updated":"2021-09-09T16:34:44.956Z","comments":true,"path":"2016/06/JavaSript模块规范  AMD规范与CMD规范介绍 /","link":"","permalink":"http://elickzhao.github.io/2016/06/JavaSript%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%20%20AMD%E8%A7%84%E8%8C%83%E4%B8%8ECMD%E8%A7%84%E8%8C%83%E4%BB%8B%E7%BB%8D%20/","excerpt":"","text":"结合一些第三方模块构建工具，如CommonJS、RequireJS或者SeaJs，可以轻松实现代码的模块化。 也就是说 这三个工具是组合各个组件的工具,最后打包成最后代码 CommonJS 规范: 是同步加载模块AMD 规范: AMD（异步模块定义）是为浏览器环境设计的，因为 CommonJS 模块系统是同步加载的，当前浏览器环境还没有准备好同步加载模块的条件。 前言 JavaSript模块规范 - AMD规范与CMD规范介绍 这篇文章特别好,内容很详细,文章也比较大,我就不转过来了,想看的时候直接连接过去看一下吧. AMD,CommonJS解释 还有这个解释 http://webpackdoc.com/module-system.html","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"}]},{"title":"JS void 0 解析","slug":"JS void 0 解析","date":"2016-06-23T14:39:50.000Z","updated":"2021-09-09T16:34:44.932Z","comments":true,"path":"2016/06/JS void 0 解析/","link":"","permalink":"http://elickzhao.github.io/2016/06/JS%20void%200%20%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言 在修改kod时遇到这个,不太了解作用于是查了下资料,详细看这里 JS魔法堂：从void 0 === undefined说起 简单说下 在js函数里 return void 0 表示此函数无返回. 还有就是 undefined在JavaScript中并不属于保留字/关键字，因此在IE5.5~8中我们可以将其当作变量那样对其赋值（IE9+及其他现代浏览器中赋值给undefined将无效） 所以说用 void 赋值更为正规一些. void的行为特点为： 1. 不管void后的运算数是什么，只管返回纯正的undefined； 2. void会对其后的运算数作取值操作，因此若属性有个getter函数，那么就会调用getter函数（因此会产生副作用） 更多具体内容看上面文章吧.","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"JavaScript中的逗号","slug":"JavaScript中的逗号","date":"2016-06-22T04:08:04.000Z","updated":"2021-09-09T16:34:44.953Z","comments":true,"path":"2016/06/JavaScript中的逗号/","link":"","permalink":"http://elickzhao.github.io/2016/06/JavaScript%E4%B8%AD%E7%9A%84%E9%80%97%E5%8F%B7/","excerpt":"","text":"前言 开发时突然遇到js语句里很多逗号,一下子搞蒙了.才想起来,没有仔细研究过这个东西. 简单说明 直白的说,没有return时,返回最左边结果,有return时返回最右边结果,当return最后一个参数为void 0,将只执行操作无返回 《javascript权威指南(6版)》说逗号运算符（,）：先计算左边的操作数，然后计算右边的操作数，最后返回右操作数的值。比如 var a=(1+1,2+2,3+3); 结果是6。可是当逗号出现在其他的地方，好像就不是先算左边的，再算右边的，返回右边的了。比如函数调用中，Math.max(x,y,z)。这里的逗号就是分隔函数参数。还有声明变量时，var a=1,b=2,c=3。这里的逗号也是起分隔的作用。请教各位逗号“,”应该怎么去理解？难道是依据逗号使用环境而定？谢谢各位，求解惑，逗号让我感觉很晕。网上找的例子： 12345678910111213alert(2*5, 2*4) //输出10而不是8 函数接收第一个参数,也说明逗号级别比较低alert((2*5, 2*4)); // 输出8 ()是返回了,相当于隐藏了return 所以返回最右边操作数的值var a = 10, b = 20;function CommaTest()&#123; return a++, b++, 10;&#125;var c = CommaTest();alert(c); 返回10`//这里顺便再提下 void 0 如果想要无返回值,只进行操作.那么这么写 return a++, b++, 10, void 0;//这样将返回空 参考文章http://blog.csdn.net/wl110231/article/details/8162732","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"php 重载相关魔法函数 __get()，__set()，__isset() , __unset()  __call() __callStatic","slug":"php 重载相关魔法函数 __get()，__set()，__isset() , __unset()  __call() __callStatic","date":"2016-06-20T14:32:59.000Z","updated":"2021-09-09T16:34:45.367Z","comments":true,"path":"2016/06/php 重载相关魔法函数 __get()，__set()，__isset() , __unset()  __call() __callStatic/","link":"","permalink":"http://elickzhao.github.io/2016/06/php%20%E9%87%8D%E8%BD%BD%E7%9B%B8%E5%85%B3%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0%20__get()%EF%BC%8C__set()%EF%BC%8C__isset()%20,%20__unset()%20%20__call()%20__callStatic/","excerpt":"前言 从这里开始 123456 public function __call($method, $parameters)&#123; //这里注意 $this-&gt;guard() 返回的是个实例,call_user_func_array()第一个参数如果是类, //则需要数组第一个是类的实例变量 return call_user_func_array([$this-&gt;guard(), $method], $parameters);&#125;","text":"前言 从这里开始 123456 public function __call($method, $parameters)&#123; //这里注意 $this-&gt;guard() 返回的是个实例,call_user_func_array()第一个参数如果是类, //则需要数组第一个是类的实例变量 return call_user_func_array([$this-&gt;guard(), $method], $parameters);&#125; 简单说明 PHP所提供的”重载”（overloading）是指动态地”创建”类属性和方法。我们是通过魔术方法（magic methods）来实现的。 属性重载: __get() __set() __isset() __unset()类重载: __call() __callStatic 属性重载使用如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class PropertyTest &#123; /** 被重载的数据保存在此 */ private $data = array(); /** 重载不能被用在已经定义的属性 */ public $declared = 1; /** 只有从类外部访问这个属性时，重载才会发生 */ private $hidden = 2; public function __set($name, $value) &#123; echo &quot;Setting &#x27;$name&#x27; to &#x27;$value&#x27;\\n&quot;; $this-&gt;data[$name] = $value; &#125; public function __get($name) &#123; echo &quot;Getting &#x27;$name&#x27;\\n&quot;; if (array_key_exists($name, $this-&gt;data)) &#123; return $this-&gt;data[$name]; &#125; $trace = debug_backtrace(); trigger_error( &#x27;Undefined property via __get(): &#x27; . $name . &#x27; in &#x27; . $trace[0][&#x27;file&#x27;] . &#x27; on line &#x27; . $trace[0][&#x27;line&#x27;], E_USER_NOTICE); return null; &#125; /** PHP 5.1.0之后版本 */ public function __isset($name) &#123; echo &quot;Is &#x27;$name&#x27; set?\\n&quot;; return isset($this-&gt;data[$name]); &#125; /** PHP 5.1.0之后版本 */ public function __unset($name) &#123; echo &quot;Unsetting &#x27;$name&#x27;\\n&quot;; unset($this-&gt;data[$name]); &#125; /** 非魔术方法 */ public function getHidden() &#123; return $this-&gt;hidden; &#125;&#125;echo &quot;&lt;pre&gt;\\n&quot;;$obj = new PropertyTest;$obj-&gt;a = 1;echo $obj-&gt;a . &quot;\\n\\n&quot;;var_dump(isset($obj-&gt;a));unset($obj-&gt;a);var_dump(isset($obj-&gt;a));echo &quot;\\n&quot;;echo $obj-&gt;declared . &quot;\\n\\n&quot;;echo &quot;Let&#x27;s experiment with the private property named &#x27;hidden&#x27;:\\n&quot;;echo &quot;Privates are visible inside the class, so __get() not used...\\n&quot;;echo $obj-&gt;getHidden() . &quot;\\n&quot;;echo &quot;Privates not visible outside of class, so __get() is used...\\n&quot;;echo $obj-&gt;hidden . &quot;\\n&quot;;$obj-&gt;hidden=333; //这里需要注意下,设置的并不是属性hidden,所以得到也并不是.echo $obj-&gt;hidden . &quot;\\n&quot;;echo $obj-&gt;getHidden() . &quot;\\n&quot;; 12345678910111213141516171819202122232425262728## 输出结果如下Setting &#x27;a&#x27; to &#x27;1&#x27;Getting &#x27;a&#x27;1Is &#x27;a&#x27; set?bool(true)Unsetting &#x27;a&#x27;Is &#x27;a&#x27; set?bool(false)1Let&#x27;s experiment with the private property named &#x27;hidden&#x27;:Privates are visible inside the class, so __get() not used...2Privates not visible outside of class, so __get() is used...Getting &#x27;hidden&#x27;Notice: Undefined property via __get(): hidden in F:\\phpStudy\\WWW\\kod\\data\\public\\test\\1.php on line 134 in F:\\phpStudy\\WWW\\kod\\data\\public\\test\\1.php on line 90Setting &#x27;hidden&#x27; to &#x27;333&#x27;Getting &#x27;hidden&#x27;3332 方法重载使用如下 1234567891011121314151617181920212223242526272829303132333435363738394041//小例子//获得每个城市天气预报class Action&#123;public function tj()&#123; echo &#x27;tj天气预报&lt;br/&gt;&#x27;; &#125;/*$m 方法名$p 方法参数集合*/public function __call($m,$p)&#123; echo $m,&#x27;天气预报&lt;br/&gt;&#x27;; &#125;&#125;$c=new Action();$c-&gt;tj();//获得城市$city=$_GET[&#x27;method&#x27;];if(isset($city))&#123;//获得城市的方法，由魔术方法__call处理$c-&gt;$city();&#125;/*网址:http://localhost/php/60.php?method=beijing结果：tj天气预报beijing天气预报*/?&gt; 123456789101112131415161718192021222324252627282930class MethodTest &#123; public function __call($name, $arguments) &#123; // 注意: $name 的值区分大小写 echo &quot;Calling object method &#x27;$name&#x27; &quot; . implode(&#x27;, &#x27;, $arguments). &quot;\\n&quot;; &#125; /** PHP 5.3.0之后版本 */ public static function __callStatic($name, $arguments) &#123; // 注意: $name 的值区分大小写 echo &quot;Calling static method &#x27;$name&#x27; &quot; . implode(&#x27;, &#x27;, $arguments). &quot;\\n&quot;; &#125;&#125;$obj = new MethodTest;//runTest方法不存在$obj-&gt;runTest(&#x27;in object context&#x27;);MethodTest::runTest(&#x27;in static context&#x27;); // PHP 5.3.0之后版本-----//输出如下/*Calling object method &#x27;runTest&#x27; in object contextCalling static method &#x27;runTest&#x27; in static context*/ 过载实现 123456789101112131415161718192021222324class Magic &#123; function __call($name,$arguments) &#123; if($name==&#x27;foo&#x27;) &#123; if(is_int($arguments[0])) $this-&gt;foo_for_int($arguments[0]); if(is_string($arguments[0])) $this-&gt;foo_for_string($arguments[0]); &#125; &#125; private function foo_for_int($x) &#123; print(&quot;oh an int!&quot;); &#125; private function foo_for_string($x) &#123; print(&quot;oh a string!&quot;); &#125;&#125; $x = new Magic();$x-&gt;foo(3);$x-&gt;foo(&quot;3&quot;);-----//输出如下/*oh an int!oh a string!*/ 参考文档官方文档PHP魔术方法之__call与__callStatic方法PHP5学习笔记：用__call()实现方法重载","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"PHP 扩展模块 phpize 解释","slug":"PHP 扩展模块 phpize 解释","date":"2016-06-19T13:48:04.000Z","updated":"2021-09-09T16:34:45.007Z","comments":true,"path":"2016/06/PHP 扩展模块 phpize 解释/","link":"","permalink":"http://elickzhao.github.io/2016/06/PHP%20%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%20phpize%20%E8%A7%A3%E9%87%8A/","excerpt":"简介 phpize是什么？phpize是用来扩展php扩展模块的，通过phpize可以建立php的外挂模块比如你想在原来编译好的php中加入memcached或者ImageMagick等扩展模块，可以使用phpizen 安装PHP的模块一个方式是加上相关参数重新编译PHP一个是用到phpize,比如eaccelerator，memcache等，这个比较方便，不用重新编译PHP，也可以随时启用或停用 phpize是用来扩展php扩展模块的，通过phpize可以建立php的外挂模块.","text":"简介 phpize是什么？phpize是用来扩展php扩展模块的，通过phpize可以建立php的外挂模块比如你想在原来编译好的php中加入memcached或者ImageMagick等扩展模块，可以使用phpizen 安装PHP的模块一个方式是加上相关参数重新编译PHP一个是用到phpize,比如eaccelerator，memcache等，这个比较方便，不用重新编译PHP，也可以随时启用或停用 phpize是用来扩展php扩展模块的，通过phpize可以建立php的外挂模块. 使用实例Linux下利用phpize安装php扩展 php有很多扩展功能，我们在初次安装的时候并没有安装某些扩展，可能在使用的过程中，又需要用到这些扩展。php提供了一个phpize工具供我们安装需要的扩展。 下面我通过安装socket扩展来介绍phpize的使用： 1.找到自己的php安装目录，例如我的目录是home/vsrank/php，在该目录下，找到bin/phpize。如果没有这个工具，则说明没有安装该工具，那么需要安装php.dev，一般都会有这个工具。 2.要扩展的话，就需要有一个和当前已安装的php的版本一样的php的源包，当前php版本可以用过phpinfo()查看。就是初次安装后查看安装是否成功的那个test.php。 3.打开源包目录，进入到ext目录，例如我就进入到：/home/vsrank/php-5.3.10/ext下，ext下有各个php带有的扩展模块，进入到ext/sockets中。 4.cd到ext/sockets后，执行下面的命令： 1/home/vsrank/php/bin/phpize 即执行phpize工具，执行后，可以看到目录下生成了对应的configure文件： 5.现在就可以通过configure来配置，执行下面的命令： 1./configure --enable-sockets --with-php-config=/home/vsrank/php/bin/php-config 12make make install 执行之后，可以看到下面的输出： 12Installing shared extensions: /home/vsrank/php/lib/php/extensions/no-debug-non-zts-20090626/ Installing header files: /home/vsrank/php/include/php/ 第一个就是扩展模块的生成目录，可以在对应目录下看到对应的sockets.so文件。 6.更改php.ini，增加下面的语句： 1extension=&quot;/home/vsrank/php/lib/php/extensions/no-debug-non-zts-20090626/sockets.so&quot; 可以看到和上面的输出是一致的。 7.重启Apache，接下来就可以看看自己的socket是不是配置好了。。 参考文档phpize增加php模块phpize的深入理解php教程之phpize使用方法linux下用phpize给PHP动态添加扩展","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"PHP 扩展模块 POSIX 和 PCNTL","slug":"PHP 扩展模块 POSIX 和 PCNTL","date":"2016-06-18T12:51:57.000Z","updated":"2021-09-09T16:34:45.002Z","comments":true,"path":"2016/06/PHP 扩展模块 POSIX 和 PCNTL/","link":"","permalink":"http://elickzhao.github.io/2016/06/PHP%20%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%20POSIX%20%E5%92%8C%20PCNTL/","excerpt":"","text":"简介 这两个模块附带函数都是对多进程任务开的. 而且这两个模块好像只能在linux下安装,windows下是不支持的. 参考文档php的POSIX 函数以及进程测试的深入分析centos安装php-posixPOSIX 官方文档 PHP的pcntl多进程基于PCNTL的PHP并发编程进程控制 官方文档","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"PHP 扩展模块 PECL 解释","slug":"PHP 扩展模块 PECL 解释","date":"2016-06-17T03:05:36.000Z","updated":"2021-09-09T16:34:45.000Z","comments":true,"path":"2016/06/PHP 扩展模块 PECL 解释/","link":"","permalink":"http://elickzhao.github.io/2016/06/PHP%20%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%20PECL%20%E8%A7%A3%E9%87%8A/","excerpt":"","text":"简介PECL 的全称是 The PHP Extension Community Library ，是一个开放的并通过 PEAR(PHP Extension and Application Repository，PHP 扩展和应用仓库)打包格式来打包安装的 PHP 扩展库仓库。通过 PEAR 的 Package Manager 的安装管理方式，可以对 PECL 模块进行下载和安装。与以往的多数 PEAR 包不同的是，PECL 扩展包含的是可以编译进 PHP Core 的 C 语言代码，因此可以将 PECL 扩展库编译成为可动态加载的 .so 共享库，或者采用静态编译方式与 PHP 源代码编译为一体的方法进行扩展。PECL 扩展库包含了对于 XML 解析，数据库访问，邮件解析，嵌入式的 Perl 以及 Pthyon 脚本解释器等诸多的 PHP 扩展模块，因此从某种意义上来说，在运行效率上 PECL 要高于以往诸多的 PEAR 扩展库 参考文档PECL （PHP 扩展模块） 百度百科 PECL 扩展库安装 官方文档 PECL项目主页","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"phpstudy 建立本地测试网站","slug":"phpstudy 建立本地测试网站","date":"2016-06-16T15:28:53.000Z","updated":"2021-09-09T16:34:45.384Z","comments":true,"path":"2016/06/phpstudy 建立本地测试网站/","link":"","permalink":"http://elickzhao.github.io/2016/06/phpstudy%20%E5%BB%BA%E7%AB%8B%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E7%BD%91%E7%AB%99/","excerpt":"","text":"拿phpstudy建立本地域名很简单 打开 其他选项菜单 -&gt; 打开hosts 把要写的域名填写进去 比如 127.0.0.1 laravel.cc 然后打开 其他选项菜单 -&gt; 站点域名管理 添加 刚才的域名 laravel.cc 并指定目录 这样就ok了","categories":[],"tags":[{"name":"phpstudy","slug":"phpstudy","permalink":"http://elickzhao.github.io/tags/phpstudy/"}]},{"title":"phpstudy 2016配置","slug":"phpstudy 2016配置","date":"2016-06-15T14:05:29.000Z","updated":"2021-09-09T16:34:45.381Z","comments":true,"path":"2016/06/phpstudy 2016配置/","link":"","permalink":"http://elickzhao.github.io/2016/06/phpstudy%202016%E9%85%8D%E7%BD%AE/","excerpt":"","text":"因为这版更新了php7 所以需要VC10和VC14 这个百度查下载就可以了 但要记住一定要X86的 光装64位的是不好使的","categories":[],"tags":[{"name":"phpstudy","slug":"phpstudy","permalink":"http://elickzhao.github.io/tags/phpstudy/"}]},{"title":"laravel Event事件解析","slug":"laravel Event事件解析","date":"2016-06-14T14:43:47.000Z","updated":"2021-09-09T16:34:45.236Z","comments":true,"path":"2016/06/laravel Event事件解析/","link":"","permalink":"http://elickzhao.github.io/2016/06/laravel%20Event%E4%BA%8B%E4%BB%B6%E8%A7%A3%E6%9E%90/","excerpt":"前言 Event事件总是晕晕的,反复看了几遍,终于纠正了我的惯性思维,我一直认为监听类是起到监听作用.其实错了,事件类是相当于触发,监听某个动作.而监听类是响应这个动作的具体操作.从另一个方面讲,监听类其实监听的是事件类的触发.这下就清晰点了.下面把整个事件所需要的文件都简单说明下. 简要说明laravel事件的主要文件 Event.php (创建事件类,这个文件最主要的作用就是注入,其他的功能暂时没发现) Listener.php (创建监听类,这个文件的主要作用就是响应事件类,当事件触发了进行响应操作) EventServiceProvider.php (关联事件与监听的文件)","text":"前言 Event事件总是晕晕的,反复看了几遍,终于纠正了我的惯性思维,我一直认为监听类是起到监听作用.其实错了,事件类是相当于触发,监听某个动作.而监听类是响应这个动作的具体操作.从另一个方面讲,监听类其实监听的是事件类的触发.这下就清晰点了.下面把整个事件所需要的文件都简单说明下. 简要说明laravel事件的主要文件 Event.php (创建事件类,这个文件最主要的作用就是注入,其他的功能暂时没发现) Listener.php (创建监听类,这个文件的主要作用就是响应事件类,当事件触发了进行响应操作) EventServiceProvider.php (关联事件与监听的文件) 编写事件流程 注册事件-监听器 (也就是在EventServiceProvider里关联相关事件类和监听类) 用php artisan event:generate 生成事件类文件和监听类文件 定义事件类 定义监听器类 触发事件详细看下面的文档 参考文档Laravel 5.1 定义事件、事件监听器以及触发事件实例教程","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"VirtualBox虚拟机 修改分辨率","slug":"VirtualBox虚拟机 修改分辨率","date":"2016-06-13T07:42:01.000Z","updated":"2021-09-09T16:34:45.065Z","comments":true,"path":"2016/06/VirtualBox虚拟机 修改分辨率/","link":"","permalink":"http://elickzhao.github.io/2016/06/VirtualBox%E8%99%9A%E6%8B%9F%E6%9C%BA%20%E4%BF%AE%E6%94%B9%E5%88%86%E8%BE%A8%E7%8E%87/","excerpt":"","text":"前言 最近搞一个多人视频系统,需要用到php的多进程模块,所以搞了一个linux虚拟机,装的是号称最美linux的Elementary OS,不过VirtualBox的分辨率真让人头疼,以前只用命令行也就不在乎了,这么漂亮的桌面就那么一小块就不爽了,于是开始调整分辨率. 具体步骤 首先安装增强功能 VirtualBox会挂载一个光盘,进入linux找到光盘位置.执行sudo sh VBboxLinuxAdditions.run 即可 调整分辨率 详细可看下面文章. 参考文章VirtualBox虚拟机 Ubuntu分辨率太小的解决方案","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"http://elickzhao.github.io/tags/VirtualBox/"}]},{"title":"larave后台日志插件","slug":"larave后台日志插件","date":"2016-06-12T13:59:46.000Z","updated":"2021-09-09T16:34:45.276Z","comments":true,"path":"2016/06/larave后台日志插件/","link":"","permalink":"http://elickzhao.github.io/2016/06/larave%E5%90%8E%E5%8F%B0%E6%97%A5%E5%BF%97%E6%8F%92%E4%BB%B6/","excerpt":"前言也是发现了两个插件,rap2hpoutre/laravel-log-viewer和ARCANEDEV/LogViewer.第一个简单些,界面显示也简单些.第二个丰富些,不过第二个测试时不好使,可能是因为我装了两个有点冲突吧.","text":"前言也是发现了两个插件,rap2hpoutre/laravel-log-viewer和ARCANEDEV/LogViewer.第一个简单些,界面显示也简单些.第二个丰富些,不过第二个测试时不好使,可能是因为我装了两个有点冲突吧. rap2hpoutre/laravel-log-viewer 安装使用安装 1composer require rap2hpoutre/laravel-log-viewer 配置 1Rap2hpoutre\\LaravelLogViewer\\LaravelLogViewerServiceProvider::class, 添加路由 1Route::get(&#x27;logs&#x27;, &#x27;\\Rap2hpoutre\\LaravelLogViewer\\LogViewerController@index&#x27;); 然后看 http://myapp/logs 就可以了 仓库地址:rap2hpoutre/laravel-log-viewer ARCANEDEV/LogViewer 安装使用安装 1composer require arcanedev/log-viewer 配置 1Arcanedev\\LogViewer\\LogViewerServiceProvider::class, 1php artisan log-viewer:publish 使用可用这个命令检查是否安装成功 1php artisan log-viewer:check 然后看 http://myapp/log-viewer 就可以了 这个不需要上面那个,还得配置路由直接就可用","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"Laravel-lang 多语言插件","slug":"Laravel-lang 多语言插件","date":"2016-06-10T13:47:26.000Z","updated":"2021-09-09T16:34:44.960Z","comments":true,"path":"2016/06/Laravel-lang 多语言插件/","link":"","permalink":"http://elickzhao.github.io/2016/06/Laravel-lang%20%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%8F%92%E4%BB%B6/","excerpt":"前言发现两个不错的语音包,caouecs/Laravel-lang和overtrue/laravel-lang.第一个是第二个的基础,只是做了一下自动化 caouecs/Laravel-lang其实使用很简单,就如下所说,把项目下载到项目里,然后把要使用的语言包,放到resources\\lang里,然后改写config\\app.php里的语言设置就ok了","text":"前言发现两个不错的语音包,caouecs/Laravel-lang和overtrue/laravel-lang.第一个是第二个的基础,只是做了一下自动化 caouecs/Laravel-lang其实使用很简单,就如下所说,把项目下载到项目里,然后把要使用的语言包,放到resources\\lang里,然后改写config\\app.php里的语言设置就ok了 仓库地址:https://github.com/caouecs/Laravel-lang Via ComposerFor Laravel 5.* : add “caouecs/laravel-lang”: “3.0” in your composer.json in “require”For Laravel 5 : add “caouecs/laravel4-lang”: “2.0” in your composer.json in “require”For Laravel 4 : add “caouecs/laravel4-lang”: “~1.0” in your composer.json in “require”Do “composer update”Files of languages are in “vendor/caouecs/laravel-lang” directoryCopy the folders of languages that you want, in app/lang (resources/lang in laravel 5) folder of your application Laravel Via GitHubClone the GitHub repository : git clone https://github.com/caouecs/Laravel-lang.gitOr download the zip fileChoose the branch:laravel4 for Laravel4 projectmaster for Laravel5 projectCopy the folders of languages that you want, in app/lang folder of your application Laravel overtrue/laravel-lang这个也很简单 安装 1composer require &quot;overtrue/laravel-lang:~3.0&quot; 配置 完成上面的操作后，将项目文件 config/app.php 中的下一行 1Illuminate\\Translation\\TranslationServiceProvider::class, 替换为： 1Overtrue\\LaravelLang\\TranslationServiceProvider::class, 修改项目语言 config/app.php： 1&#x27;locale&#x27; =&gt; &#x27;zh-CN&#x27;, 使用1$ php artisan lang:publish zh-CN,zh-HK,th,tk 这样就会自动把语音包放到lang下面了 参考文档:项目说明文档项目仓库","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"laravel-breadcrumbs 面包屑插件","slug":"laravel-breadcrumbs 面包屑插件","date":"2016-06-10T07:44:07.000Z","updated":"2021-09-09T16:34:45.262Z","comments":true,"path":"2016/06/laravel-breadcrumbs 面包屑插件/","link":"","permalink":"http://elickzhao.github.io/2016/06/laravel-breadcrumbs%20%E9%9D%A2%E5%8C%85%E5%B1%91%E6%8F%92%E4%BB%B6/","excerpt":"前言还不错的插件,减少了开发面包屑功能的麻烦,不过还得自定义个文件,每个route都得写上下关系才行.还是不能特别便利,不过有总比没有好. 使用方法 安装 1$ composer require davejamesmiller/laravel-breadcrumbs","text":"前言还不错的插件,减少了开发面包屑功能的麻烦,不过还得自定义个文件,每个route都得写上下关系才行.还是不能特别便利,不过有总比没有好. 使用方法 安装 1$ composer require davejamesmiller/laravel-breadcrumbs 配置 123456789&#x27;providers&#x27; =&gt; [ // ... DaveJamesMiller\\Breadcrumbs\\ServiceProvider::class,],&#x27;aliases&#x27; =&gt; [ // ... &#x27;Breadcrumbs&#x27; =&gt; DaveJamesMiller\\Breadcrumbs\\Facade::class,], 使用 需要创建个文件app/Http/breadcrumbs.php 像是这样.每个路由都得定义一下,并且给与上下级关系,下面只是静态定义,更多定义可以看文档. 1234567891011121314151617181920212223242526272829303132333435&lt;?php// HomeBreadcrumbs::register(&#x27;home&#x27;, function($breadcrumbs)&#123; $breadcrumbs-&gt;push(&#x27;Home&#x27;, route(&#x27;home&#x27;));&#125;);// Home &gt; AboutBreadcrumbs::register(&#x27;about&#x27;, function($breadcrumbs)&#123; $breadcrumbs-&gt;parent(&#x27;home&#x27;); $breadcrumbs-&gt;push(&#x27;About&#x27;, route(&#x27;about&#x27;));&#125;);// Home &gt; BlogBreadcrumbs::register(&#x27;blog&#x27;, function($breadcrumbs)&#123; $breadcrumbs-&gt;parent(&#x27;home&#x27;); $breadcrumbs-&gt;push(&#x27;Blog&#x27;, route(&#x27;blog&#x27;));&#125;);// Home &gt; Blog &gt; [Category]Breadcrumbs::register(&#x27;category&#x27;, function($breadcrumbs, $category)&#123; $breadcrumbs-&gt;parent(&#x27;blog&#x27;); $breadcrumbs-&gt;push($category-&gt;title, route(&#x27;category&#x27;, $category-&gt;id));&#125;);// Home &gt; Blog &gt; [Category] &gt; [Page]Breadcrumbs::register(&#x27;page&#x27;, function($breadcrumbs, $page)&#123; $breadcrumbs-&gt;parent(&#x27;category&#x27;, $page-&gt;category); $breadcrumbs-&gt;push($page-&gt;title, route(&#x27;page&#x27;, $page-&gt;id));&#125;); 路由也需要一定的操作,这里文档没有特别提出.这里需要定义路由时要命名路由要不然就会出错. 12345678//利用as定义路由别名Route::get(&#x27;home&#x27;,[&#x27;as&#x27;=&gt;&#x27;home&#x27;,function()&#123; return view(&#x27;home&#x27;);&#125;]);Route::get(&#x27;blog&#x27;,[&#x27;as&#x27;=&gt;&#x27;blog&#x27;,function()&#123; return view(&#x27;blog&#x27;);&#125;]); 在模版中使用 12$ php artisan vendor:publish//生成 config/breadcrumbs.php 配置文件 这里可以配置模版文件,也就是面包屑样子.可以自定义,也可以使用插件写好的样子.文件像这样. 1&#x27;view&#x27; =&gt; &#x27;breadcrumbs::bootstrap3&#x27;, 然后在模版文件添加代码 1234&lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery/2.2.3/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&#123;!! Breadcrumbs::render(&#x27;blog&#x27;) !!&#125; 自带模版是拿bootstrap写的,所以要加入bootstrap样式,要不该看不到样子了 好了,简单使用就这些了,更多用法看文档吧,文档很详细的. 参考文档仓库地址davejamesmiller/laravel-breadcrumbs 文档地址Laravel Breadcrumbs","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"laravel插件记录","slug":"laravel插件记录","date":"2016-06-08T16:56:13.000Z","updated":"2021-09-09T16:34:45.266Z","comments":true,"path":"2016/06/laravel插件记录/","link":"","permalink":"http://elickzhao.github.io/2016/06/laravel%E6%8F%92%E4%BB%B6%E8%AE%B0%E5%BD%95/","excerpt":"","text":"前言总结一下好用的插件,省着忘记. 好用插件Api响应格式插件laravel5-fractalFractal官方网站 权限管理插件zizaco/entrust 面包屑插件davejamesmiller/laravel-breadcrumbs 提示翻译插件caouecs/laravel-lang 日志统计后台arcanedev/log-viewer 日志显示 和上面那个差不多 不过不用后台配合rap2hpoutre/laravel-log-viewer debug显示错误barryvdh/laravel-debugbar 给model加tag 暂时还不知道什么用cviebrock/eloquent-taggable 把title作为url有利于seocviebrock/eloquent-sluggable 提示信息插件laracasts/flash 一个个人网站和商城的程序microweber/microweber 构建API doc插件 自动生成api文件mpociot/laravel-apidoc-generator 后台程序big-pang/laravel5.2-Admin 后台程序 跟上面类似 不过这是老外写的而且更全面些rappasoft/laravel-5-boilerplate 应用的消息通知插件https://github.com/fenos/Notifynder使用 Laravel Notifynder 扩展轻松实现 Laravel 应用的消息通知功能 数据库备份插件vinkla/backup 这个带有压缩功能的备份 而且能查询列表,不过只能用在linux下,因为需要个rsyncpaulvl/backup 这个比上一个简单些不能压缩,文档说能命名但是测试不行,但可以用在windows下schickling/backup 这个非常全面 但是这个是 Laravel 4 的backup-manager/laravel 这个也比较大 功能比较全 这个需要zip压缩命令 所以在win下也不是很好用spatie/laravel-backup 这个也不错 最近一直更新 还上了php7.0和laravel5.3 不过文档比较麻烦 在另一个地址 被墙了","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"Entrust - Laravel 用户权限系统解决方案","slug":"Entrust - Laravel 用户权限系统解决方案","date":"2016-06-08T13:48:22.000Z","updated":"2021-09-09T16:34:44.905Z","comments":true,"path":"2016/06/Entrust - Laravel 用户权限系统解决方案/","link":"","permalink":"http://elickzhao.github.io/2016/06/Entrust%20-%20Laravel%20%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"前言最近需要做后台所以找到这个插件.下面的文章内容稍微有点老,但大致讲解的没问题,还是结合项目仓库一起看就明白很多了. 简单说明 针对那篇文章没有提到的东西简单说明下 注意引入文件,升级后很多名称变了,所以一定要参考文档.","text":"前言最近需要做后台所以找到这个插件.下面的文章内容稍微有点老,但大致讲解的没问题,还是结合项目仓库一起看就明白很多了. 简单说明 针对那篇文章没有提到的东西简单说明下 注意引入文件,升级后很多名称变了,所以一定要参考文档. 1234567891011121314151617181920use Zizaco\\Entrust\\EntrustRole; //以前引入的文件名不同,以后也要注意class Role extends EntrustRole&#123;&#125;use Zizaco\\Entrust\\EntrustPermission;class Permission extends EntrustPermission&#123;&#125;use Zizaco\\Entrust\\Traits\\EntrustUserTrait;class User extends Eloquent&#123; use EntrustUserTrait; //这个名称也变了 ...&#125; hasRole和can的用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//最简单用法//确认是否在哪个用户组和具有哪个权限$user-&gt;hasRole(&#x27;owner&#x27;); // false$user-&gt;hasRole(&#x27;admin&#x27;); // true$user-&gt;can(&#x27;edit-user&#x27;); // false$user-&gt;can(&#x27;create-post&#x27;); // true//可一次确认多个用户组和权限//第三个参数是判断,前面参数是 &amp;&amp; 还是 ||$user-&gt;hasRole([&#x27;owner&#x27;, &#x27;admin&#x27;]); // true$user-&gt;hasRole([&#x27;owner&#x27;, &#x27;admin&#x27;], true); // false, user does not have admin role$user-&gt;can([&#x27;edit-user&#x27;, &#x27;create-post&#x27;]); // true$user-&gt;can([&#x27;edit-user&#x27;, &#x27;create-post&#x27;], true); // false, user does not have edit-user permission//模糊匹配// match any admin permission$user-&gt;can(&quot;admin.*&quot;); // true// match any permission about users$user-&gt;can(&quot;*_users&quot;); // true//当前登录用户,可以用简单方法快速验证权限Entrust::hasRole(&#x27;role-name&#x27;);Entrust::can(&#x27;permission-name&#x27;);// is identical toAuth::user()-&gt;hasRole(&#x27;role-name&#x27;);Auth::user()-&gt;can(&#x27;permission-name&#x27;);//自定义验证ability()//三个参数 第一个role 第二个permission 第三个自定义参数 //这个个没用过暂时这么记录$options = array( &#x27;validate_all&#x27; =&gt; true, &#x27;return_type&#x27; =&gt; &#x27;both&#x27;);list($validate, $allValidations) = $user-&gt;ability( array(&#x27;admin&#x27;, &#x27;owner&#x27;), array(&#x27;create-post&#x27;, &#x27;edit-user&#x27;), $options);var_dump($validate);// bool(false)var_dump($allValidations);// array(4) &#123;// [&#x27;role&#x27;] =&gt; bool(true)// [&#x27;role_2&#x27;] =&gt; bool(false)// [&#x27;create-post&#x27;] =&gt; bool(true)// [&#x27;edit-user&#x27;] =&gt; bool(false)// &#125;//模版的一些用法@role(&#x27;admin&#x27;) &lt;p&gt;This is visible to users with the admin role. Gets translated to \\Entrust::role(&#x27;admin&#x27;)&lt;/p&gt;@endrole@permission(&#x27;manage-admins&#x27;) &lt;p&gt;This is visible to users with the given permissions. Gets translated to \\Entrust::can(&#x27;manage-admins&#x27;). The @can directive is already taken by core laravel authorization package, hence the @permission directive instead.&lt;/p&gt;@endpermission@ability(&#x27;admin,owner&#x27;, &#x27;create-post,edit-user&#x27;) &lt;p&gt;This is visible to users with the given abilities. Gets translated to \\Entrust::ability(&#x27;admin,owner&#x27;, &#x27;create-post,edit-user&#x27;)&lt;/p&gt;@endability//剩下还有中间件等等一些用法 看项目文档吧 这是我测试时的文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Route::get(&#x27;add&#x27;,function()&#123; // Cache为file时 会出现Cache不支持tag的错误 //换成array就好了 $admin = new Role; $admin-&gt;name = &#x27;Admin&#x27;; $admin-&gt;save(); $owner = new Role; $owner-&gt;name = &#x27;Owner&#x27;; $owner-&gt;save(); $manageUsers = new Permission(); $manageUsers-&gt;name = &#x27;manage_users&#x27;; $manageUsers-&gt;display_name = &#x27;Manage Users&#x27;; $manageUsers-&gt;save(); $managePosts = new Permission(); $managePosts-&gt;name = &#x27;manage_posts&#x27;; $managePosts-&gt;display_name = &#x27;Manage Posts&#x27;; $managePosts-&gt;save(); //给用户组增加权限 //从这个版本的文档来看 好像更喜欢用 attachPermission($managePosts) 这种简洁的写法 $owner-&gt;perms()-&gt;sync(array($managePosts-&gt;id, $manageUsers-&gt;id)); //还可以这么写 //$admin-&gt;attachPermissions($manageUsers,$managePosts); $admin-&gt;perms()-&gt;sync(array($managePosts-&gt;id)); //还可以这么写 //$admin-&gt;attachPermission($managePosts); // 获取用户 $user = User::where(&#x27;name&#x27;,&#x27;=&#x27;,&#x27;elick&#x27;)-&gt;first(); // 可以使用 Entrust 提供的便捷方法用户授权 // 注: 参数可以为 Role 对象, 数组, 或者 ID $user-&gt;attachRole( $admin ); // 或者使用 Eloquent 自带的对象关系赋值 //$user-&gt;roles()-&gt;attach( $admin-&gt;id ); // id only $a = $user-&gt;hasRole(&quot;Owner&quot;); // false $b = $user-&gt;hasRole(&quot;Admin&quot;); // true $c = $user-&gt;can(&quot;manage_posts&quot;); // true $d = $user-&gt;can(&quot;manage_users&quot;); // false dump($a);dump($b);dump($c);dump($d); //can 和hasRole也能接收数组 一个对全都对 $user-&gt;hasRole([&#x27;owner&#x27;, &#x27;admin&#x27;]); // true $user-&gt;can([&#x27;edit-user&#x27;, &#x27;create-post&#x27;]); // true //如果想要两个参数同为真才行,可以用第三个参数 $user-&gt;hasRole([&#x27;owner&#x27;, &#x27;admin&#x27;]); // true $user-&gt;hasRole([&#x27;owner&#x27;, &#x27;admin&#x27;], true); // false, user does not have admin role $user-&gt;can([&#x27;edit-user&#x27;, &#x27;create-post&#x27;]); // true $user-&gt;can([&#x27;edit-user&#x27;, &#x27;create-post&#x27;], true); // false, user does not have edit-user permission&#125;);Route::get(&#x27;test&#x27;,function()&#123; $user = User::where(&#x27;name&#x27;,&#x27;=&#x27;,&#x27;elick&#x27;)-&gt;first(); $a = $user-&gt;ability([&#x27;Admin&#x27;,&#x27;Owner&#x27;], [&#x27;manage_posts&#x27;,&#x27;manage_users&#x27;]); dump($a);&#125;); 参考文件项目地址:https://github.com/Zizaco/entrustEntrust - Laravel 用户权限系统解决方案","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"github删除fork项目","slug":"github删除fork项目","date":"2016-06-08T04:13:43.000Z","updated":"2021-09-09T16:34:45.155Z","comments":true,"path":"2016/06/github删除fork项目/","link":"","permalink":"http://elickzhao.github.io/2016/06/github%E5%88%A0%E9%99%A4fork%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"简单说明 在仓库页面的setting里,进入setting页面,到最下面看到delete this repository按钮,就是它了.点击删除后会提示让你输入仓库名称,输入完成后就删除完毕. 详细看这里图文说明:http://www.chepoo.com/remove-fork-github-project.html","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"Git","slug":"Git","permalink":"http://elickzhao.github.io/tags/Git/"}]},{"title":"Linux系统如何查看版本信息","slug":"Linux系统如何查看版本信息","date":"2016-06-06T07:41:04.000Z","updated":"2021-09-09T16:34:44.969Z","comments":true,"path":"2016/06/Linux系统如何查看版本信息/","link":"","permalink":"http://elickzhao.github.io/2016/06/Linux%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/","excerpt":"","text":"Linux系统如何查看版本信息 1234567891011//输入&quot;uname -a &quot;,可显示电脑以及操作系统的相关信息。uname -a//输入&quot;cat /proc/version&quot;,说明正在运行的内核版本。cat /proc/version//输入&quot;cat /etc/issue&quot;, 显示的是发行版本信息cat /etc/issue//lsb_release -a (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)lsb_release -a","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"}]},{"title":"laravel控制器学习笔记","slug":"laravel控制器学习笔记","date":"2016-06-05T15:54:43.000Z","updated":"2021-09-09T16:34:45.264Z","comments":true,"path":"2016/06/laravel控制器学习笔记/","link":"","permalink":"http://elickzhao.github.io/2016/06/laravel%E6%8E%A7%E5%88%B6%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一些私有属性说明 123456789101112131415161718//注册成功后挑战地址protected $redirectPath = &#x27;/&#x27;;//登录成功后跳转地址protected $loginPath = &#x27;/&#x27;;//但是有个问题当登录成功后 还是进入auth/login的时候 还是会默认跳转到/home路径下//重置密码后跳转路径protected $redirectTo = &#x27;/dashboard&#x27;;//设置这个属性就可以设置登录验证的字段protected $username = &#x27;name&#x27;;//自定义登录模版位置protected $loginView = &#x27;admin.auth.login&#x27;;//自定义注册模版位置protected $registerView = &#x27;admin.auth.register&#x27;;//这个自定义验证配置项 在config/auth.php 但是这是5.2属性 5.1没有 //这个可以坐到对前台会员登录和后台管理员登录 分离管理protected $guard = &#x27;admin&#x27;;","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"laravel模型学习笔记","slug":"laravel模型学习笔记","date":"2016-06-04T14:55:09.000Z","updated":"2021-09-09T16:34:45.273Z","comments":true,"path":"2016/06/laravel模型学习笔记/","link":"","permalink":"http://elickzhao.github.io/2016/06/laravel%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"模型类一些私有属性 123456789101112131415161718192021222324252627282930//指定表名 protected $table = &#x27;my_flights&#x27;;//这个限制只决定怎么插入到数据库 不决定怎么取出数据protected $dateFormat = &#x27;Y-m-d&#x27;;//白名单 可以直接创建数据的字段protected $fillable = [&#x27;title&#x27;,&#x27;intro&#x27;,&#x27;content&#x27;,&#x27;published_at&#x27;];//黑名单 除此之外的字段都可以直接创建protected $guarded = [&#x27;created_at&#x27;,&#x27;updated_at&#x27;];//设置字段为Carbon实例 可以直接使用Carbon方法protected $dates = [&#x27;published_at&#x27;];//属性转换类型 key是字段名称 value是要转换成的类型protected $casts = [&#x27;is_admin&#x27; =&gt; &#x27;boolean&#x27;,];//数组转换 把数组转化成JSON格式存入数据库 读取时自动转化成数组protected $casts = [&#x27;options&#x27; =&gt; &#x27;array&#x27;, ];//隐藏模型的一些属性 直接输出的时候是无法看见的protected $hidden = [&#x27;password&#x27;];//显示白名单 那些字段直接输出是可以被看到的protected $visible = [&#x27;first_name&#x27;, &#x27;last_name&#x27;];//追加字段到返回数组中 而且是数据库没有的字段 而且需要访问器的帮忙//但这个不理解有什么用处 他其实是通过已有字段经过判断后输出 两个字段都能返回 只不过这个返回是布尔值protected $appends = [&#x27;is_admin&#x27;];","text":"模型类一些私有属性 123456789101112131415161718192021222324252627282930//指定表名 protected $table = &#x27;my_flights&#x27;;//这个限制只决定怎么插入到数据库 不决定怎么取出数据protected $dateFormat = &#x27;Y-m-d&#x27;;//白名单 可以直接创建数据的字段protected $fillable = [&#x27;title&#x27;,&#x27;intro&#x27;,&#x27;content&#x27;,&#x27;published_at&#x27;];//黑名单 除此之外的字段都可以直接创建protected $guarded = [&#x27;created_at&#x27;,&#x27;updated_at&#x27;];//设置字段为Carbon实例 可以直接使用Carbon方法protected $dates = [&#x27;published_at&#x27;];//属性转换类型 key是字段名称 value是要转换成的类型protected $casts = [&#x27;is_admin&#x27; =&gt; &#x27;boolean&#x27;,];//数组转换 把数组转化成JSON格式存入数据库 读取时自动转化成数组protected $casts = [&#x27;options&#x27; =&gt; &#x27;array&#x27;, ];//隐藏模型的一些属性 直接输出的时候是无法看见的protected $hidden = [&#x27;password&#x27;];//显示白名单 那些字段直接输出是可以被看到的protected $visible = [&#x27;first_name&#x27;, &#x27;last_name&#x27;];//追加字段到返回数组中 而且是数据库没有的字段 而且需要访问器的帮忙//但这个不理解有什么用处 他其实是通过已有字段经过判断后输出 两个字段都能返回 只不过这个返回是布尔值protected $appends = [&#x27;is_admin&#x27;]; 数据库一些用法 1App\\Flight::updateOrCreate([&#x27;name&#x27;=&gt;&#x27;Flight 10&#x27;],[&#x27;airline&#x27;=&gt;&#x27;888&#x27;]); 如果有就更新第一条搜索到的数据 第一个参数搜索条件 第二个参数更新内容 如果没有就创建 这个方法和firstOrNew还有firstOrCreate 是一样的这不过这两个只有一个参数 他们用法其实不太很有用查到后只会更新下时间 并没有其他用,如果参数为数组为多元,那么只是加了搜索条件而已搜出来的 还是新的,所以还会接着创建.还有一点Create还得必须修改模型fillable或者$guarded 而New还得用save存一下不能直接插入数据库 1234567DB::table(&#x27;users&#x27;)-&gt;whereExists(function ($query) &#123; $query-&gt;select(DB::raw(1)) -&gt;from(&#x27;orders&#x27;) -&gt;whereRaw(&#x27;orders.user_id = users.id&#x27;);&#125;)-&gt;get(); select * from users where exists (select 1 from orders where orders.user_id = users.id) 生成上面那句语句 exists 判断括号内语句是否为真 为真则搜索 为假则放弃 表关联 还有个问题就是在函数命名上,也是有规矩的 单数用单数 复数用复数 下面就是例子 12345678public function account()&#123; return $this-&gt;hasOne(&#x27;App\\Models\\UserAccount&#x27;);&#125;//如果这里用单数post就会报错 public function posts()&#123; return $this-&gt;hasMany(&#x27;App\\Models\\Post&#x27;);&#125; 一对一Flight表 123456public function fly()&#123; //外键一般用当前模型的表名加ID 例如 flight_id //这个外键是int类型或者是varchar类型都可以 //第三个参数是表内关联的键 也是就是当期模型的表所含的字段 外键是关联外部的表所含的字段 return $this-&gt;hasOne(&#x27;App\\Flys&#x27;,&#x27;flight_fid&#x27;,&#x27;airline&#x27;);&#125; Fly表 12345678&gt; function flight()&#123; //默认外键为flight_id 这里的外键还是相对于Flight来说的 这是因为这个是belongsTO从属表 所以外键是位于表内字段 //return $this-&gt;belongsTo(&#x27;App\\Flight&#x27;,&#x27;f_id&#x27;,&#x27;airline&#x27;); //这里内键也是相对Flight说 其实是Flight的内部字段 return $this-&gt;belongsTo(&#x27;App\\Flight&#x27;,&#x27;flight_fid&#x27;,&#x27;airline&#x27;);&#125; 一对多 123456789101112/* 实际上在底层无论是hasOne方法还是belongsTo方法都可以接收额外参数， 比如如果user_accounts中关联users的外键是$foreign_key，该外键对应users表中的列是$local_key， 那么我们可以这样调用hasOne方法： $this-&gt;hasOne(&#x27;App\\Models\\UserAccount&#x27;,$foreign_key,$local_key); 调用belongsTo方法也是一样： $this-&gt;belongsTo(&#x27;App\\User&#x27;,$foreign_key,$local_key); 此外，belongsTo还接收一个额外参数$relation，用于指定关联关系名称， 其默认值为调用belongsTo的方法名，这里是user。 * */ 多对多 12345//注意我们定义中间表的时候没有在结尾加s并且命名规则是按照字母表顺序，//将role放在前面，user放在后面，并且用_分隔//所以RoleUser这个model必须指定表名 要不会出错的 protected $table = &#x27;role_user&#x27;;//至于字段就没有说道了$user = User::find(1);","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"phpstorm 图标含义大解析","slug":"phpstorm 图标含义大解析","date":"2016-06-03T17:19:39.000Z","updated":"2021-09-09T16:34:45.373Z","comments":true,"path":"2016/06/phpstorm 图标含义大解析/","link":"","permalink":"http://elickzhao.github.io/2016/06/phpstorm%20%E5%9B%BE%E6%A0%87%E5%90%AB%E4%B9%89%E5%A4%A7%E8%A7%A3%E6%9E%90/","excerpt":"前言 phpstorm是个非常棒的IDE,高度定制化并且功能丰富.但因为没有正式的汉化版,所以很多便捷的使用方式,还没有被大家了解到.看来以后要多研究啊.最近使用的时候就发现了问题,一些图标不知道他具体的含义,本来是很好的提示作用却打了折扣,这里把英文翻译过来,以便日后记忆.","text":"前言 phpstorm是个非常棒的IDE,高度定制化并且功能丰富.但因为没有正式的汉化版,所以很多便捷的使用方式,还没有被大家了解到.看来以后要多研究啊.最近使用的时候就发现了问题,一些图标不知道他具体的含义,本来是很好的提示作用却打了折扣,这里把英文翻译过来,以便日后记忆. 图标解析文件类型图标 文件类型 图标 apache 配置文件 归档文件 C# 文件 C/C++ 文件 Shell 命令文件 CoffeeScript 文件 Dart 文件 (介绍:http://www.oschina.net/p/dart) Diagram 文件 (UML,流程图文件) Erlang 文件 纯文本文件 handlebars 文件 (Handlebars 是 JavaScript 一个语义模板库) HAML 文件 (介绍:http://www.oschina.net/p/haml) HTML 文件 IDL 文件 (接口描述语言,一种开发语言) Image文件 JavaFX 文件 (介绍:http://www.javafxchina.net/blog/) JavaScript 文件 JavaScript test 文件 Node.js运行文件 JSON 文件 JSTestDriver Config 文件 JSP 文件 LESS 文件 reStructuredText 文件 (类似MD文档语音) Patch(补丁)文件 PHP 文件 Regular expressions (正则文件) SASS/SCSS 文件 Smarty 文件 SQL 文件 Stylus 文件 (类似less/scss语音) TypeScript 文件 (介绍:http://www.open-open.com/lib/view/open1349622724697.html) XHTML 文件 XML DTD 文件 (介绍:http://www.w3school.com.cn/dtd/) XML 文件 YAML 文件 普通图标 图标 描述 变量 (Variable) 属性 (Property) 参数 (Parameter) 元素 (Element) 源文件夹 ( Source root) 测试目录 (Test root) 资源目录 (Resource root) 以下为可见性修饰符 —– 私有的 (private) 受保护的 (protected) 公共的 (public) 树形中的图标 图标 描述 类 (Class) Final class 接口 (Interface) PHP trait 方法/函数 (Method/function) 方法/函数的接口 ( Method/function in an interface) Dart函数 (Function in Dart) 变量 (Variable) 常量 (Constant) 字段，信息组 (Field) 属性 (Property) 参数 (Parameter) 元素 (Element) 以下为可见性修饰符 —– 私有的 (private) 受保护的 (protected) 公共的 (public) 数据源 图标 描述 数据库(DB data source) DB2 Derby H2 HSQLDB MySQL Oracle PostgreSQL SQL Server SQLite Sybase 只读 (DB data source with the read-only status, e.g. DBReadonlyDB2 for DB2.) DDL data source 模式/集合 (Schema) 表 (Table) 视图 (View) 列 (Column) 非空字段 (A NOT NULL column) 主键字段 (Column with a primary key) 外键字段 (Column with a foreign key) 索引字段 ( Column with an index) 主键 (Primary key) 外键 (Foreign key) 索引 (Index) 数据函数 ()dataFunction) 参考文章https://www.jetbrains.com/help/phpstorm/2016.1/symbols.html?from=old_help&amp;top=","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"phpstorm","slug":"phpstorm","permalink":"http://elickzhao.github.io/tags/phpstorm/"}]},{"title":"看码高手 各种编码长相","slug":"看码高手 各种编码长相","date":"2016-06-03T09:34:21.000Z","updated":"2021-09-09T16:34:45.717Z","comments":true,"path":"2016/06/看码高手 各种编码长相/","link":"","permalink":"http://elickzhao.github.io/2016/06/%E7%9C%8B%E7%A0%81%E9%AB%98%E6%89%8B%20%E5%90%84%E7%A7%8D%E7%BC%96%E7%A0%81%E9%95%BF%E7%9B%B8/","excerpt":"","text":"前言 有些编码时间长了一不用,就忘记了.看长相挺熟悉,就是不知道是什么.所以还是记录下吧 Unicode\\u547d\\u4ee4 –&gt; 命令 Utf-8&amp;#x6211;&amp;#x662F;&amp;#x4E92;&amp;#x8054;&amp;#x7F51; –&gt; 我是互联网 UrlEncode (utf-8)%e6%88%91%e6%98%af%e4%ba%92%e8%81%94%e7%bd%91 –&gt; 我是互联网","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"Sea.js 模块开发插件","slug":"Sea.js 模块开发插件","date":"2016-06-02T14:26:58.000Z","updated":"2021-09-09T16:34:45.034Z","comments":true,"path":"2016/06/Sea.js 模块开发插件/","link":"","permalink":"http://elickzhao.github.io/2016/06/Sea.js%20%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6/","excerpt":"前言 现在大部分前端开发,都用npm或者bower.因为这样不仅升级组件方便,而且兼容性也能得到保障.但是对于简单开发来说,过于庞大的组件也是比较麻烦的.所以这个Sea.js还是有一定存在价值的. 我也是在KodExplorer里发现这个插件的.没有太多使用,所以这里就点一下,以便以后记住.如果需要用就看官方吧,里面文档很详细的.","text":"前言 现在大部分前端开发,都用npm或者bower.因为这样不仅升级组件方便,而且兼容性也能得到保障.但是对于简单开发来说,过于庞大的组件也是比较麻烦的.所以这个Sea.js还是有一定存在价值的. 我也是在KodExplorer里发现这个插件的.没有太多使用,所以这里就点一下,以便以后记住.如果需要用就看官方吧,里面文档很详细的. 我的一些经验定义模块的时候,两种方法对外提供功能.但是不能在同一文件中,定义两个.一种是提供函数,另一种是提供类的方法.两种使用方法也不同,具体看下面例子 模块js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879define([&quot;./languages/en&quot;, &quot;./plugins/link-dialog/link-dialog&quot;, &quot;./plugins/reference-link-dialog/reference-link-dialog&quot;, &quot;./plugins/image-dialog/image-dialog&quot;, &quot;./plugins/code-block-dialog/code-block-dialog&quot;, &quot;./plugins/table-dialog/table-dialog&quot;, &quot;./plugins/emoji-dialog/emoji-dialog&quot;, &quot;./plugins/goto-line-dialog/goto-line-dialog&quot;, &quot;./plugins/help-dialog/help-dialog&quot;, &quot;./plugins/html-entities-dialog/html-entities-dialog&quot;, &quot;./plugins/preformatted-text-dialog/preformatted-text-dialog&quot; ], function(require, exports, module)&#123; //var $ = require(&quot;jquery&quot;); //这里很怪 define([加载模块组]) 这里说是预加载,可是没有下面 require()是用不了的 //但是下面require() 并不需要上面定义预加载 也可以用 那么这数组还有什么意思 //但是要改的那里 也是这么写的 好怪 require(&quot;./plugins/link-dialog/link-dialog&quot;); require(&quot;./plugins/reference-link-dialog/reference-link-dialog&quot;); require(&quot;./plugins/image-dialog/image-dialog&quot;); require(&quot;./plugins/code-block-dialog/code-block-dialog&quot;); require(&quot;./plugins/table-dialog/table-dialog&quot;); require(&quot;./plugins/emoji-dialog/emoji-dialog&quot;); require(&quot;./plugins/goto-line-dialog/goto-line-dialog&quot;); require(&quot;./plugins/help-dialog/help-dialog&quot;); require(&quot;./plugins/html-entities-dialog/html-entities-dialog&quot;); require(&quot;./plugins/preformatted-text-dialog/preformatted-text-dialog&quot;); var editormd = require(&quot;./editormd&quot;); //console.log($, editormd); //console.log(require.resolve(&quot;./editormd&quot;)); var uri = (module.uri); //console.log(uri.substr(0,(uri.length-11))); var libpath = uri.substr(0,(uri.length-11))+&quot;lib/&quot;; //exports.foo = &#x27;bar&#x27;; exports.doSomething = function() &#123; //alert(&#x27;dosomething&#x27;); testEditor = editormd(&quot;test-editormd&quot;, &#123; width: &quot;90%&quot;, height: 640, path : libpath, markdown : &#x27;ddddd&#x27;, //toolbar : false, //关闭工具栏 htmlDecode : true, // 开启HTML标签解析，为了安全性，默认不开启 tex : true, // 开启科学公式TeX语言支持，默认关闭 //previewCodeHighlight : false, // 关闭预览窗口的代码高亮，默认开启 flowChart : true, // 疑似Sea.js与Raphael.js有冲突，必须先加载Raphael.js，Editor.md才能在Sea.js下正常进行； sequenceDiagram : true, // 同上 onload : function() &#123; console.log(&#x27;onload&#x27;, this); //this.fullscreen(); //this.unwatch(); //this.watch().fullscreen(); //this.setMarkdown(&quot;#PHP&quot;); //this.width(&quot;100%&quot;); //this.height(480); //this.resize(&quot;100%&quot;, 640); &#125; &#125;); &#125;; function Mdeditor () &#123; &#125; //这两个是冲突的 module.exports和exports只能出现一个 //module.exports 返回的是个对象,exports返回的是属性和方法 //module.exports = Mdeditor; Mdeditor.prototype.call = function () &#123; alert(&#x27;ddd&#x27;); &#125; &#125;); mainjs 123456 var editormd = require(&quot;editormd&quot;); editormd.doSomething(); alert(editormd.foo); //当使用对象时 还得new一下才可以// var e = new editormd();// e.call(); 在seajs.use()的时候加载的模块是自动引用的,不用想上面的定义模块时,require一下,直接就可用了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// // 并发加载模块 a 和模块 b，并在都加载完成时，执行指定回调seajs.use([&#x27;./a&#x27;, &#x27;./b&#x27;], function(a, b) &#123; a.init(); b.init();&#125;);------------------------------------------------------------------&lt;script type=&quot;text/javascript&quot;&gt; seajs.config(&#123; base : &quot;./&quot;, alias : &#123; jquery : &quot;js/jquery.min&quot;, //editormd : &quot;../../editormd&quot; editormd : &quot;../editormd&quot; &#125; &#125;); //seajs.use(&quot;./js/seajs-main&quot;); //使用main.js时 editormd 路径要改为 &quot;../../editormd&quot; var deps = [ &quot;jquery&quot;, &quot;editormd&quot;, &quot;../languages/en&quot;, &quot;../plugins/link-dialog/link-dialog&quot;, &quot;../plugins/reference-link-dialog/reference-link-dialog&quot;, &quot;../plugins/image-dialog/image-dialog&quot;, &quot;../plugins/code-block-dialog/code-block-dialog&quot;, &quot;../plugins/table-dialog/table-dialog&quot;, &quot;../plugins/emoji-dialog/emoji-dialog&quot;, &quot;../plugins/goto-line-dialog/goto-line-dialog&quot;, &quot;../plugins/help-dialog/help-dialog&quot;, &quot;../plugins/html-entities-dialog/html-entities-dialog&quot;, &quot;../plugins/preformatted-text-dialog/preformatted-text-dialog&quot; ]; seajs.use(deps, function($, editormd) &#123; var testEditor; $.get(&quot;./test.md&quot;, function(md)&#123; testEditor = editormd(&quot;test-editormd&quot;, &#123; width: &quot;90%&quot;, height: 640, path : &#x27;../lib/&#x27;, markdown : md, //toolbar : false, // 关闭工具栏 codeFold : true, searchReplace : true, saveHTMLToTextarea : true, // 保存 HTML 到 Textarea htmlDecode : &quot;style,script,iframe|on*&quot;, // 开启 HTML 标签解析，为了安全性，默认不开启 emoji : true, taskList : true, tocm : true, // Using [TOCM] tex : true, // 开启科学公式 TeX 语言支持，默认关闭 //previewCodeHighlight : false, // 关闭预览窗口的代码高亮，默认开启 flowChart : true, // 疑似 Sea.js与 Raphael.js 有冲突，必须先加载 Raphael.js ，Editor.md 才能在 Sea.js 下正常进行； sequenceDiagram : true, // 同上 //dialogLockScreen : false, // 设置弹出层对话框不锁屏，全局通用，默认为 true //dialogShowMask : false, // 设置弹出层对话框显示透明遮罩层，全局通用，默认为 true //dialogDraggable : false, // 设置弹出层对话框不可拖动，全局通用，默认为 true //dialogMaskOpacity : 0.4, // 设置透明遮罩层的透明度，全局通用，默认值为 0.1 //dialogMaskBgColor : &quot;#000&quot;, // 设置透明遮罩层的背景颜色，全局通用，默认为 #fff imageUpload : true, imageFormats : [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;], imageUploadURL : &quot;./php/upload.php&quot;, onload : function() &#123; console.log(&#x27;onload&#x27;, this); //this.fullscreen(); //this.unwatch(); //this.watch().fullscreen(); //this.setMarkdown(&quot;#PHP&quot;); //this.width(&quot;100%&quot;); //this.height(480); //this.resize(&quot;100%&quot;, 640); &#125; &#125;); &#125;); &#125;); &lt;/script&gt; 项目地址 http://seajs.org/docs/#intro","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"php 函数学习","slug":"php 函数学习","date":"2016-06-01T15:21:40.000Z","updated":"2021-09-09T16:34:45.352Z","comments":true,"path":"2016/06/php 函数学习/","link":"","permalink":"http://elickzhao.github.io/2016/06/php%20%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/","excerpt":"查看练习地址:[https://ide.c9.io/elickzhao/test(https://ide.c9.io/elickzhao/test) [TOC]","text":"查看练习地址:[https://ide.c9.io/elickzhao/test(https://ide.c9.io/elickzhao/test) [TOC] 魔术常量 名称 说明 __FILE__ 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。 __DIR__ 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增） 。 __FUNCTION__ 函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。 __CLASS__ 类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\\Bar）。注意自 PHP 5.4 起 __CLASS__ 对 trait 也起作用。当用在 trait 方法中时，__CLASS__ 是调用 trait 方法的类的名字。。 __TRAIT__ Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 Foo\\Bar）。 __METHOD__ 类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。。 __NAMESPACE__ 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 Aarray_slice()1234//从数组中取出一段//参数 取出开始位置 取出个数//返回是个数组array_slice() Cclass_uses()1234//返回类所引用的trait //参数可以是个 实例 new bar 也可以是个字符串类名 &#x27;bar&#x27;//返回的是一个数组结果 class_uses() checkdnsrr()123456//主要用于检查域名和ip是否正确//给指定的主机（域名）或者IP地址做DNS通信检查//参数 ip或者域名 备选参数主机类型 //返回 一个布尔值//bool checkdnsrr ( string $host [, string $type = &quot;MX&quot; ] )checkdnsrr() call_user_func_array()1mixed call_user_func_array ( callable $callback , array $param_arr ) compact()创建一个包含变量名和它们的值的数组： 12345678910111213&lt;?php$firstname = &quot;Bill&quot;;$lastname = &quot;Gates&quot;;$age = &quot;60&quot;;$result = compact(&quot;firstname&quot;, &quot;lastname&quot;, &quot;age&quot;);print_r($result);?&gt;-----out:Array ( [firstname] =&gt; Bill [lastname] =&gt; Gates [age] =&gt; 60 ) Ddirname()1234567891011//dirname() 函数返回路径中的目录部分。dirname(path);echo dirname(&quot;c:/testweb/home.php&quot;);echo dirname(&quot;/testweb/home.php&quot;);------#output# c:/testweb# /testweb date_parse_from_format()12345//返回给定日期的详细数组//参数 格式 给定日期//返回个数组//array date_parse_from_format ( string $format , string $date )date_parse_from_format(); Ffilter_var()12345//函数通过指定的过滤器过滤变量。如果成功，则返回已过滤的数据，如果失败，则返回 false。//参数 规定要过滤的变量 可选。规定要使用的过滤器的 ID。 规定包含标志/选项的数组。检查每个过滤器可能的标志和选项。 http://www.w3school.com.cn/php/php_ref_filter.asp//filter_var(variable, filter, options)filter_var file_exists()Gget_class()1234//返回对象的类名//参数类实例//返回一个类名字符串get_class() Iini_set()12345//设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。取值用 ini_get()//参数 $varname : 选项名称//参数 $newvalue : 选项新的值//返回 成功时返回旧的值，失败时返回 FALSE。string ini_set ( string $varname , string $newvalue ) Mmethod_exists()1234//检查类的方法是否存在//参数 前面是类实例 后面是方法名//返回是个布尔值method_exists() Pproperty_exists()12345//检查对象或类是否具有该属性//参数 类 属性名//返回 布尔值bool property_exists ( mixed $class , string $property )property_exists() preg_split()12345//通过一个正则表达式分隔字符串//参数 搜索模式正则 被搜索的字符串 限度最多被分成几个部分 flags看手册吧讲了很多但不太主要//返回数组被分割的数组//array preg_split ( string $pattern , string $subject [, int $limit = -1 [, int $flags = 0 ]] )preg_split() property_exists()*Sstr_replace()12345678910//该函数子字符串替换//参数 查询部分 替换部分 字符串//返回一个字符串或者数组str_replace() #例echo str_replace(&quot;world&quot;,&quot;Shanghai&quot;,&quot;Hello world!&quot;);-----#output# Hello Shanghai! Uunlink()","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"}]},{"title":"js 操作文件 FileAPI","slug":"js 操作文件 FileAPI","date":"2016-05-31T10:27:46.000Z","updated":"2021-09-09T16:34:45.187Z","comments":true,"path":"2016/05/js 操作文件 FileAPI/","link":"","permalink":"http://elickzhao.github.io/2016/05/js%20%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%20FileAPI/","excerpt":"[TOC] 项目地址:https://github.com/mailru/FileAPI 前言原本打算是操作本地文件,如打开文件,新建文件,保存文件.但好像js是无法坐到这些的. 只能通过一些特别的手段达到一定的效果而已. 这个组件就是搜索时找到的,主要是通过上传时得到文件一些信息,他主要用作图片上传, 文件上传时获得相关内容.而且他还能操作摄像头用于头像. 并且他还有个jquery的插件,主要用处也是上传头像时的相关操作.","text":"[TOC] 项目地址:https://github.com/mailru/FileAPI 前言原本打算是操作本地文件,如打开文件,新建文件,保存文件.但好像js是无法坐到这些的. 只能通过一些特别的手段达到一定的效果而已. 这个组件就是搜索时找到的,主要是通过上传时得到文件一些信息,他主要用作图片上传, 文件上传时获得相关内容.而且他还能操作摄像头用于头像. 并且他还有个jquery的插件,主要用处也是上传头像时的相关操作. 一些经验因为不符合我的需求所以没太深入研究,只是测试下了获得上传文件内容. 把项目下载下来后,把下个文件放在根目录里就可以了. 还有一点注意,必须放在php环境里,要不会出错. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no, width=400, initial-scale=0.8, maximum-scale=0.8&quot; /&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;yes&quot; /&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt; &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot; /&gt; &lt;script&gt; // Объект настройки var FileAPI = &#123; debug: true, // режим отладки staticPath: &#x27;./&#x27; // путь до флешек &#125;; &lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;dist/FileAPI.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;file&quot; name=&#x27;my-input&#x27; id=&#x27;singleFile&#x27;&gt; &lt;script&gt; (function ()&#123; FileAPI.event.on(singleFile,&#x27;change&#x27; ,function (evt/**Event*/)&#123; // Retrieve file list var files = FileAPI.getFiles(singleFile); if( files.length )&#123; FileAPI.each(files, function (file)&#123; FileAPI.readAsText(file, &quot;utf-8&quot;, function (evt/**Object*/)&#123; if( evt.type == &#x27;load&#x27; )&#123; // Success var text = evt.result; //console.log(text); alert(text); &#125; else if( evt.type ==&#x27;progress&#x27; )&#123; var pr = evt.loaded/evt.total * 100; console.log(pr); &#125; &#125;); &#125;); &#125; &#125;); &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://elickzhao.github.io/tags/JavaScript/"}]},{"title":"Editor.md Examples 不错的在线编辑MD文件工具","slug":"Editor.md Examples 不错的在线编辑MD文件工具","date":"2016-05-30T15:04:54.000Z","updated":"2021-09-09T16:34:44.900Z","comments":true,"path":"2016/05/Editor.md Examples 不错的在线编辑MD文件工具/","link":"","permalink":"http://elickzhao.github.io/2016/05/Editor.md%20Examples%20%E4%B8%8D%E9%94%99%E7%9A%84%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91MD%E6%96%87%E4%BB%B6%E5%B7%A5%E5%85%B7/","excerpt":"","text":"项目主页:https://pandao.github.io/editor.md/ 先简单说两点: 可以不借助php环境使用 因为主要基于js的 但是有些插件却是必须使用php环境,比如 emoji,preformatted-text 这两个, 一个是标签 一个html图形 目前来说他只能在线编辑,却不能保存和打开文件 这个我想加上","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"laravel 安装 (windows)","slug":"laravel 安装 (windows)","date":"2016-05-29T13:05:10.000Z","updated":"2021-09-09T16:34:45.251Z","comments":true,"path":"2016/05/laravel 安装 (windows)/","link":"","permalink":"http://elickzhao.github.io/2016/05/laravel%20%E5%AE%89%E8%A3%85%20(windows)/","excerpt":"","text":"第一步 安装composer 从这里 https://getcomposer.org/download/ 后直接安装即可 切记需先安装php 并且版本支持做开发项目 第二步 配置composer镜像仓库composer config -g repo.packagist composer https://packagist.phpcomposer.com输入这行代码即可 你可以在任意位置打开命令窗口输入 这样就是全局配置当如你也可以进入项目根目录 在那里打开命令窗口输入 这样就是那个项目的配置而不是全局的 以后开发项目年还有选择的机会 第三步 安装laravelcomposer create-project laravel/laravel myapp --prefer-dist使用这句就可以创建新的项目 myapp为指定目录如果遇到报错 请用 composer selfupdate 更新一下 然后尝试安装以上你的laravel项目已经建立完成 那么动手写吧 必要补充你也可以使用laravel安装器 然后通过安装器来建立新的项目composer global require &quot;laravel/installer=~1.1&quot;使用上面代码安装laravel安装器并确保 C:\\Users\\ 你用户名\\AppData\\Roaming\\Composer\\vendor\\bin或者 C:\\ProgramData\\ComposerSetup\\bin 因为我当前机器的系统环境变量是这里下面有laravel.bat这个文件接下来你就可以使用laravel new blog来建立项目了 blog为你的项目名 好了 就是这些 开始码代码吧","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"Laravel项目 基本开发流程","slug":"Laravel项目 基本开发流程","date":"2016-05-28T14:20:20.000Z","updated":"2021-09-09T16:34:44.963Z","comments":true,"path":"2016/05/Laravel项目 基本开发流程/","link":"","permalink":"http://elickzhao.github.io/2016/05/Laravel%E9%A1%B9%E7%9B%AE%20%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/","excerpt":"###用composer建立项目莫名其妙的5.1.11的库文件少了 vendor 这个目录所以拿composer无法创建了 只好创建5.2 或者下载一键安装包 1composer create-project laravel/laravel myapp --prefer-dist ###配置项目环境 配置数据连接 打开.env文件进行配置 (这个必须先行配置 要不下面插件安装会提示错误) 还有就是config里的database.php的配置文件一般是用于多数据库连接时在里面进行修改 初始化composer 在配置里搜索composer然后把 composer.phar地址填写进去 没有的话 就按照提示下载一个或者安装一下 (C:\\ProgramData\\ComposerSetup\\bin\\composer.phar 这是我的位置仅供参考)然后点确定初始化完成 配置Command Line Tool Support 1 点击添加 选择Tool based on Symfony Console 确定 2 起一个别名 然后添加脚本地址 也就是artisan所在位置 如果php.exe不在运行环境里 那也得选择地址 3 完成后可以点编辑选择是当前项目下使用 还是全局使用(上次我是选择当期项目下 这次新建立项目就又装了一遍 这次我选全局了 看看下次开项目是不是还用再装一遍 已经正事了是全局的 第二次不用配置了 看来我又错了 虽然为全局的不用安装 但是命令还在那个命名空间 所以生成的文件还在老的项目里 而不能生成在新的项目所以没用) 4 配置文件可以复制进去 但是必须替换里面的项目名 要不会报错##注意Command Line Tool Support 在laravel 5.2里配置artisan会报错 具体原因不明 也许是我的phpstorm版本的问题 我这个一直没升级 还是10.0.1 其实命令是好使的在cmd里 只不过还得输入那么多 所以项目降级到laravel 5.1了 这次遇到的麻烦太多了 5.1还不能用composer生成线上的库不知道什么问题缺少vendor 所以只能用一键安装包来新建项目 而且5.2插件支持也变了所以原本打算用5.2最后也是放弃了","text":"###用composer建立项目莫名其妙的5.1.11的库文件少了 vendor 这个目录所以拿composer无法创建了 只好创建5.2 或者下载一键安装包 1composer create-project laravel/laravel myapp --prefer-dist ###配置项目环境 配置数据连接 打开.env文件进行配置 (这个必须先行配置 要不下面插件安装会提示错误) 还有就是config里的database.php的配置文件一般是用于多数据库连接时在里面进行修改 初始化composer 在配置里搜索composer然后把 composer.phar地址填写进去 没有的话 就按照提示下载一个或者安装一下 (C:\\ProgramData\\ComposerSetup\\bin\\composer.phar 这是我的位置仅供参考)然后点确定初始化完成 配置Command Line Tool Support 1 点击添加 选择Tool based on Symfony Console 确定 2 起一个别名 然后添加脚本地址 也就是artisan所在位置 如果php.exe不在运行环境里 那也得选择地址 3 完成后可以点编辑选择是当前项目下使用 还是全局使用(上次我是选择当期项目下 这次新建立项目就又装了一遍 这次我选全局了 看看下次开项目是不是还用再装一遍 已经正事了是全局的 第二次不用配置了 看来我又错了 虽然为全局的不用安装 但是命令还在那个命名空间 所以生成的文件还在老的项目里 而不能生成在新的项目所以没用) 4 配置文件可以复制进去 但是必须替换里面的项目名 要不会报错##注意Command Line Tool Support 在laravel 5.2里配置artisan会报错 具体原因不明 也许是我的phpstorm版本的问题 我这个一直没升级 还是10.0.1 其实命令是好使的在cmd里 只不过还得输入那么多 所以项目降级到laravel 5.1了 这次遇到的麻烦太多了 5.1还不能用composer生成线上的库不知道什么问题缺少vendor 所以只能用一键安装包来新建项目 而且5.2插件支持也变了所以原本打算用5.2最后也是放弃了 ###给phpstrom安装插件 Laravel plugin 1234//phpstrom自带插件在配置里的plugins里搜索Laravel就开会出现了 (这个能提示大多数代码)//注意有个问题 虽然可以不用重新安装 但是没打开一个新的项目就得重新激活一下// 设置 -&gt; 其他设置 -&gt; laravel plugin -&gt; Enable plugin for this project//这样这个插件才好使 Laravel-ide-helper 123456789101112//安装程序composer require barryvdh/laravel-ide-helper//配置文件到 config &gt; app.php &gt; 服务数组里Barryvdh\\LaravelIdeHelper\\IdeHelperServiceProvider::class,//生成提示文件 这样一些静态命令才会有提示php artisan ide-helper:generate//在composer.json里 添加更新时命令 (为确保提示为最新的 当加载程序变更时 自动重启生成 顺序不能变) &quot;pre-update-cmd&quot;: [ &quot;php artisan clear-compiled&quot;, &quot;php artisan ide-helper:generate&quot;, &quot;php artisan optimize&quot; ], illuminate/html这个包在laravel 5.2下换名了 所以不能用下面那个地址了 改成了 &quot;laravelcollective/html&quot;: &quot;5.2.*&quot; 包的位置也换成了 Collective\\Html\\ 123456789101112131415//安装程序composer require illuminate/html:^5.0//配置程序Illuminate\\Html\\HtmlServiceProvider::class,//设置门面别名 也就是app.php配置文件里的aliases数组里 感觉设置一个就行了 两个都是相同的&#x27;Form&#x27; =&gt; Illuminate\\Html\\FormFacade::class,&#x27;Html&#x27; =&gt; Illuminate\\Html\\HtmlFacade::class,/*在模版文件里From::不出提示 那是因为直接用了composer require这样直接安装 而不是使用写在composer.json里用 update安装 所以ide-helper命令没有执行解决办法:手动update一下,或者ide-helper命令一下 提示就会出现了还有个一劳永逸的方法就是 把这个命令再放到 &quot;pre-install-cmd&quot; 数组里 这样安装的时候也自动执行了*/ Laravel Debugbar 123456//安装程序composer require barryvdh/laravel-debugbar//配置程序Barryvdh\\Debugbar\\ServiceProvider::class,//配置门面别名&#x27;Debugbar&#x27; =&gt; Barryvdh\\Debugbar\\Facade::class, 配置Command Line Tool Support官方参考文档 123#上面已经配置好了 就可以直接用了 使用Ctrl+Shift+X调用Command Line工具 在里面直接输入artisan命令 可以提示和补全 很方便#还有个问题是自定义命令的话 是不会加到提示里的比如我自己加的make:view(已经确定可以加提示) 但是可以自己手动添加提示 就在配置页面的open definition on editor这个选项 就是右侧第四个 点开这个就会出现一个xml文件 按着格式把命令填进去后面就可以使用了#以后也许可以写个程序自动添加进去 ###建立数据库数据库已经在上面环境配置建立完毕,现在开始建立所需要的表 建立模型 12345678910111213141516//用命令直接建立模型和数据库迁移artisan make:model Model/Task -m//修改迁移文件#2016_03_17_085421_create_tasks_table.php public function up() &#123; Schema::create(&#x27;tasks&#x27;, function (Blueprint $table) &#123; $table-&gt;increments(&#x27;id&#x27;); $table-&gt;string(&#x27;name&#x27;); //增加个字段name $table-&gt;timestamps(); &#125;); &#125;//执行迁移命令artisan migrate 编写路由 编写模版","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"linux下tree命令","slug":"linux下tree命令","date":"2016-05-27T04:47:57.000Z","updated":"2021-09-09T16:34:45.291Z","comments":true,"path":"2016/05/linux下tree命令/","link":"","permalink":"http://elickzhao.github.io/2016/05/linux%E4%B8%8Btree%E5%91%BD%E4%BB%A4/","excerpt":"","text":"前言windows下是有tree命令的,可以打印出目录结构.但是linux下却不是默认安装的. Note:准确的说是ubuntu下没有,因为其他发行版本我还没有试过. 首先安装 tree1sudo apt-get install tree 简单使用123456789# 星号代表层级数,想看到那层写那个,默认全都显示.# 而且不想windows只显示目录,默认是会显示目录和文件tree -L * # 只显示目录 不显示文件tree -d # 更多说明看这个吧 都很简单tree --help ##文章参考:linux tree命令以树形结构显示文件目录结构","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"}]},{"title":"现代 PHP 新特性系列 —— 善用接口","slug":"现代 PHP 新特性系列 —— 善用接口","date":"2016-05-26T10:24:15.000Z","updated":"2021-09-09T16:34:45.690Z","comments":true,"path":"2016/05/现代 PHP 新特性系列 —— 善用接口/","link":"","permalink":"http://elickzhao.github.io/2016/05/%E7%8E%B0%E4%BB%A3%20PHP%20%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%20%E2%80%94%E2%80%94%20%E5%96%84%E7%94%A8%E6%8E%A5%E5%8F%A3/","excerpt":"前言接口一直让我很晕,下面这篇文章有了很好的说明.现代 PHP 新特性系列（二） —— 善用接口这里我就再简单化下,以便我能快速记忆. 简要说明接口说直观点就是模具,或者说API API说说他像API,是因为他提出来所有功能.你知道接口有什么,你就知道你能做什么了 模具说说他像模具,是因为接口的功能是统一的,一致的.但是实现的方法可以不同.就像你做一个花瓶的模具,但是根据填充的材料不同,可以做出不同的花瓶.什么玻璃的,陶瓷的,珐琅的.虽然他们长的都一个样. 接口的作用所以接口的作用,就是解耦. 比如一个DB类流程: DB操作类,根据DB接口提供的功能,进行具体功能开发. DB实例化的时候,必须传入符合DB接口的DB驱动类.(符合接口保证功能可用,而且不符合接口也会报错) DB操作类,根据传入不同DB驱动实例,达到解耦的作用.(因为功能名称都是统一的)","text":"前言接口一直让我很晕,下面这篇文章有了很好的说明.现代 PHP 新特性系列（二） —— 善用接口这里我就再简单化下,以便我能快速记忆. 简要说明接口说直观点就是模具,或者说API API说说他像API,是因为他提出来所有功能.你知道接口有什么,你就知道你能做什么了 模具说说他像模具,是因为接口的功能是统一的,一致的.但是实现的方法可以不同.就像你做一个花瓶的模具,但是根据填充的材料不同,可以做出不同的花瓶.什么玻璃的,陶瓷的,珐琅的.虽然他们长的都一个样. 接口的作用所以接口的作用,就是解耦. 比如一个DB类流程: DB操作类,根据DB接口提供的功能,进行具体功能开发. DB实例化的时候,必须传入符合DB接口的DB驱动类.(符合接口保证功能可用,而且不符合接口也会报错) DB操作类,根据传入不同DB驱动实例,达到解耦的作用.(因为功能名称都是统一的) 大致如下图: 代码参考 用的不是DB的例子Store类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?phpnamespace Illuminate\\Contracts\\Cache;interface Store&#123; /** * Retrieve an item from the cache by key. * * @param string|array $key * @return mixed */ public function get($key); /** * Retrieve multiple items from the cache by key. * * Items not found in the cache will have a null value. * * @param array $keys * @return array */ public function many(array $keys); /** * Store an item in the cache for a given number of minutes. * * @param string $key * @param mixed $value * @param int $minutes * @return void */ public function put($key, $value, $minutes); /** * Store multiple items in the cache for a given number of minutes. * * @param array $values * @param int $minutes * @return void */ public function putMany(array $values, $minutes); /** * Increment the value of an item in the cache. * * @param string $key * @param mixed $value * @return int|bool */ public function increment($key, $value = 1); /** * Decrement the value of an item in the cache. * * @param string $key * @param mixed $value * @return int|bool */ public function decrement($key, $value = 1); /** * Store an item in the cache indefinitely. * * @param string $key * @param mixed $value * @return void */ public function forever($key, $value); /** * Remove an item from the cache. * * @param string $key * @return bool */ public function forget($key); /** * Remove all items from the cache. * * @return void */ public function flush(); /** * Get the cache key prefix. * * @return string */ public function getPrefix();&#125; MemcachedStore类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;?phpnamespace Illuminate\\Cache;use Memcached;use Illuminate\\Contracts\\Cache\\Store;class MemcachedStore extends TaggableStore implements Store&#123; /** * The Memcached instance. * * @var \\Memcached */ protected $memcached; /** * A string that should be prepended to keys. * * @var string */ protected $prefix; /** * Create a new Memcached store. * * @param \\Memcached $memcached * @param string $prefix * @return void */ public function __construct($memcached, $prefix = &#x27;&#x27;) &#123; $this-&gt;setPrefix($prefix); $this-&gt;memcached = $memcached; &#125; /** * Retrieve an item from the cache by key. * * @param string|array $key * @return mixed */ public function get($key) &#123; $value = $this-&gt;memcached-&gt;get($this-&gt;prefix.$key); if ($this-&gt;memcached-&gt;getResultCode() == 0) &#123; return $value; &#125; &#125; /** * Retrieve multiple items from the cache by key. * * Items not found in the cache will have a null value. * * @param array $keys * @return array */ public function many(array $keys) &#123; $prefixedKeys = array_map(function ($key) &#123; return $this-&gt;prefix.$key; &#125;, $keys); $values = $this-&gt;memcached-&gt;getMulti($prefixedKeys, null, Memcached::GET_PRESERVE_ORDER); if ($this-&gt;memcached-&gt;getResultCode() != 0) &#123; return array_fill_keys($keys, null); &#125; return array_combine($keys, $values); &#125; /** * Store an item in the cache for a given number of minutes. * * @param string $key * @param mixed $value * @param int $minutes * @return void */ public function put($key, $value, $minutes) &#123; $this-&gt;memcached-&gt;set($this-&gt;prefix.$key, $value, $minutes * 60); &#125; /** * Store multiple items in the cache for a given number of minutes. * * @param array $values * @param int $minutes * @return void */ public function putMany(array $values, $minutes) &#123; $prefixedValues = []; foreach ($values as $key =&gt; $value) &#123; $prefixedValues[$this-&gt;prefix.$key] = $value; &#125; $this-&gt;memcached-&gt;setMulti($prefixedValues, $minutes * 60); &#125; /** * Store an item in the cache if the key doesn&#x27;t exist. * * @param string $key * @param mixed $value * @param int $minutes * @return bool */ public function add($key, $value, $minutes) &#123; return $this-&gt;memcached-&gt;add($this-&gt;prefix.$key, $value, $minutes * 60); &#125; /** * Increment the value of an item in the cache. * * @param string $key * @param mixed $value * @return int|bool */ public function increment($key, $value = 1) &#123; return $this-&gt;memcached-&gt;increment($this-&gt;prefix.$key, $value); &#125; /** * Decrement the value of an item in the cache. * * @param string $key * @param mixed $value * @return int|bool */ public function decrement($key, $value = 1) &#123; return $this-&gt;memcached-&gt;decrement($this-&gt;prefix.$key, $value); &#125; /** * Store an item in the cache indefinitely. * * @param string $key * @param mixed $value * @return void */ public function forever($key, $value) &#123; $this-&gt;put($key, $value, 0); &#125; /** * Remove an item from the cache. * * @param string $key * @return bool */ public function forget($key) &#123; return $this-&gt;memcached-&gt;delete($this-&gt;prefix.$key); &#125; /** * Remove all items from the cache. * * @return void */ public function flush() &#123; $this-&gt;memcached-&gt;flush(); &#125; /** * Get the underlying Memcached connection. * * @return \\Memcached */ public function getMemcached() &#123; return $this-&gt;memcached; &#125; /** * Get the cache key prefix. * * @return string */ public function getPrefix() &#123; return $this-&gt;prefix; &#125; /** * Set the cache key prefix. * * @param string $prefix * @return void */ public function setPrefix($prefix) &#123; $this-&gt;prefix = ! empty($prefix) ? $prefix.&#x27;:&#x27; : &#x27;&#x27;; &#125;&#125; CacheStore类 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App\\Tests;use Illuminate\\Contracts\\Cache\\Store;class CacheStore&#123; protected $store; public function __construct(Store $store) &#123; $this-&gt;store = $store; &#125; public function get($key) &#123; return $this-&gt;store-&gt;get($key); &#125; public function put($key, $value, $minutes=1) &#123; $this-&gt;store-&gt;put($key, $value, $minutes); &#125; public function forget($key) &#123; $this-&gt;store-&gt;forever($key); &#125; public function flush() &#123; $this-&gt;store-&gt;flush(); &#125;&#125; 使用CacheStore类 123456$memcached = new \\Memcached();$memcached-&gt;addServer(&#x27;localhost&#x27;,11211);$memcachedCache = new MemcachedStore($memcached);$cacheStore = new CacheStore($memcachedCache);$cacheStore-&gt;put(&#x27;site&#x27;,&#x27;http://LaravelAcademy.org&#x27;);dd($cacheStore-&gt;get(&#x27;site&#x27;));","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"laravel框架加载流程","slug":"laravel框架加载流程","date":"2016-05-25T16:30:10.000Z","updated":"2021-09-09T16:34:45.271Z","comments":true,"path":"2016/05/laravel框架加载流程/","link":"","permalink":"http://elickzhao.github.io/2016/05/laravel%E6%A1%86%E6%9E%B6%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/","excerpt":"","text":"public/index.php 此文件会加载由 Composer 生成的自动加载器定义并获取由 bootstrap/app.php 文件中所生成的 Laravel 应用程序实例 bootstrap/app.php 生成Laravel应用程序实例 $app并且绑定核心 App\\Http\\Kernel::class 或 App\\Console\\Kernel::class这取决于请求类型 在这里请求经过一些列操作 最终返回浏览器 app/Http/Kernel.php 一般情况是 HTTP 请求,所以主要说些这个这个类继承自 Illuminate\\Foundation\\Http\\Kernel 它定义了一个 bootstrappers 数组，在请求被运行前会先行运作。这些启动器设置了错误处理、日志记录、侦测应用程序环境，并运行其它需要在请求实际处理前就该被完成掉的工作。其实这个过程就是 启动框架的服务提供者 -&gt; Illuminate\\Foundation\\Bootstrap\\BootProviders 这个继承自 Illuminate\\Contracts\\Foundation\\Application 但是实现却是一开始的 Illuminate\\Foundation\\Application 也就是创建框架实例那个文件里 有这个方法 (有点搞不懂 继承自一个接口,接口没有功能,自己也没有功能,而下面实现这个功能的又没有继承他 那如何找到这个功能的呢) 看这里接口说明app/Http/Kernel.phpHTTP 核心也定义了一份 HTTP 中间件 清单，所有的请求在被应用程序处理之前都必须经过它们。这些中间件处理 HTTP session 的读写、验证 CSRF 令牌、决定应用程序是否处于维护模式，以及其它更多任务作。 router 所有服务提供者加载完毕后,把request请求转移给router路由器经过router分派给route(路由)或者controller,并运行中间件处理后返回response(响应) 整个启动流程,主要涉及的几个文件如下public/index.php,bootstrap/app.php,app/Http/Kernel.php,除了Kernel另外两个文件去掉注释,基本很简洁 public/index.php 1234567891011121314151617//引入composer自动加载程序require __DIR__.&#x27;/../bootstrap/autoload.php&#x27;;//启动框架,生成应用程序$app = require_once __DIR__.&#x27;/../bootstrap/app.php&#x27;;//运行应用程序,接收Request请求$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);//经过路由器分发到路由,控制器,中间件的处理返回Response$response = $kernel-&gt;handle( $request = Illuminate\\Http\\Request::capture());//发送响应到浏览器$response-&gt;send();//销毁请求与响应$kernel-&gt;terminate($request, $response); bootstrap/app.php 12345678910111213141516171819202122232425&lt;?php//创建应用程序$app = new Illuminate\\Foundation\\Application( realpath(__DIR__.&#x27;/../&#x27;));//重要的接口绑定 (会根据不同请求,做不同响应.所以主要说下Http)$app-&gt;singleton( Illuminate\\Contracts\\Http\\Kernel::class, App\\Http\\Kernel::class);$app-&gt;singleton( Illuminate\\Contracts\\Console\\Kernel::class, App\\Console\\Kernel::class);$app-&gt;singleton( Illuminate\\Contracts\\Debug\\ExceptionHandler::class, App\\Exceptions\\Handler::class);//返回应用程序return $app; app/Http/Kernel.php 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\Http;use Illuminate\\Foundation\\Http\\Kernel as HttpKernel;//这里需要说明下,Kernel继承自HttpKernel也就是框架基础核心.//基础核心主要作用就是,加载这里配置的中间件,还有就是启动框架的各种服务//因为该文件内容较多就不展示了,可以自己稍微看一下class Kernel extends HttpKernel&#123; //设置了全局中间件 protected $middleware = [ \\Illuminate\\Foundation\\Http\\Middleware\\CheckForMaintenanceMode::class, \\App\\Http\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\VerifyCsrfToken::class, ]; //设置了路由中间件 protected $routeMiddleware = [ &#x27;auth&#x27; =&gt; \\App\\Http\\Middleware\\Authenticate::class, &#x27;auth.basic&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, &#x27;guest&#x27; =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, &#x27;test&#x27;=&gt; \\App\\Http\\Middleware\\TestMiddleware::class, &#x27;mi&#x27;=&gt; \\App\\Http\\Middleware\\MiMiddleware::class, ];&#125; 结合图片就大致了解,laravel的启动过程. 通过上面注释文件,估计大多数悟性爆表的同学已经明白整个过程了.还有极少数晕乎少年没有明白.这里再多说几句. 其实整个流程就三部 全部在index.php这个文件里 启动框架 这个是由 app.php做到的 并准备好中间 服务待用 创建http内核 响应请求","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"XSS 和 CSRF 跨站攻击","slug":"XSS 和 CSRF 跨站攻击","date":"2016-05-25T15:13:42.000Z","updated":"2021-09-09T16:34:45.073Z","comments":true,"path":"2016/05/XSS 和 CSRF 跨站攻击/","link":"","permalink":"http://elickzhao.github.io/2016/05/XSS%20%E5%92%8C%20CSRF%20%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/","excerpt":"","text":"xss 编辑跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的 主要防范:过滤客户提交内容,不能信任客户提交内容.目前来看chrome浏览器能够自己屏蔽这个问题.IE还是不行,还得需要强壮的代码. CSRFCSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 主要防范:CSRF主要是伪装请求,所以只要确认不是本站请求,就可以很好的化解这个问题.对于每个表单提交都有个token,然后提交的地址再去验证这个token就可以了 参考文献:XSS跨站脚本攻击过程最简单演示","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://elickzhao.github.io/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"http://elickzhao.github.io/tags/CSRF/"}]},{"title":"laravel 简单自定义个artisan命令","slug":"laravel 简单自定义个artisan命令","date":"2016-05-23T16:11:59.000Z","updated":"2021-09-09T16:34:45.257Z","comments":true,"path":"2016/05/laravel 简单自定义个artisan命令/","link":"","permalink":"http://elickzhao.github.io/2016/05/laravel%20%E7%AE%80%E5%8D%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AAartisan%E5%91%BD%E4%BB%A4/","excerpt":"###参考 artisan make:model 而写的 make:view 新建blade模版 MakeView.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?phpnamespace App\\Console\\Commands;use Illuminate\\Console\\Command;use Illuminate\\Filesystem\\Filesystem;class MakeView extends Command&#123; /** * The name and signature of the console command. * * @var string */ protected $signature = &#x27;make:view &#123;name : like content or article/content&#125;&#x27;; /** * The console command description. * * @var string */ protected $description = &#x27;Create a new blade page&#x27;; /** * The type of class being generated. * * @var string */ protected $type; /** * 文件系统 * @var Filesystem */ protected $files; /** * Create a new command instance. * * @return void */ public function __construct(Filesystem $files) &#123; parent::__construct(); $this-&gt;files=$files; &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; // $path = $this-&gt;getPath($this-&gt;argument(&#x27;name&#x27;)); if($this-&gt;alreadyExists($path))&#123; $this-&gt;error($this-&gt;type.&#x27; already exists!&#x27;); return false; &#125; $this-&gt;makeDir($path); $this-&gt;files-&gt;put($path, $this-&gt;getStub()); return $this-&gt;info($this-&gt;type.&#x27; created successfully.&#x27;); &#125; /** * Get path * @param string $name * @return string */ protected function getPath($name)&#123; return base_path(&#x27;resources/views&#x27;).&quot;/&quot;.$name.&quot;.blade.php&quot;; &#125; /** * 模版是否已经存在 * @param $path * @return bool */ protected function alreadyExists($path)&#123; return $this-&gt;files-&gt;exists($path); &#125; /** * 建立目录 * @param $path */ protected function makeDir($path)&#123; if (! $this-&gt;files-&gt;isDirectory(dirname($path))) &#123; $this-&gt;files-&gt;makeDirectory(dirname($path), 0777, true, true); &#125; &#125; /** * 获得模版内容 * @param string $stub //现在默认为bootstrap风格 以后还可以添加妹子UI风格模版等等 * @return string * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException */ protected function getStub($stub=&#x27;view.stub&#x27;)&#123; return $this-&gt;files-&gt;get(__DIR__.&#x27;/stubs/&#x27;.$stub); &#125;&#125;","text":"###参考 artisan make:model 而写的 make:view 新建blade模版 MakeView.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?phpnamespace App\\Console\\Commands;use Illuminate\\Console\\Command;use Illuminate\\Filesystem\\Filesystem;class MakeView extends Command&#123; /** * The name and signature of the console command. * * @var string */ protected $signature = &#x27;make:view &#123;name : like content or article/content&#125;&#x27;; /** * The console command description. * * @var string */ protected $description = &#x27;Create a new blade page&#x27;; /** * The type of class being generated. * * @var string */ protected $type; /** * 文件系统 * @var Filesystem */ protected $files; /** * Create a new command instance. * * @return void */ public function __construct(Filesystem $files) &#123; parent::__construct(); $this-&gt;files=$files; &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; // $path = $this-&gt;getPath($this-&gt;argument(&#x27;name&#x27;)); if($this-&gt;alreadyExists($path))&#123; $this-&gt;error($this-&gt;type.&#x27; already exists!&#x27;); return false; &#125; $this-&gt;makeDir($path); $this-&gt;files-&gt;put($path, $this-&gt;getStub()); return $this-&gt;info($this-&gt;type.&#x27; created successfully.&#x27;); &#125; /** * Get path * @param string $name * @return string */ protected function getPath($name)&#123; return base_path(&#x27;resources/views&#x27;).&quot;/&quot;.$name.&quot;.blade.php&quot;; &#125; /** * 模版是否已经存在 * @param $path * @return bool */ protected function alreadyExists($path)&#123; return $this-&gt;files-&gt;exists($path); &#125; /** * 建立目录 * @param $path */ protected function makeDir($path)&#123; if (! $this-&gt;files-&gt;isDirectory(dirname($path))) &#123; $this-&gt;files-&gt;makeDirectory(dirname($path), 0777, true, true); &#125; &#125; /** * 获得模版内容 * @param string $stub //现在默认为bootstrap风格 以后还可以添加妹子UI风格模版等等 * @return string * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException */ protected function getStub($stub=&#x27;view.stub&#x27;)&#123; return $this-&gt;files-&gt;get(__DIR__.&#x27;/stubs/&#x27;.$stub); &#125;&#125; view.stub 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;New Page&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; ##注意 想要自定义参数 比如短参数必须使用两个方法 getArguments() 和 getOptions() ###补充 又看了遍源码 找到更方便的方法 这个文档里没有写 所以下面两种方法都可以 1234//直接设置属性就可以了 切记短参数放在前面用 | 分割protected $signature = &#x27;make:view &#123;name : like content or article/content&#125; &#123;--l | layout : create new layout&#125;&#x27;;//这里还要注意一点是 在Parser.php 里的 $matches = preg_split(&#x27;/\\s*\\|\\s*/&#x27;, $token, 2); 中间的 \\| 是转义成了 | 字符 不要在忽略 认为是或了 给自己提个醒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;?php/** * Created by elick. * Class: MakeView * Date: 2016/3/16 * Time: 18:28 * Description: Brief description */namespace App\\Console\\Commands;use Illuminate\\Console\\Command;use Illuminate\\Filesystem\\Filesystem;//引入相关类use Symfony\\Component\\Console\\Input\\InputArgument;use Symfony\\Component\\Console\\Input\\InputOption;class MakeView extends Command&#123; //这里特别注意 取消了 $signature 这个属性 使用$name否则下面两个方法都不好使 protected $name = &#x27;make:view&#x27;; /** * The console command description. * * @var string */ protected $description = &#x27;Create a new blade page&#x27;; /** * The type of class being generated. * * @var string */ protected $type = &#x27;View&#x27;; /** * 文件系统 * @var Filesystem */ protected $files; /** * Create a new command instance. * * @return void */ public function __construct(Filesystem $files) &#123; parent::__construct(); $this-&gt;files = $files; &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; //XXX 还有一点就是这里了 handle和fire有啥区别 有空看看那 $path = $this-&gt;getPath($this-&gt;argument(&#x27;name&#x27;)); if ($this-&gt;alreadyExists($path)) &#123; $this-&gt;error($this-&gt;type . &#x27; already exists!&#x27;); return false; &#125; $this-&gt;makeDir($path); $content = $this-&gt;option(&#x27;layout&#x27;) ? $this-&gt;getStub() : &quot;&quot;; $this-&gt;files-&gt;put($path, $content); return $this-&gt;info($this-&gt;type . &#x27; created successfully.&#x27;); &#125; /** * Get path * @param string $name * @return string */ protected function getPath($name) &#123; return base_path(&#x27;resources/views&#x27;) . &quot;/&quot; . $name . &quot;.blade.php&quot;; &#125; /** * 建立目录 * @param $path */ protected function makeDir($path) &#123; if (!$this-&gt;files-&gt;isDirectory(dirname($path))) &#123; $this-&gt;files-&gt;makeDirectory(dirname($path), 0777, true, true); &#125; &#125; /** * 获得模版内容 * @param string $stub //现在默认为bootstrap风格 以后还可以添加妹子UI风格模版等等 * @return string * @throws \\Illuminate\\Contracts\\Filesystem\\FileNotFoundException */ protected function getStub($stub = &#x27;view.stub&#x27;) &#123; return $this-&gt;files-&gt;get(__DIR__ . &#x27;/stubs/&#x27; . $stub); &#125; /** * 模版是否已经存在 * @param $path * @return bool */ protected function alreadyExists($path) &#123; return $this-&gt;files-&gt;exists($path); &#125; protected function getArguments() &#123; return [ [&#x27;name&#x27;, InputArgument::REQUIRED, &#x27;The name of the class&#x27;], ]; &#125; protected function getOptions() &#123; return [ [&#x27;layout&#x27;, &#x27;l&#x27;, InputOption::VALUE_NONE, &#x27;Create a new migration file for the model.&#x27;], ]; &#125;&#125;","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"laravel 包开发的一些思路","slug":"laravel 包开发的一些思路","date":"2016-05-21T14:52:28.000Z","updated":"2021-09-09T16:34:45.249Z","comments":true,"path":"2016/05/laravel 包开发的一些思路/","link":"","permalink":"http://elickzhao.github.io/2016/05/laravel%20%E5%8C%85%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/","excerpt":"ContactServiceProvider 服务提供者 这里面 registerContact() 其实是没用的 应该是调用其他服务功能时才有用.但是这个简单功能完全可通过router和controller完全能实现所以 感觉不需要写个什么服务了.暂时这么理解吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php namespace Jai\\Contact;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Routing\\Router;class ContactServiceProvider extends ServiceProvider&#123; protected $defer = false; public function boot() &#123; //注册模版地址 这里一定要使用realpath() 不是绝对路径就会出错 $this-&gt;loadViewsFrom(realpath(__DIR__.&#x27;/../views&#x27;), &#x27;contact&#x27;); //注册包路由 $this-&gt;setupRoutes($this-&gt;app-&gt;router); // this for conig $this-&gt;publishes([ __DIR__.&#x27;/config/contact.php&#x27; =&gt; config_path(&#x27;contact.php&#x27;), ]); &#125; /** * Define the routes for the application. * * @param \\Illuminate\\Routing\\Router $router * @return void */ public function setupRoutes(Router $router) &#123; //设置路由命名空间 $router-&gt;group([&#x27;namespace&#x27; =&gt; &#x27;Jai\\Contact\\Http\\Controllers&#x27;], function($router) &#123; require __DIR__.&#x27;/Http/routes.php&#x27;; &#125;); &#125; public function register() &#123; $this-&gt;registerContact(); config([ &#x27;config/contact.php&#x27;, ]); //这两句是从stripe里摘出来的 绑定名称 以后注入用 $this-&gt;app-&gt;singleton(&#x27;command.cashier.table&#x27;, function ($app) &#123; return new CashierTableCommand; &#125;); //这里相当于注册一个command命令 参数:这里就用到上边的绑定注入了 $this-&gt;commands(&#x27;command.cashier.table&#x27;); &#125; private function registerContact() &#123; $this-&gt;app-&gt;bind(&#x27;contact&#x27;,function($app)&#123; //这个绑定毫无意义 也许可能是没有用到 //return new Contact($app); return new elick($app); &#125;); &#125;&#125;","text":"ContactServiceProvider 服务提供者 这里面 registerContact() 其实是没用的 应该是调用其他服务功能时才有用.但是这个简单功能完全可通过router和controller完全能实现所以 感觉不需要写个什么服务了.暂时这么理解吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php namespace Jai\\Contact;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Routing\\Router;class ContactServiceProvider extends ServiceProvider&#123; protected $defer = false; public function boot() &#123; //注册模版地址 这里一定要使用realpath() 不是绝对路径就会出错 $this-&gt;loadViewsFrom(realpath(__DIR__.&#x27;/../views&#x27;), &#x27;contact&#x27;); //注册包路由 $this-&gt;setupRoutes($this-&gt;app-&gt;router); // this for conig $this-&gt;publishes([ __DIR__.&#x27;/config/contact.php&#x27; =&gt; config_path(&#x27;contact.php&#x27;), ]); &#125; /** * Define the routes for the application. * * @param \\Illuminate\\Routing\\Router $router * @return void */ public function setupRoutes(Router $router) &#123; //设置路由命名空间 $router-&gt;group([&#x27;namespace&#x27; =&gt; &#x27;Jai\\Contact\\Http\\Controllers&#x27;], function($router) &#123; require __DIR__.&#x27;/Http/routes.php&#x27;; &#125;); &#125; public function register() &#123; $this-&gt;registerContact(); config([ &#x27;config/contact.php&#x27;, ]); //这两句是从stripe里摘出来的 绑定名称 以后注入用 $this-&gt;app-&gt;singleton(&#x27;command.cashier.table&#x27;, function ($app) &#123; return new CashierTableCommand; &#125;); //这里相当于注册一个command命令 参数:这里就用到上边的绑定注入了 $this-&gt;commands(&#x27;command.cashier.table&#x27;); &#125; private function registerContact() &#123; $this-&gt;app-&gt;bind(&#x27;contact&#x27;,function($app)&#123; //这个绑定毫无意义 也许可能是没有用到 //return new Contact($app); return new elick($app); &#125;); &#125;&#125; command 命令 这个是把stripe里的CashierTableCommand类直接粘过来.简单的来说 就是在database\\mrigration 创建个迁移文件 然后把内容复制进去 平并且添加这个命令等安装的时候执行这个命令 并执行 artisan migrate 就安装到数据库里了 并不是自动执行一次性完成的$this-&gt;laravel[]里有很多有用的东西 以后得看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpnamespace Laravel\\Cashier;use Illuminate\\Console\\Command;use Symfony\\Component\\Console\\Input\\InputArgument;class CashierTableCommand extends Command&#123; /** * The console command name. * * @var string */ protected $name = &#x27;cashier:table&#x27;; /** * The console command description. * * @var string */ protected $description = &#x27;Create a migration for the Cashier database columns&#x27;; /** * Execute the console command. * * @return void */ public function fire() &#123; //建立迁移文件 $fullPath = $this-&gt;createBaseMigration(); //填充迁移文件内容 file_put_contents($fullPath, $this-&gt;getMigrationStub()); $this-&gt;info(&#x27;Migration created successfully!&#x27;); //刷新autoload $this-&gt;laravel[&#x27;composer&#x27;]-&gt;dumpAutoloads(); &#125; /** * Create a base migration file for the reminders. * * @return string */ protected function createBaseMigration() &#123; $name = &#x27;add_cashier_columns&#x27;; $path = $this-&gt;laravel[&#x27;path.database&#x27;].&#x27;/migrations&#x27;; return $this-&gt;laravel[&#x27;migration.creator&#x27;]-&gt;create($name, $path); &#125; /** * Get the contents of the reminder migration stub. * * @return string */ protected function getMigrationStub() &#123; $stub = file_get_contents(__DIR__.&#x27;/stubs/migration.stub&#x27;); return str_replace(&#x27;cashier_table&#x27;, $this-&gt;argument(&#x27;table&#x27;), $stub); &#125; /** * Get the console command arguments. * * @return array */ protected function getArguments() &#123; return [ [&#x27;table&#x27;, InputArgument::REQUIRED, &#x27;The name of your billable table.&#x27;], ]; &#125;&#125; routes 路由表 上面已经注册了路由地址和命名空间,所以编写路由分配controller就好了 123456789&lt;?php/** * Created by PhpStorm. * User: elick * Date: 2016/4/1 * Time: 18:15 *///因为使用router-&gt;group()这里连命名空间都不用写了Route::get(&#x27;contact&#x27;,&#x27;ContactController@index&#x27;); controller 控制器 这个也很简单 从这个来看 可以使用原本App的模型.但是如何使用自带模型呢?我现在的想法是和config一样通过publishes 把model直接复制到App\\Models下,也许根本不用,因为现在这个composer已经搜索这个目录 也许直接就可以加载放在目录下可以直接加载 只要继承了use Eloquent;use Illuminate\\Database\\Eloquent\\Model;这两个都可以 其实Eloquent 相当于快捷方式 引用的也是下面那个类但是还有个问题就是如果有自定义数据库怎么插入数据库 这个一会实验下安装数据库还没看 找到好的包时看一下通过stripe包 看到他的方法 看上面命令 12345678910111213141516171819202122232425262728293031323334&lt;?php/** * Created by PhpStorm. * User: elick * Date: 2016/4/1 * Time: 18:17 */namespace Jai\\Contact\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Models\\Post;use Illuminate\\Support\\Facades\\Config;use Jai\\Contact\\Models\\Test;use View;class ContactController extends Controller&#123; public function index()&#123; echo __DIR__.&#x27;/../../config&#x27;; echo &quot;&lt;br&gt;&quot;; echo realpath(__DIR__.&#x27;/../../config&#x27;); echo &quot;&lt;br&gt;&quot;; echo &quot;这就是realpath()的区别&quot;; $t = Test::all()-&gt;toArray(); dump($t); $posts = Post::all()-&gt;toArray(); dump($posts); dump(Config::get(&#x27;contact.message&#x27;)); return view(&#x27;contact::contact&#x27;); //eturn View::make(&#x27;contact::contact&#x27;); &#125;&#125; model 1234567891011121314&lt;?php namespace Jai\\Contact\\Models;/** * Created by PhpStorm. * User: elick * Date: 2016/4/5 * Time: 13:55 */use Eloquent;use Illuminate\\Database\\Eloquent\\Model;class Test extends Model&#123;&#125; contact.blad.php 模版 其实模版就没啥写的 就是模版文件 上面的服务提供者provider只要写对路径 剩下就是前端页面的事了 很简单 config 配置文件 这里的配置文件没写什么其实关键也就在于如何调用配置文件 使用Config::get()这个方法 然后判断配置内容 根据内容写出逻辑 12345678910&lt;?php/** * Created by PhpStorm. * User: elick * Date: 2016/4/1 * Time: 18:21 */return [ &quot;message&quot; =&gt; &quot;Welcome to My new package&quot;]; 改写composer.json 这里命名空间一定要搞对,因为服务提供者provider 使用的命名空间是 Jai\\Contact\\ 而他的真实路径是 packages/jai/contact/src 所以要这么写 123456789&quot;autoload&quot;: &#123; &quot;classmap&quot;: [ &quot;database&quot; ], &quot;psr-4&quot;: &#123; &quot;App\\\\&quot;: &quot;app/&quot;, &quot;Jai\\\\Contact\\\\&quot;:&quot;packages/jai/contact/src&quot; &#125;&#125;, 接下来两个命令 12345//更新Composer的autoloadercomposer dump-autoload//将自定义包的配置文件发布到应用根目录的config目录下以便可以访问。php artisan vendor:publish","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"bower 简介","slug":"bower 简介","date":"2016-05-18T08:00:08.000Z","updated":"2021-09-09T16:34:45.107Z","comments":true,"path":"2016/05/bower 简介/","link":"","permalink":"http://elickzhao.github.io/2016/05/bower%20%E7%AE%80%E4%BB%8B/","excerpt":"","text":"详细内容 请参考这篇文章Bower的简单使用教程 bower init 生成 bower.json 这个是项目安装的组件包bower --save XXX 这是本项目安装组件 并记录在bower.json bowerrc文件简单说明 directory:是值第三方依赖包下载所在的位置proxy：在很多公司，为了保护公司内网的安全性，是需要配置这个代理的。所以这里一般要配置公司的代理timeout：默认的连接为60000ms，但是当网速不好的时候，可以设置10分钟，”timeout”:600000还有很多大家可以自行查一查哈","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"bower","slug":"bower","permalink":"http://elickzhao.github.io/tags/bower/"}]},{"title":"bootstrap 该死的IE兼容","slug":"bootstrap 该死的IE兼容","date":"2016-05-17T13:18:46.000Z","updated":"2021-09-09T16:34:45.104Z","comments":true,"path":"2016/05/bootstrap 该死的IE兼容/","link":"","permalink":"http://elickzhao.github.io/2016/05/bootstrap%20%E8%AF%A5%E6%AD%BB%E7%9A%84IE%E5%85%BC%E5%AE%B9/","excerpt":"","text":"前面碎碎念真是不搞页面,不知道弄兼容如此的恶心.当然你一板一眼的写,能避免很多的麻烦,可是利用框架,插件来做,这是烦的要死了. 这次利用了 yoesman+gulp+bower 快速搭建了个项目 其中还用到swiper插件 这个插件 3代主要面对手机 可是有些新特性 2代还没有 真是麻烦 用了3代 兼容性就有麻烦了. 基本解决问题bower里有个很好的插件 bootstrap-ie8 bower install --save bootstrap-ie8 安装好后 他能帮你解决大多数的兼容问题 细微修改IE 9 不兼容 classList 这个属性 所以需要如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445if (!(&quot;classList&quot; in document.documentElement)) &#123; //兼容ie8 HTMLElement window.HTMLElement = window.HTMLElement || Element; //兼容ie9 classlist Object.defineProperty(HTMLElement.prototype, &#x27;classList&#x27;, &#123; get: function() &#123; var self = this; function update(fn) &#123; return function(value) &#123; var classes = self.className.split(/\\s+/g), index = classes.indexOf(value); fn(classes, index, value); self.className = classes.join(&quot; &quot;); &#125; &#125; return &#123; add: update(function(classes, index, value) &#123; if (!~index) classes.push(value); &#125;), remove: update(function(classes, index) &#123; if (~index) classes.splice(index, 1); &#125;), toggle: update(function(classes, index, value) &#123; if (~index) classes.splice(index, 1); else classes.push(value); &#125;), contains: function(value) &#123; return !!~self.className.split(/\\s+/g).indexOf(value); &#125;, item: function(i) &#123; return self.className.split(/\\s+/g)[i] || null; &#125; &#125;; &#125; &#125;); &#125;&lt;/script&gt; IE 8 不兼容 window.HTMLElement 所以第一行还得加上这一句 IE浏览器也真是够够的了 12//兼容ie8 HTMLElementwindow.HTMLElement = window.HTMLElement || Element;","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://elickzhao.github.io/tags/bootstrap/"},{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"http://elickzhao.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"}]},{"title":"前端开发环境简介","slug":"前端开发环境简介","date":"2016-05-16T14:08:57.000Z","updated":"2021-09-09T16:34:45.560Z","comments":true,"path":"2016/05/前端开发环境简介/","link":"","permalink":"http://elickzhao.github.io/2016/05/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%AE%80%E4%BB%8B/","excerpt":"","text":"这篇文章 只是简单介绍 几个框架的主要作用,并不涉及详细用法. npm 老大中的老大npm 不用多说什么 这是一切基础中的基础 yeoman 快速构建项目目录其实很多项目开发的时候,目录结构及需要的插件都有一定规律.所以yeoman是解放懒人的又一利器.他的主要作用就是,当你开始一个新项目时不用自己再手动各个目录和安装那些插件,一切都为你准备好,只要一个命令 yo找到你要开发项目,接下来只需等待yeoman帮你建立好所需的一切 bower 找轮子利器自己遭轮子虽然有成就感,不过别人写好的东西又何必再去浪费时间.所以bower又是懒人必不可少的.之所以选择bower是因为比npm搜索跟人性化,对我来说目前是这样,我更喜欢bower gulp 让你更专注的写东西 其他的事情交给gulp吧bower是需要实现一些功能的时候去搜索这个功能的插件,比如slider. 而gulp所用的插件是为了给你开发带来便利,并不是你网页上的功能.比如压缩css,js. 比如 sass直接编译好显示.这些都是提供你写代码时的方便.有了gulp 我就不在需要dw了,用sublime就好了. #参考文章:前端模块管理器简介Yeoman官方教程：用Yeoman和AngularJS做Web应用","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"bower","slug":"bower","permalink":"http://elickzhao.github.io/tags/bower/"},{"name":"gulp","slug":"gulp","permalink":"http://elickzhao.github.io/tags/gulp/"}]},{"title":"laravel 银联支付一点总结","slug":"laravel 银联支付一点总结","date":"2016-05-15T14:08:05.000Z","updated":"2021-09-09T16:34:45.259Z","comments":true,"path":"2016/05/laravel 银联支付一点总结/","link":"","permalink":"http://elickzhao.github.io/2016/05/laravel%20%E9%93%B6%E8%81%94%E6%94%AF%E4%BB%98%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"第一步开通测试 在我的产品中 点击为测试 然后添加要测试的项目 要不然会提示无权限 这里选择网关支付 下载测试证书 测试证书要从 个人中心 测试参数哪里下载 https://open.unionpay.com/ajweb/account/testPara商户私钥证书 必须安装一下 要不会会出错 编写代码 config\\laravel-omnipay.php12345678910111213141516171819202122232425&lt;?phpreturn [ // The default gateway to use &#x27;default&#x27; =&gt; &#x27;paypal&#x27;, // Add in each gateway here &#x27;gateways&#x27; =&gt; [ &#x27;unionpay&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;UnionPay_Express&#x27;, &#x27;options&#x27; =&gt; [ &#x27;merId&#x27; =&gt; &#x27;777290058128659&#x27;, &#x27;certPath&#x27; =&gt; storage_path(&#x27;app/unionpay/certs/700000000000001_acp.pfx&#x27;), &#x27;certPassword&#x27; =&gt; &#x27;000000&#x27;, &#x27;certDir&#x27; =&gt; storage_path(&#x27;app/unionpay/certs&#x27;), //付款完成后跳转会商家页面地址 两个好像可以写同一个地址 &#x27;returnUrl&#x27; =&gt; &#x27;http://114.254.183.127/omnipay/public/unionpay/return&#x27;, &#x27;notifyUrl&#x27; =&gt; &#x27;http://114.254.183.127/omnipay/public/unionpay/notify&#x27; ] ] ]];","text":"第一步开通测试 在我的产品中 点击为测试 然后添加要测试的项目 要不然会提示无权限 这里选择网关支付 下载测试证书 测试证书要从 个人中心 测试参数哪里下载 https://open.unionpay.com/ajweb/account/testPara商户私钥证书 必须安装一下 要不会会出错 编写代码 config\\laravel-omnipay.php12345678910111213141516171819202122232425&lt;?phpreturn [ // The default gateway to use &#x27;default&#x27; =&gt; &#x27;paypal&#x27;, // Add in each gateway here &#x27;gateways&#x27; =&gt; [ &#x27;unionpay&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;UnionPay_Express&#x27;, &#x27;options&#x27; =&gt; [ &#x27;merId&#x27; =&gt; &#x27;777290058128659&#x27;, &#x27;certPath&#x27; =&gt; storage_path(&#x27;app/unionpay/certs/700000000000001_acp.pfx&#x27;), &#x27;certPassword&#x27; =&gt; &#x27;000000&#x27;, &#x27;certDir&#x27; =&gt; storage_path(&#x27;app/unionpay/certs&#x27;), //付款完成后跳转会商家页面地址 两个好像可以写同一个地址 &#x27;returnUrl&#x27; =&gt; &#x27;http://114.254.183.127/omnipay/public/unionpay/return&#x27;, &#x27;notifyUrl&#x27; =&gt; &#x27;http://114.254.183.127/omnipay/public/unionpay/notify&#x27; ] ] ]]; routes.php 回调的方式不要写错了 是 POST 1234//银联支付处理Route::get(&#x27;unionpay/pay&#x27;,&#x27;UnionpayController@pay&#x27;);//支付后回调页面Route::post(&#x27;unionpay/return&#x27;,&#x27;UnionpayController@result&#x27;); UnionpayController.php 注意引用的 一定是 Omnipay的门面 因为会自动加载 Omnipay\\Omnipay这个类 这是错的 会找不到gateway()方法的 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use App\\Http\\Requests;use App\\Http\\Controllers\\Controller;use Omnipay; //**************** 就是这里千万不要搞错 引用的是这个门面//现在返回还有点问题 但是无关大雅了 支付流程已经完成了 class UnionpayController extends Controller&#123; public function pay()&#123; $gateway = Omnipay::gateway(&#x27;unionpay&#x27;); $order = [ &#x27;orderId&#x27; =&gt; date(&#x27;YmdHis&#x27;), &#x27;txnTime&#x27; =&gt; date(&#x27;YmdHis&#x27;), &#x27;orderDesc&#x27; =&gt; &#x27;My test order title&#x27;, &#x27;txnAmt&#x27; =&gt; &#x27;100&#x27; //订单价格 ];// dump(config(&#x27;laravel-omnipay.gateways&#x27;));// dd(storage_path(&#x27;app/unionpay/certs/acp_test_sign.pfx&#x27;)); $response = $gateway-&gt;purchase($order)-&gt;send(); $response-&gt;redirect(); &#125; public function result()&#123; $gateway = Omnipay::getFactory(&#x27;unionpay&#x27;); $response = $gateway-&gt;completePurchase([&#x27;request_params&#x27;=&gt;$_REQUEST])-&gt;send(); if ($response-&gt;isPaid()) &#123; exit(&#x27;支付成功！&#x27;); &#125;else&#123; exit(&#x27;支付失败！&#x27;); &#125; &#125; public function notify()&#123; echo &#x27;hhhh&#x27;; &#125;&#125; 测试同调 有一点一定要记住 点击获取短信 后,再填写验证码 要不有可能会提示验证码错误,或者系统忙","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"FIREFOX 和 chrome中 如何 禁止鼠标拖拽图片","slug":"FIREFOX 和 chrome中 如何 禁止鼠标拖拽图片","date":"2016-05-13T16:01:58.000Z","updated":"2021-09-09T16:34:44.913Z","comments":true,"path":"2016/05/FIREFOX 和 chrome中 如何 禁止鼠标拖拽图片/","link":"","permalink":"http://elickzhao.github.io/2016/05/FIREFOX%20%E5%92%8C%20chrome%E4%B8%AD%20%E5%A6%82%E4%BD%95%20%E7%A6%81%E6%AD%A2%E9%BC%A0%E6%A0%87%E6%8B%96%E6%8B%BD%E5%9B%BE%E7%89%87/","excerpt":"","text":"##三种办法 1234567&lt;script language=&quot;javascript&quot;&gt; document.images[i].ondragstart=function ()&#123;return false;&#125;; e.preventDefault(); document.ondragstart=function() &#123;return false;&#125;&lt;/script&gt; 我用过第三个 ondragstart 这个好使","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"Emmet：HTMLCSS 简明介绍","slug":"Emmet：HTMLCSS 简明介绍","date":"2016-05-12T17:03:28.000Z","updated":"2021-09-09T16:34:44.904Z","comments":true,"path":"2016/05/Emmet：HTMLCSS 简明介绍/","link":"","permalink":"http://elickzhao.github.io/2016/05/Emmet%EF%BC%9AHTMLCSS%20%E7%AE%80%E6%98%8E%E4%BB%8B%E7%BB%8D/","excerpt":"这里就写几个主要的,详细请看这篇文章:http://www.iteye.com/news/27580使用Emmet加速Web前端开发 初始化 HTML文档需要包含一些固定的标签，比如、、等，现在你只需要1秒钟就可以输入这些标签。比如输入“!”或“html:5”，然后按Tab键： 嵌套 现在你只需要1行代码就可以实现标签的嵌套。 123&gt;: 子元素符号，表示嵌套的元素+：同级标签符号^：可以使该符号前的标签提升一行 分组 你可以通过嵌套和括号来快速生成一些代码块，比如输入(.foo&gt;h1)+(.bar&gt;h2)，会自动生成如下代码 123456&lt;div class=&quot;foo&quot;&gt; &lt;h1&gt;&lt;/h1&gt;&lt;/div&gt;&lt;div class=&quot;bar&quot;&gt; &lt;h2&gt;&lt;/h2&gt;&lt;/div&gt; 快速添加类名、ID、文本和属性 使用E#ID添加ID名 使用E.class添加类名 使用E[attr]添加属性 使用E{text}添加文本","text":"这里就写几个主要的,详细请看这篇文章:http://www.iteye.com/news/27580使用Emmet加速Web前端开发 初始化 HTML文档需要包含一些固定的标签，比如、、等，现在你只需要1秒钟就可以输入这些标签。比如输入“!”或“html:5”，然后按Tab键： 嵌套 现在你只需要1行代码就可以实现标签的嵌套。 123&gt;: 子元素符号，表示嵌套的元素+：同级标签符号^：可以使该符号前的标签提升一行 分组 你可以通过嵌套和括号来快速生成一些代码块，比如输入(.foo&gt;h1)+(.bar&gt;h2)，会自动生成如下代码 123456&lt;div class=&quot;foo&quot;&gt; &lt;h1&gt;&lt;/h1&gt;&lt;/div&gt;&lt;div class=&quot;bar&quot;&gt; &lt;h2&gt;&lt;/h2&gt;&lt;/div&gt; 快速添加类名、ID、文本和属性 使用E#ID添加ID名 使用E.class添加类名 使用E[attr]添加属性 使用E{text}添加文本 隐式标签 声明一个带类的标签，只需输入div.item，就会生成。 在过去版本中，可以省略掉div，即输入.item即可生成&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;。现在如果只输入.item，则Emmet会根据父标签进行判定。比如在&lt;ul&gt;中输入.item，就会生成&lt;li class=&quot;item&quot;&gt;&lt;/li&gt;。 定义多个元素 要定义多个元素，可以使用符号。比如，ul&gt;li3可以生成如下代码： 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 定义多个带属性的元素 如果输入 ul&gt;li.item$*3，将会生成如下代码： 12345&lt;ul&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt;&lt;/ul&gt; emmet 和 css 简写width: 100px : w100border-bottom : bdbborder-top: bdtfont-size : fz 单位: px→ 默认 p→ % e→ em r→ rem x→ ex 多个单位 CSS中的某些属笥，比如margin，允许多个值。在Emmet中要做到这一点，只需要每个值之间使用破折号(-)。来看看下面的例子，给body定义margin的四个值： 颜色 在Emmet中使用#前缀，后面紧跟颜色值，但不同的字符数将会输出不同的十六进制代码。来看一些例子： ＃1→ ＃111111 ＃E0→ ＃e0e0e0 ＃FC0→ ＃FFCC00 !important 尽管在CSS中!important并不经常使用，但在Emmet也带有一定的缩写。添加!就可以自动生成： 多属性 现在我们具Emmet的CSS特性的一个基本了解，也是将它们放在一起的时候。就类似于Emmet和HTML中的相邻元素的功能。可以使用加号+运算符来创建多个属性。我们来看一个简单的示例： 模糊匹配 如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的 1overflow: hidden; 供应商前缀 如果输入非W3C标准的CSS属性，Emmet会自动加上供应商前缀，比如输入trs，则会生成： 12345-webkit-transform: ; -moz-transform: ; -ms-transform: ; -o-transform: ; transform: ; 你也可以在任意属性前加上“-”符号，也可以为该属性加上前缀。比如输入-super-foo： 12345-webkit-super-foo: ;-moz-super-foo: ;-ms-super-foo: ;-o-super-foo: ;super-foo: ; 如果不希望加上所有前缀，可以使用缩写来指定，比如-wm-trf表示只加上-webkit和-moz前缀： 123-webkit-transform: ;-moz-transform: ;transform: ; w 表示 -webkit-m 表示 -moz-s 表示 -ms-o 表示 -o- 渐变 输入lg(left, #fff 50%, #000)，会生成如下代码： 12345background-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000));background-image: -webkit-linear-gradient(left, #fff 50%, #000);background-image: -moz-linear-gradient(left, #fff 50%, #000);background-image: -o-linear-gradient(left, #fff 50%, #000);background-image: linear-gradient(left, #fff 50%, #000);","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"Emmet","slug":"Emmet","permalink":"http://elickzhao.github.io/tags/Emmet/"}]},{"title":"gulp使用bower下组件","slug":"gulp+bower","date":"2016-05-10T16:59:14.000Z","updated":"2021-09-09T16:34:45.162Z","comments":true,"path":"2016/05/gulp+bower/","link":"","permalink":"http://elickzhao.github.io/2016/05/gulp+bower/","excerpt":"","text":"我的项目使用 yeoman 生成的目录 自带gulpfile.js 想引入bower里组件到html页面 不需要手动写 执行 gulp 任务 wiredep 就可以了 但后来我引用兼容插件时 没有使用 也自动写入文件了 难道是serve任务的功劳?? 这个尚不清楚,反正如果没引入 执行一下这个 wiredep任务就可以了 gulp+bower 使用必须用 wiredep 手动wiredep才可以","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"bower","slug":"bower","permalink":"http://elickzhao.github.io/tags/bower/"},{"name":"gulp","slug":"gulp","permalink":"http://elickzhao.github.io/tags/gulp/"}]},{"title":"github开博客","slug":"github开博客","date":"2016-05-10T14:09:12.000Z","updated":"2021-09-09T16:34:45.158Z","comments":true,"path":"2016/05/github开博客/","link":"","permalink":"http://elickzhao.github.io/2016/05/github%E5%BC%80%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"hexo方法使用hexo搭建博客使用Hexo搭建个人博客使用GitHub和Hexo搭建免费静态Blog使用hexo搭建博客 简明步骤 下载 node.js 安装npm 下载Hexo 创建github新的仓库 配置ssh 配置Hexo配置文件 记得repo:地址是SSH 因为gtihub仓库有两个地址一个https 一个 git 一定要用git那个 那样才能用到ssh的自动上传 上传测试 安装主题 修改细节http://wsgzao.github.io/post/hexo-jacman/#http://wuchong.me/blog/2014/11/20/how-to-use-jacman/","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://elickzhao.github.io/tags/Git/"}]},{"title":"phpstrom快捷键及使用技巧","slug":"phpstrom快捷键及使用技巧","date":"2016-05-09T07:05:58.000Z","updated":"2021-09-09T16:34:45.379Z","comments":true,"path":"2016/05/phpstrom快捷键及使用技巧/","link":"","permalink":"http://elickzhao.github.io/2016/05/phpstrom%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"Alt+Shift+X命令行工具 (这个和Terminal有区别这个是laravel自带一些命令 这个好像的装laravel插件才可以用) Ctrl+F12呼叫出方法列表 Ctrl+Alt+S呼出配置 Ctrl+P快速打开文件 Ctrl+Shift+A搜索所有配置选项 Ctrl+Shift+Z撤销刚才的撤销也就是windows上的 Ctrl+Y Ctrl+Q显示代码注释 Ctrl+E最近打开文件","text":"Alt+Shift+X命令行工具 (这个和Terminal有区别这个是laravel自带一些命令 这个好像的装laravel插件才可以用) Ctrl+F12呼叫出方法列表 Ctrl+Alt+S呼出配置 Ctrl+P快速打开文件 Ctrl+Shift+A搜索所有配置选项 Ctrl+Shift+Z撤销刚才的撤销也就是windows上的 Ctrl+Y Ctrl+Q显示代码注释 Ctrl+E最近打开文件 Ctrl + Shift +小键盘+展开全部 Alt+Enter切换编辑语音 比如在php中要编辑html 用这个就可以打开 html编辑然后使用zendcoding快速编辑了 Ctrl + Tab键切换选项卡和工具窗口 Alt + ＃[0-9]打开相应的工具窗口 Ctrl+Tab里 能看到各个窗口编号 1 项目目录 3 Terminal CTRL+ALT+F12 资源管理器打开文件夹，跳转至当前文件在磁盘上的位置 CTRL+ALT ←/→ 返回上次编辑的位置 CTRL+ [] 光标移动到 {}[]开头或结尾位置 CTRL+SHIFT+[] 选中块代码，可以快速复制 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 F3 查找下一个 SHIFT+F3 查找上一个 CTRL+R 当前窗口替换文本 把两个项目放到一起显示用设置-&gt;项目-&gt; directories 然后添加项目目录就可以了 当写完一个方法的时候 在方法头部可以用 /** + 回车 然后IDE会自动完成备注 很是方便 详细连接 ： http://www.myext.cn/php/a_2818.htmlPhpStorm 快捷键大全 PhpStorm 常用快捷键和配置","categories":[{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"phpstorm","slug":"phpstorm","permalink":"http://elickzhao.github.io/tags/phpstorm/"},{"name":"ide","slug":"ide","permalink":"http://elickzhao.github.io/tags/ide/"}]},{"title":"gulp学习","slug":"gulp学习","date":"2016-05-08T16:19:49.000Z","updated":"2021-09-09T16:34:45.164Z","comments":true,"path":"2016/05/gulp学习/","link":"","permalink":"http://elickzhao.github.io/2016/05/gulp%E5%AD%A6%E4%B9%A0/","excerpt":"简单说下gulp使用流程 首先进入 项目目录 npm install –save-dev gulp 其次安装其他所需插件 配置文件里有 就不赘述了 规划目录开始编写 项目地址 123456789101112131415gulp #目录结构├─.idea│ └─libraries├─app│ └─assets # 随便找的测试例子│ ├─css│ │ └─font│ ├─images│ └─js├─build # 第一个实例 输出目录├─dist # 第二个实例 输出目录├─js # 第一个实例 随便写的js└─web # browser-syn 测试 随便写的scss ├─css └─scss Note:因为gulp-sass需要node-sass的支持才能用,不过node-sass被墙住了,所以这里共享一个,不过版本是3.7的 如果升级了就自行更换吧https://yunpan.cn/cPI3SEfajJeX9 访问密码 a6b0","text":"简单说下gulp使用流程 首先进入 项目目录 npm install –save-dev gulp 其次安装其他所需插件 配置文件里有 就不赘述了 规划目录开始编写 项目地址 123456789101112131415gulp #目录结构├─.idea│ └─libraries├─app│ └─assets # 随便找的测试例子│ ├─css│ │ └─font│ ├─images│ └─js├─build # 第一个实例 输出目录├─dist # 第二个实例 输出目录├─js # 第一个实例 随便写的js└─web # browser-syn 测试 随便写的scss ├─css └─scss Note:因为gulp-sass需要node-sass的支持才能用,不过node-sass被墙住了,所以这里共享一个,不过版本是3.7的 如果升级了就自行更换吧https://yunpan.cn/cPI3SEfajJeX9 访问密码 a6b0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173/** * Created by elick on 2016/5/8. *//* 这是packages.json的配置 不过里面不能写注释所以写在这里了&quot;devDependencies&quot;: &#123; //常用插件 &quot;browser-sync&quot;: &quot;^2.12.5&quot;, //浏览器同步插件 &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-autoprefixer&quot;: &quot;^3.1.0&quot;, //使用Autoprefixer来补全浏览器兼容的css &quot;gulp-concat&quot;: &quot;^2.6.0&quot;, //合并js &quot;gulp-jshint&quot;: &quot;^2.0.0&quot;, //检测js有没有报错或警告 &quot;jshint&quot;: &quot;^2.9.2&quot;, // gulp-jshint 不能单独使用 需要配合这个 &quot;gulp-load-plugins&quot;: &quot;^1.2.2&quot;, //读取插件 不用每个都都定义变量了 &quot;gulp-rename&quot;: &quot;^1.2.2&quot;, //改写名字 &quot;gulp-sass&quot;: &quot;^2.3.1&quot;, //解析sass文件 &quot;node-sass&quot;: &quot;^3.7.0&quot; //gulp-sass不能单独使用需要配合这个 //这个需要翻墙才能npm下载 &quot;gulp-uglify&quot;: &quot;^1.5.3&quot; //压缩文件&#125;*/var gulp = require(&#x27;gulp&#x27;), uglify = require(&#x27;gulp-uglify&#x27;), browserSync = require(&#x27;browser-sync&#x27;);//这个插件的意义就在上面 不用去写那么多注册 这一行就可以搞定了var gulpLoadPlugins = require(&#x27;gulp-load-plugins&#x27;), plugins = gulpLoadPlugins();gulp.task(&#x27;minify&#x27;,function()&#123; gulp.src(&#x27;js/app.js&#x27;) .pipe(uglify()) .pipe(gulp.dest(&#x27;build&#x27;))&#125;);gulp.task(&#x27;js&#x27;,function()&#123; return gulp.src(&#x27;js/*.js&#x27;) .pipe(uglify()) .pipe(plugins.concat(&#x27;app.js&#x27;)) //这就是那个plugins插件的用法 不需要require(concat) .pipe(gulp.dest(&#x27;build&#x27;)); //输出目录&#125;);gulp.task(&#x27;watch&#x27;,function()&#123; var watcher = gulp.watch(&#x27;templates/*.tmpl.html&#x27;, [&#x27;build&#x27;]); //watch() 这个函数自带的 不需要插件 watcher.on(&#x27;change&#x27;, function (event) &#123; console.log(&#x27;Event type: &#x27; + event.type); // added, changed, or deleted console.log(&#x27;Event path: &#x27; + event.path); // The path of the modified file &#125;); //与上面的watcher.on的功能等同 //gulp.watch(&#x27;templates/*.tmpl.html&#x27;, function (event) &#123; // console.log(&#x27;Event type: &#x27; + event.type); // added, changed, or deleted // console.log(&#x27;Event path: &#x27; + event.path); // The path of the modified file //&#125;);&#125;);// 另一篇文章的插件测试 ---------------------------------------//引入gulpvar gulp = require(&#x27;gulp&#x27;);//引入组件var jshint = require(&#x27;gulp-jshint&#x27;); //这个还得配合jshint使用,单独使用不可以var sass = require(&#x27;gulp-sass&#x27;);var concat = require(&#x27;gulp-concat&#x27;);var uglify = require(&#x27;gulp-uglify&#x27;);var rename = require(&#x27;gulp-rename&#x27;); //经过测试这个组件基本毫无意义 也许有用我现在没发现//其实下面可以写在一起 不过这样分开写不错 因为可以单独执行//检查脚本gulp.task(&#x27;lint&#x27;,function()&#123; gulp.src(&#x27;./js/*.js&#x27;) .pipe(jshint()) .pipe(jshint.reporter(&#x27;default&#x27;));&#125;);// 编译Sassgulp.task(&#x27;sass&#x27;, function() &#123; gulp.src(&#x27;./scss/*.scss&#x27;) .pipe(sass()) .pipe(gulp.dest(&#x27;./css&#x27;));&#125;);//合并压缩文件gulp.task(&#x27;scripts&#x27;,function()&#123; gulp.src(&#x27;./js/*.js&#x27;) .pipe(uglify()) .pipe(concat(&#x27;all.min.js&#x27;)) .pipe(gulp.dest(&#x27;./dist&#x27;));&#125;);//默认任务gulp.task(&#x27;default&#x27;,function()&#123; gulp.run(&#x27;lint&#x27;,&#x27;sass&#x27;,&#x27;scripts&#x27;); //运行任务 //监听文件变化 gulp.watch(&#x27;./js/*.js&#x27;,function()&#123; gulp.run(&#x27;lint&#x27;,&#x27;sass&#x27;,&#x27;scripts&#x27;); &#125;);&#125;);// browser-sync 测试 --------------------------------------------------------------//这种配置是静态文件配置方法// 不对 其实把less或者sass也放到监控里其实一样// 还是错了 还是静态的 因为less和sass需要 gulp转换才可以 目前这里并没有转换任务//因为单一执行的browser-sync一个任务//https://github.com/BrowserSync/gulp-browser-sync 这里有很多配置方法的例子gulp.task(&#x27;browser-sync&#x27;,function()&#123; var files = [ &#x27;app/**/*.html&#x27;, &#x27;app/assets/css/**/*.css&#x27;, &#x27;app/assets/images/** /*.png&#x27;, &#x27;app/assets/js/**/*.js&#x27; ]; browserSync.init(files,&#123; server: &#123; baseDir: &#x27;./app/assets&#x27; //这个是主页地址 &#125; &#125;);&#125;);//第二个测试 ----------------------------------------------------------------var filter = require(&#x27;gulp-filter&#x27;);var reload = browserSync.reload;gulp.task(&#x27;b-sync&#x27;,function()&#123; //第二种 用watch监控因为 wtach可以写多个 这个服务器写法就得和下面gulp.watch(&#x27;web/*.html&#x27;)配合 //要不只能监控sass变化了 browserSync(&#123; server:&#123; baseDir: &quot;./web&quot; &#125; &#125;); //第一种写法 用browserSync 来监控文件 //这么写也可以啊 而且能监控html文件变化 上面那个只能监控sass文件 //var files = [ // &#x27;web/**/*.html&#x27;, // //&#x27;web/**/*.css&#x27;, //用上这句 其实下面sass任务里的 reload可以去掉 不过速度比那个慢很多所以还是把这个去掉吧 // //]; // //browserSync.init(files,&#123; // server: &#123; // baseDir: &#x27;./web&#x27; //这个是主页地址 // &#125; //&#125;);&#125;);gulp.task(&#x27;sass&#x27;,function()&#123; return gulp.src(&#x27;web/scss/styles.scss&#x27;) .pipe(sass(&#123;includePaths:[&#x27;web/scss&#x27;]&#125;)) //编译SASS .pipe(gulp.dest(&#x27;web/css&#x27;)) // 写入CSS目录 .pipe(filter(&#x27;web/**/*.css&#x27;)) //过滤流确保CSS文件通过。 .pipe(reload(&#123;stream:true&#125;)); //注入浏览器&#125;);gulp.task(&#x27;def&#x27;,[&#x27;sass&#x27;,&#x27;b-sync&#x27;],function()&#123; gulp.watch(&#x27;web/scss/*.scss&#x27;,[&#x27;sass&#x27;]); gulp.watch(&#x27;web/*.html&#x27;).on(&#x27;change&#x27;,reload);&#125;); 123456789101112131415&#123; &quot;private&quot;: true, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=0.12.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;browser-sync&quot;: &quot;^2.12.5&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-concat&quot;: &quot;^2.6.0&quot;, &quot;gulp-jshint&quot;: &quot;^2.0.0&quot;, &quot;gulp-load-plugins&quot;: &quot;^1.2.2&quot;, &quot;gulp-uglify&quot;: &quot;^1.5.3&quot; &#125;&#125; 参考文章:Gulp开发教程：Building With Gulp前端构建工具gulp入门教程前端构建之gulp与常用插件Browsersync + Gulp","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"},{"name":"gulp","slug":"gulp","permalink":"http://elickzhao.github.io/tags/gulp/"}]},{"title":"npm package.json 配置说明","slug":"npm package.json 配置说明","date":"2016-05-08T15:06:01.000Z","updated":"2021-09-09T16:34:45.338Z","comments":true,"path":"2016/05/npm package.json 配置说明/","link":"","permalink":"http://elickzhao.github.io/2016/05/npm%20package.json%20%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/","excerpt":"1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;name&quot;: &quot;studyangular&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;dependencies&quot;: &#123;&#125;, &quot;repository&quot;: &#123;&#125;, &quot;devDependencies&quot;: &#123; &quot;grunt&quot;: &quot;^0.4.5&quot;, &quot;grunt-autoprefixer&quot;: &quot;^2.0.0&quot;, &quot;grunt-concurrent&quot;: &quot;^1.0.0&quot;, &quot;grunt-contrib-clean&quot;: &quot;^0.6.0&quot;, &quot;grunt-contrib-compass&quot;: &quot;^1.0.0&quot;, &quot;grunt-contrib-concat&quot;: &quot;^0.5.0&quot;, &quot;grunt-contrib-connect&quot;: &quot;^0.9.0&quot;, &quot;grunt-contrib-copy&quot;: &quot;^0.7.0&quot;, &quot;grunt-contrib-cssmin&quot;: &quot;^0.12.0&quot;, &quot;grunt-contrib-htmlmin&quot;: &quot;^0.4.0&quot;, &quot;grunt-contrib-imagemin&quot;: &quot;^0.9.2&quot;, &quot;grunt-contrib-jshint&quot;: &quot;^0.11.0&quot;, &quot;grunt-contrib-uglify&quot;: &quot;^0.7.0&quot;, &quot;grunt-contrib-watch&quot;: &quot;^0.6.1&quot;, &quot;grunt-filerev&quot;: &quot;^2.1.2&quot;, &quot;grunt-google-cdn&quot;: &quot;^0.4.3&quot;, &quot;grunt-newer&quot;: &quot;^1.1.0&quot;, &quot;grunt-ng-annotate&quot;: &quot;^0.9.2&quot;, &quot;grunt-svgmin&quot;: &quot;^2.0.0&quot;, &quot;grunt-usemin&quot;: &quot;^3.0.0&quot;, &quot;grunt-wiredep&quot;: &quot;^2.0.0&quot;, &quot;jshint-stylish&quot;: &quot;^1.0.0&quot;, &quot;load-grunt-tasks&quot;: &quot;^3.1.0&quot;, &quot;time-grunt&quot;: &quot;^1.0.0&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=0.10.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;grunt test&quot; &#125;&#125; Private最喜欢这个字段 设置为true下面那些就全部用写了,开发时 或者 不想共享时 就用这个可选字段，布尔值。如果private为true，npm会拒绝发布。这可以防止私有repositories不小心被发布出去。","text":"1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;name&quot;: &quot;studyangular&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;dependencies&quot;: &#123;&#125;, &quot;repository&quot;: &#123;&#125;, &quot;devDependencies&quot;: &#123; &quot;grunt&quot;: &quot;^0.4.5&quot;, &quot;grunt-autoprefixer&quot;: &quot;^2.0.0&quot;, &quot;grunt-concurrent&quot;: &quot;^1.0.0&quot;, &quot;grunt-contrib-clean&quot;: &quot;^0.6.0&quot;, &quot;grunt-contrib-compass&quot;: &quot;^1.0.0&quot;, &quot;grunt-contrib-concat&quot;: &quot;^0.5.0&quot;, &quot;grunt-contrib-connect&quot;: &quot;^0.9.0&quot;, &quot;grunt-contrib-copy&quot;: &quot;^0.7.0&quot;, &quot;grunt-contrib-cssmin&quot;: &quot;^0.12.0&quot;, &quot;grunt-contrib-htmlmin&quot;: &quot;^0.4.0&quot;, &quot;grunt-contrib-imagemin&quot;: &quot;^0.9.2&quot;, &quot;grunt-contrib-jshint&quot;: &quot;^0.11.0&quot;, &quot;grunt-contrib-uglify&quot;: &quot;^0.7.0&quot;, &quot;grunt-contrib-watch&quot;: &quot;^0.6.1&quot;, &quot;grunt-filerev&quot;: &quot;^2.1.2&quot;, &quot;grunt-google-cdn&quot;: &quot;^0.4.3&quot;, &quot;grunt-newer&quot;: &quot;^1.1.0&quot;, &quot;grunt-ng-annotate&quot;: &quot;^0.9.2&quot;, &quot;grunt-svgmin&quot;: &quot;^2.0.0&quot;, &quot;grunt-usemin&quot;: &quot;^3.0.0&quot;, &quot;grunt-wiredep&quot;: &quot;^2.0.0&quot;, &quot;jshint-stylish&quot;: &quot;^1.0.0&quot;, &quot;load-grunt-tasks&quot;: &quot;^3.1.0&quot;, &quot;time-grunt&quot;: &quot;^1.0.0&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=0.10.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;grunt test&quot; &#125;&#125; Private最喜欢这个字段 设置为true下面那些就全部用写了,开发时 或者 不想共享时 就用这个可选字段，布尔值。如果private为true，npm会拒绝发布。这可以防止私有repositories不小心被发布出去。 Name 必须字段,包名称 小提示： 不要在name中包含js, node字样； 这个名字最终会是URL的一部分，命令行的参数，目录名，所以不能以点号或下划线开头； 这个名字可能在require()方法中被调用，所以应该尽可能短； Version必须字段,包版本name和version是package.json中最重要的两个字段，也是发布到NPM平台上的唯一标识，如果没有正确设置这两个字段，包就不能发布和被下载。新版本的NPM可以指定scope, 名字可以加前缀标识，如@ijse/mypackage。 Description 包的描述信息，可选字段，必须是字符串。 npm search 的时候会用到。 Keywords 包的关键词信息，是一个字符串数组， npm search 的时候会用到。 Homepage 包的主页地址,可选字段， 没有 http:// 等带协议前缀的URL。 bugs可选字段，问题追踪系统的URL或邮箱地址； npm bugs 用的上。包的bug跟踪主页地址，应该如下设置 12345&#123; &quot;url&quot; :&quot;http://github.com/owner/project/issues&quot;,&quot;email&quot; :&quot;project@hostname.com&quot;&#125; License 包的开源协议名称,可选字段。 如果是使用一个普遍的license，比如BSD-3-Clause或MIT，直接使用： 1&#123; &quot;license&quot; : &quot;BSD-3-Clause&quot; &#125; Author , contributors 都是可选字段。author是一个人，contributors是一组人。 Author的格式如下： 1234&#123; &quot;name&quot; : &quot;Barney Rubble&quot;, &quot;email&quot; : &quot;b@rubble.com&quot;, &quot;url&quot; : &quot;http://barnyrubble.tumblr.com/&quot;&#125; 或者: 1&quot;Barney Rubble &lt;b@rubble.com&gt; (http://barnyrubble.tumblr.com/)&quot; files可选字段，项目包含的一组文件。如果是文件夹，文件夹下的文件也会被包含。如果需要把某些文件不包含在项目中，添加一个”.npmignore”文件。这个文件和”gitignore”类似。 main可选字段。包的入口文件，如index.js 这个字段的值是你程序主入口 模块的ID 。如果其他用户需要你的包，当用户调用require()方法时，返回的就是这个模块的导出（ exports ）。 bin可选字段。很多的包都会有执行文件需要安装到PATH中去。 这个字段对应的是一个Map，每个元素对应一个 { 命令名：文件名 } 。 1&#123; &quot;bin&quot; : &#123; &quot;npm&quot; : &quot;./cli.js&quot; &#125; &#125; 当包被安装后，NPM将创建一个cli.js文件的链接到/usr/local/bin/iapp下。 man为系统的man命令提供帮助文档, 如： 1&quot;man&quot;: &quot;./man/doc.1&quot; 帮助文件的文件名必须以数字结尾，如果是压缩的，需要以.gz结尾。 如果是字符串数组： 12&quot;name&quot;: &quot;foo&quot;,&quot;man&quot;: [&quot;./man/foo.1&quot;, &quot;./man/bar.1&quot;, &quot;./man/foo.2&quot; ] 则分别可以man foo, man foo-bar, man 2 foo来查看。 Directories CommonJS包所要求的目录结构信息，目前除了告诉别人你的程序目录结构，貌似没有别的什么用。下级字段可以是：lib, bin, man, doc, example。 每个都是字符串 用于指示包的目录结构： Directories.lib 指示库文件的位置。 Directories.bin 和前面的bin是一样的，但如果前面已经有bin，那么这个就无效。 除了以上两个，还有Directories.doc&amp; Directories.man &amp; Directories.example。 Repository 可选字段。用于指示代码存放的位置。 12345678910111213141516171819202122&quot;repository&quot; : &#123; &quot;type&quot; : &quot;git&quot; , &quot;url&quot; : &quot;http://github.com/npm/npm.git&quot; &#125;&quot;repository&quot; : &#123; &quot;type&quot; : &quot;svn&quot; , &quot;url&quot; : &quot;http://v8.googlecode.com/svn/trunk/&quot; &#125;``` Scripts通过设置这个可以使NPM调用一些命令脚本，封装一些功能。可选字段，object。Key是生命周期事件名，value是在事件点要跑的命令。参考npm-scripts。**config**可选字段，object。添加一些设置，可以供scripts读取用，同时这里的值也会被添加到系统的环境变量中。Config对象中的值在 Scripts 的整个周期中皆可用，专门用于给Scripts提供配置参数。```json&quot;name&quot;: &quot;foo&quot;,&quot;config&quot;: &#123; &quot;port&quot;: &quot;8080&quot;&#125; Dependencies指定依赖的其它包，这些依赖是指包发布后正常执行时所需要的，如果是开发中依赖的包，可以在devDependencies设置。 通常使用下面命令来安装： 1npm install --save otherpackage 可选字段，指示当前包所依赖的其他包。 12345678910111213&#123; &quot;dependencies&quot; : &#123; &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot; , &quot;bar&quot; : &quot;&gt;=1.0.2 &lt;2.1.2&quot; , &quot;baz&quot; : &quot;&gt;1.0.2 &lt;=2.3.4&quot; , &quot;boo&quot; : &quot;2.0.1&quot; , &quot;qux&quot; : &quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot; , &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot; , &quot;til&quot; : &quot;~1.2&quot; , &quot;elf&quot; : &quot;~1.2.3&quot; , &quot;two&quot; : &quot;2.x&quot; , &quot;thr&quot; : &quot;3.3.x&quot; &#125;&#125; 版本格式可以是下面任一种： version 完全匹配 version 大于这个版本 =version 大于或等于这个版本 &lt;version &lt;=version ~version 非常接近这个版本 ^version 与当前版本兼容 1.2.x X代表任意数字，因此1.2.1, 1.2.3等都可以 http://… Unix系统下使用的tarball的URL。 任何版本都可以 “” 任何版本都可以 version1 - version2 等价于 &gt;=version1 &lt;=version2 . range1 || range2 满足任意一个即可 git… Git地址 user/repo devDependencies Git URL可以有如下种形式： 12345git://github.com/user/project.git#commit-ish git+ssh://user@hostname:project.git#commit-ish git+ssh://user@hostname/project.git#commit-ish git+http://user@hostname/project/blah.git#commit-ish git+https://user@hostname/project/blah.git#commit-ish devDependencies 可选字段。如果只需要下载使用某些模块，而不下载这些模块的测试和文档框架，放在这个下面比较不错。这些依赖只有在开发时候才需要。 1npm install --save-dev mypack peerDependencies 可选字段。兼容性依赖。如果你的包是插件，适合这种方式。相关的依赖，如果你的包是插件，而用户在使用你的包时候，通常也会需要这些依赖（插件），那么可以将依赖列到这里。 12345678910&quot;peerDependencies&quot;: &#123; &quot;karma-jasmine&quot;: &quot;~0.1.0&quot;, &quot;karma-requirejs&quot;: &quot;~0.2.0&quot;, &quot;karma-coffee-preprocessor&quot;: &quot;~0.1.0&quot;, &quot;karma-html2js-preprocessor&quot;: &quot;~0.1.0&quot;, &quot;karma-chrome-launcher&quot;: &quot;~0.1.0&quot;, &quot;karma-firefox-launcher&quot;: &quot;~0.1.0&quot;, &quot;karma-phantomjs-launcher&quot;: &quot;~0.1.0&quot;, &quot;karma-script-launcher&quot;: &quot;~0.1.0&quot;&#125; 这些都是karma的相关插件，一般使用karma的时候都会需要。 bundledDependencies 可选字段。发布包时同时打包的其他依赖。 optionalDependencies 可选字段。如果你想在某些依赖即使没有找到，或则安装失败的情况下，npm都继续执行。那么这些依赖适合放在这里。 Engines 可选字段。既可以指定node版本： 1&#123; &quot;engines&quot; : &#123;&quot;node&quot; : &quot;&gt;=0.10.3 &lt;0.12&quot; &#125; &#125; 也可以指定npm版本： 1&#123; &quot;engines&quot; : &#123;&quot;npm&quot; : &quot;~1.0.20&quot; &#125; &#125; engineStrick 可选字段，布尔值。如果你肯定你的程序只能在制定的engine上运行，设置为true。 os可选字段。指定模块可以在什么操作系统上运行： 123&quot;os&quot; : [ &quot;darwin&quot;,&quot;linux&quot; ]&quot;os&quot; : [ &quot;!win32&quot; ] cpu可选字段。指定CPU型号。 123&quot;cpu&quot; : [ &quot;x64&quot;,&quot;ia32&quot; ]&quot;cpu&quot; : [ &quot;!arm&quot;,&quot;!mips&quot; ] preferGlobal 可选字段，布尔值。如果你的包是个命令行应用程序，需要全局安装，就可以设为true。 publishConfig 可选字段。发布时使用的配置值放这。这个字段用于设置发布时候的一些设定。尤其方便你希望发布前设定指定的tag或registry。 也可以设定其它子字段，但只有tag和registry会影响到发布。 NPM的一些默认值说明 123&quot;scripts&quot;:&#123;&quot;start&quot;: &quot;node server.js&quot;&#125; #如果你的包里有server.js文件，npm默认将执行： node server.js &quot;scripts&quot;:&#123;&quot;preinstall&quot;:&quot;node-gyp rebuild&quot;&#125; #如果包里有 binding.gyp， npm默认在 preinstall命令时，使用node-gyp做编译 1&quot;contributors&quot;: [...] #如果项目根目录下含有AUTHORS文件，则NPM会自动将每一行以Name &lt;email&gt; (url)的格式读取并设定此字段。 参考文章npm package.json 配置文件package.json for NPM 文件详解","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"}]},{"title":"nodejs npm常用命令","slug":"nodejs npm常用命令","date":"2016-05-06T14:47:16.000Z","updated":"2021-09-09T16:34:45.332Z","comments":true,"path":"2016/05/nodejs npm常用命令/","link":"","permalink":"http://elickzhao.github.io/2016/05/nodejs%20npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"npm search 搜索包 npm install 安装nodejs的依赖包 npm install -g 将包安装到全局环境中但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的，就好像全局安装了vmarket后，就可以在命令行中直接运行vm命令 npm install –save 安装的同时，将信息写入package.json中 项目路径中如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包这样代码提交到github时，就不用提交node_modules这个文件夹了。 npm init 会引导你创建一个package.json文件，包括名称、版本、作者这些信息等 npm ls 列出当前安装的了所有包 npm ls -g 查看全局安装的模块及依赖","text":"npm search 搜索包 npm install 安装nodejs的依赖包 npm install -g 将包安装到全局环境中但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的，就好像全局安装了vmarket后，就可以在命令行中直接运行vm命令 npm install –save 安装的同时，将信息写入package.json中 项目路径中如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包这样代码提交到github时，就不用提交node_modules这个文件夹了。 npm init 会引导你创建一个package.json文件，包括名称、版本、作者这些信息等 npm ls 列出当前安装的了所有包 npm ls -g 查看全局安装的模块及依赖 npm root 查看当前包的安装路径 npm root -g 查看全局的包的安装路径 npm config set cache 设置全局缓存 npm config set prefix 设置全局安装包位置 npm update 更新 npm remove 移除 npm uninstall xxx (-g) 卸载模块 npm cache clean 清理缓存 npm help 帮助，如果要单独查看install命令的帮助，可以使用的npm help install npm view moudleName dependencies：查看包的依赖关系 npm view moduleName repository.url：查看包的源文件地址 npm view moduleName engines：查看包所依赖的Node的版本 npm help folders：查看npm使用的所有文件夹 npm rebuild moduleName：用于更改包内容后进行重建 npm outdated moduleName：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新 参考文章:http://www.cnblogs.com/linjiqin/p/3765772.htmlhttp://my.oschina.net/robinjiang/blog/168732","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"}]},{"title":"composer 一些常用命令及使用心得","slug":"composer 一些常用命令及使用心得","date":"2016-05-06T09:30:51.000Z","updated":"2021-09-09T16:34:45.121Z","comments":true,"path":"2016/05/composer 一些常用命令及使用心得/","link":"","permalink":"http://elickzhao.github.io/2016/05/composer%20%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","excerpt":"","text":"1234567891011121314151617181920212223composer selfupdate composer require &quot;foo/bar:1.0.0&quot; 安装一个库composer update foo/bar 更新单个库composer create-project laravel/laravel myapp --prefer-dist 创建laravel项目composer config -g repo.packagist composer https://packagist.phpcomposer.com 配置仓库镜像composer global require &quot;laravel/installer=~1.1&quot; 全局安装laravel安装器composer install update --prefer-dist 后面这个参数是强制使用压缩包composer install --profile 后面这个参数是显示安装时间composer dump-autoload --optimize 生产环境优化composer update symfony/yaml --prefer-source 强制克隆代码 用于修改库文件当你更新一个修改的库的时候 会提示你是否放弃修改----------------------------------------------------------------------------------------------------$ composer updateLoading composer repositories with package information Updating dependencies - Updating symfony/symfony v2.2.0 (v2.2.0- =&gt; v2.2.0) The package has modified files: M Dumper.php Discard changes [y,n,v,s,?]?---------------------------------------------------------------------------------------------------- 全局配置目录C:\\Users\\elick\\AppData\\Roaming\\Composer","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"composer","slug":"composer","permalink":"http://elickzhao.github.io/tags/composer/"}]},{"title":"webstorm 和 phpstorm 个人喜爱的设置","slug":"webstorm 和 phpstorm 个人喜爱的设置","date":"2016-05-06T08:43:45.000Z","updated":"2021-09-09T16:34:45.471Z","comments":true,"path":"2016/05/webstorm 和 phpstorm 个人喜爱的设置/","link":"","permalink":"http://elickzhao.github.io/2016/05/webstorm%20%E5%92%8C%20phpstorm%20%E4%B8%AA%E4%BA%BA%E5%96%9C%E7%88%B1%E7%9A%84%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"编辑器主题 首先去 Color Themes 下载我最爱的 sublime text2 主题, 用 文件 -&gt; 导入设置 安装后重启 修改字体大小及宽度, 设置-&gt;编辑器-&gt;颜色和字体-&gt;font 我一般喜欢用 Consolas 这个是自带里面最好的,其次是 Dejavu Sans Mono Source Code Pro 不过后面两个需要下载. 字体大小 一般选 15 自宽 1.4 这样看着没那么累 配置界面颜色好了 如果你是默认主题的话 就会发现左侧 侧边栏 跟右侧颜色不是一样的.对于一个强迫症患者来说这是不能接受的. 如何解决呢.就是去plugins 去下载一个插件 color IDE 激活重启以后 世界和谐了 细节调整这个主题变成颜色是很满意,但是还是有些蛋疼的地方.比如说,搜索结果是一大块白色,根本看不清是什么内容,选中相同代码,背景是黑色,很难辨识,这里就通过 File -&gt; Settings -&gt; editor -&gt;color&amp;fonts-&gt;general 这里慢慢调了","categories":[],"tags":[{"name":"phpstorm","slug":"phpstorm","permalink":"http://elickzhao.github.io/tags/phpstorm/"}]},{"title":"一个图片说明开源许可协议","slug":"常用开源许可协议介绍","date":"2016-05-05T05:09:58.000Z","updated":"2021-09-09T16:34:45.632Z","comments":true,"path":"2016/05/常用开源许可协议介绍/","link":"","permalink":"http://elickzhao.github.io/2016/05/%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"参考文章:常用开源许可协议介绍开源许可证的一些介绍","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"}]},{"title":"git 删除右键菜单","slug":"git 删除右键菜单","date":"2016-05-04T14:06:10.000Z","updated":"2021-09-09T16:34:45.152Z","comments":true,"path":"2016/05/git 删除右键菜单/","link":"","permalink":"http://elickzhao.github.io/2016/05/git%20%E5%88%A0%E9%99%A4%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/","excerpt":"","text":"首先，我表示git默认的右键菜单很烦，太多项了，而我们平时用的最多的无非是一个Git Bash！删除msGit右键菜单 如果是windows 64位系统cmd进入”C:\\Program Files (x86)\\Git\\git-cheetah”目录，运行 1regsvr32 /u git_shell_ext64.dll 如果还想用这个功能 可以看下面这个文章 参考文章 http://blog.csdn.net/songques/article/details/8488061","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://elickzhao.github.io/tags/Git/"}]},{"title":"windows 下安装VirtualBox , Vagrant 和 Homestead","slug":"windows 下安装VirtualBox , Vagrant 和 Homestead","date":"2016-05-04T10:54:01.000Z","updated":"2021-09-09T16:34:45.480Z","comments":true,"path":"2016/05/windows 下安装VirtualBox , Vagrant 和 Homestead/","link":"","permalink":"http://elickzhao.github.io/2016/05/windows%20%E4%B8%8B%E5%AE%89%E8%A3%85VirtualBox%20,%20Vagrant%20%E5%92%8C%20Homestead/","excerpt":"下载 VirtualBox 并安装 这个不用说一顿下一步就好了 下载地址 下载安装 Vagrant 这个也是跟上面一样 下载地址 哦 记得重启电脑要不命令不好使的 下载 Homestead Vagrant Box 这里你可以使用命令 vagrant box add laravel/homestead 慢慢等 大概20分钟左右吧 (使用命令时会让你选择 记得要选择 virtualbox 如果你装的VM那就选另一个就好了)也可以看到下载地址自己下 就是在输入命令后 开始下载时 果断 Ctrl+C 通过地址我发现 直接去浏览版本 然后进入版本后在后面 接上这个 providers/virtualbox.box 就可以下载了 我试了下下载速度其实快不了多少 但是有个好处可以断点续传 而使用命令是不可以的 如果失败了 是比较麻烦的https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.4.2/providers/virtualbox.box 失败了… 唉下载那种方式我失败了 总说文件无法打开 也不知道为啥 但是别人都成功了 算了不管了 以后再说吧 还是直接用命令下 反正时间也没差多少","text":"下载 VirtualBox 并安装 这个不用说一顿下一步就好了 下载地址 下载安装 Vagrant 这个也是跟上面一样 下载地址 哦 记得重启电脑要不命令不好使的 下载 Homestead Vagrant Box 这里你可以使用命令 vagrant box add laravel/homestead 慢慢等 大概20分钟左右吧 (使用命令时会让你选择 记得要选择 virtualbox 如果你装的VM那就选另一个就好了)也可以看到下载地址自己下 就是在输入命令后 开始下载时 果断 Ctrl+C 通过地址我发现 直接去浏览版本 然后进入版本后在后面 接上这个 providers/virtualbox.box 就可以下载了 我试了下下载速度其实快不了多少 但是有个好处可以断点续传 而使用命令是不可以的 如果失败了 是比较麻烦的https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.4.2/providers/virtualbox.box 失败了… 唉下载那种方式我失败了 总说文件无法打开 也不知道为啥 但是别人都成功了 算了不管了 以后再说吧 还是直接用命令下 反正时间也没差多少 命令执行后 会在 C:\\Users\\ 你的用户名 \\.vagrant.d\\boxes 下面增加这个box (名字是laravel-VAGRANTSLASH-homestead) 如果想删除可以直接上这里删除 (而且上次操作时不知道为什么出来两个版本 一个0.4.2 一个0.3.0 不知道是不是跟我建立了两个虚拟机有关 以后测试下) 不过现在光有box 还没有建立虚拟机 下面是下载 laravel/Homestead命令 composer global require &quot;laravel/homestead=~2.0&quot; 如果你没装composer 可以直接用git clone 来下载 git clone https://github.com/laravel/homestead.git Homestead 可以任选其一 初始化 配置文件 Homestead.yaml 这个有很三个方法 去克隆下来文件夹,找到init.bat点击执行就可以了 就会生成默认配置文件 (composer global 下载的文件位置在 C:\\Users\\ 你的用户名 \\AppData\\Roaming\\Composer\\vendor\\laravel\\homestead) 还是去到克隆的那个文件夹 使用 bash init.sh 来生成 但是这个需要你安装Git 并且把Git下的bin目录放到环境变量里才可以 否则找不到这个bash命令的 使用homestead init 来生成默认配置 但是同样 需要配置环境变量 否则无法使用, 建议还是把composer配置到环境变量,因为其他一些项目有时也需要执行一些命令 这样可以一劳永逸 比如laravel-install (配置环境变量的目录 C:\\Users\\ 你的用户名\\AppData\\Roaming\\Composer\\vendor\\bin) 第三个方法又失败了 可能windows下不能使用 只有在linux才能使用 反正提示没有init这个命令 而且 -h 也没有 找到这个命令 可以了原来是 laravel/Homestea 版本问题 如果是3.0版本就没有这个命令 2.0的版本就有这个命令 好了 这种方式是全局安装 接下来就是配置这个 主机的配置了 这种方式是全局安装，即同一主机上所有项目共享该Homestead盒子，当然你也可以为每个项目单独指定Homestead盒子，可参考Laravel Homestead相应的文档，这里不再赘述。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364---# 虚拟主机ip 这个默认就可以不需要改ip: &quot;192.168.10.10&quot;# 虚拟主机 使用内存memory: 2048# 虚拟主机 使用CPU核心数cpus: 1# 使用哪个 Vagrant 提供者： virtualbox 、 vmware_fushion 或者 vmware_workstation 我们下载的是virtualbox版 所以默认就是这个了provider: virtualbox# 私有SSH KEY 这个我没有 也能登录和使用authorize: ~/.ssh/id_rsa.pubkeys: - ~/.ssh/id_rsa# 共享文件夹folders: - map: F:\\phpStudy\\WWW\\homestead to: /home/vagrant - map: F:\\phpStudy\\WWW\\homestead\\laravelapp to: /home/vagrant/laravelapp # 站点配置 这个需要配置本地hostsites: - map: homestead.app to: /home/vagrant - map: laravel.app to: /home/vagrant/laravelapp/public //hhvm: true 这个必须对齐to 要不会报错 #多站点可以这么写 不过记住添加新站点一定要执行 vagrant provision 命令#否则nginx里不会有新站点配置 域名不会指向 当然要手动自己写也可以 # 数据库名databases: - homestead# 数据库对应.env环境变量 也就是laravel项目.env配置文件variables: - key: APP_ENV value: local#黑火测试配置# blackfire:# - id: foo# token: bar# client-id: foo# client-token: bar#端口映射 可以把虚拟机端口# ports:# - send: 93000# to: 9300# - send: 7777# to: 777# protocol: udp#测试一则 这里必须有空格 方向别搞反了ports: - send: 8080 to: 80 启动并初始化 homestead 虚拟机 进入自己的目录 使用命令 Homestead up 这个命令是2.0版本才有 3.0版本是没有的 而且使用前必须使用homestead init 要不即使有配置文件也会出错 还有个问题就是这个版本会找0.3.0那个版本的box 也就是说我上面下载的0.4.2那个没用了 也就是为什么上面说会出现两个版本 看来还得用新的3.0 Homestead试一下 有几个问题需要注意 共享目录如果配置错误 更改配置文件 居然也不好使 只能销毁重新建立虚拟机 不知道为什么 其他设置均可以 可能我这个机器Vagrant现在也有些问题 而且还有个问题共享目录php文件不显示 只显示laravel项目 很诡异 我在根目录放歌index.php文件就不显示 但是laravel项目指定域名就可以 这个新版本的3.0 很是麻烦 去掉了很多命令 就剩了一个make 全局的虚拟机好像不好使了 只有项目的虚拟机可以用 而且比较简单 只要在项目里 composer require laravel/homestead 并在项目根目录执行 homestead make 然后启动就可以了 vagrant up 全局的虚拟机可以使用 步骤是 先安装 VirtualBox 和 Vagrant 到用户目录 也就是进入 C:\\Users\\elick 以后 git clone https://github.com/laravel/homestead.git Homestead 最好不要用composer 用Git吧 这个比较方便 和上个版本不一样了 进入 Homestead 用命令生成配置文件 bash init.sh 或者点击init.bat 这样生成C:\\Users\\ 你的用户名 .homestead 目录并且在目录下生成配置文件 然后这步很关键了 进入刚才git clone下来的 Homestead 目录 在这个目录下 vagrant up 其他目录使用这个命令是没用的 只有在这个目录里使用才可以 这样就生成了全局虚拟机 几个有用的命令12vagrant destroy --force //删除命令vagrant reload --provision //更新配置文件 好像说是更新网站配置文件 注意: vagrant up 必须在 Homestead 目录下使用,还有就是直接启动虚拟机的话,那么 Homestead.yaml的配置就会失效,所以必须用 vagrant up 来启动虚拟机. *说明: 其实主要是挂载共享目录问题,端口是没问题的,只不过是默认端口,不是你配置的那个.所以你需要进入虚拟机后 手动挂载共享目录,这样也可以用的,只不过何必跟自己找麻烦,还是老实用vagrant up吧 一些文章地址 windows 安装laravel Homestead vagrant打造自己的开发环境~~我也来一发 1+1&gt;2:用Docker和Vagrant构建简洁高效开发环境 {Laravel 5.2 文档} 开始 —— Laravel Homestead Laravel Homestead 学院翻译的不完全 下面半段没翻译 所以还得看原版","categories":[],"tags":[{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"},{"name":"vagrant","slug":"vagrant","permalink":"http://elickzhao.github.io/tags/vagrant/"}]},{"title":"自己的docker开发环境 -- 自我版","slug":"自己的docker开发环境 -- 自我版","date":"2016-05-04T09:49:40.000Z","updated":"2021-09-09T16:34:45.730Z","comments":true,"path":"2016/05/自己的docker开发环境 -- 自我版/","link":"","permalink":"http://elickzhao.github.io/2016/05/%E8%87%AA%E5%B7%B1%E7%9A%84docker%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%20--%20%E8%87%AA%E6%88%91%E7%89%88/","excerpt":"这世界变化快啊 我刚学会这个 又出新东西了基于Kubernetes构建Docker集群管理详解Docker Machine + Compose + Swarm让Docker功能更强大的10个开源工具连接容器 –link 简要说明 懒人的最爱 – 下载快速用为了方便急用的同志们,把仓库和配置方法放在最前面,如果想学习的请往下看 仓库地址: https://github.com/elickzhao/docker-study 配置方法 进入dockerfiles目录, 修改配置文件docker-compose.yml123456789101112131415161718192021222324252627282930313233343536data: build: ./data volumes: - &quot;/c/Users/elick/myapp:/data:rw&quot; #这里修改 &#x27;/c/Users/elick/myapp&#x27; 为你主机上要共享的目录 privileged: true mysql: build: ./mysql volumes_from: - data volumes: - &quot;/c/Users/elick/myapp/db/mysql:/var/lib/mysql&quot; #这里修改 &#x27;/c/Users/elick/myapp&#x27; 为你主机上要共享的目录 environment: - MYSQL_ROOT_PASSWORD=123456 #根据你的需要修改数据库密码 ports: - &quot;3306:3306&quot; #根据需要修改数据库端口php: build: ./php expose: - &quot;9000&quot; volumes_from: - data links: - mysql privileged: truenginx: build: ./nginx volumes_from: - data volumes: - &quot;/c/Users/elick/myapp/nginx/nginx.conf:/etc/nginx/nginx.conf&quot; #这里修改 &#x27;/c/Users/elick/myapp&#x27; 为你主机上要共享的目录 links: - php:php ports: - &quot;80:80&quot; #根据需要修改web服务器端口 privileged: true 使用 docker-composer up 建立并启动容器 如果除了data容器 全部启动的话 并且浏览localhost也没错的话 那么你就拥有了最新的php环境了","text":"这世界变化快啊 我刚学会这个 又出新东西了基于Kubernetes构建Docker集群管理详解Docker Machine + Compose + Swarm让Docker功能更强大的10个开源工具连接容器 –link 简要说明 懒人的最爱 – 下载快速用为了方便急用的同志们,把仓库和配置方法放在最前面,如果想学习的请往下看 仓库地址: https://github.com/elickzhao/docker-study 配置方法 进入dockerfiles目录, 修改配置文件docker-compose.yml123456789101112131415161718192021222324252627282930313233343536data: build: ./data volumes: - &quot;/c/Users/elick/myapp:/data:rw&quot; #这里修改 &#x27;/c/Users/elick/myapp&#x27; 为你主机上要共享的目录 privileged: true mysql: build: ./mysql volumes_from: - data volumes: - &quot;/c/Users/elick/myapp/db/mysql:/var/lib/mysql&quot; #这里修改 &#x27;/c/Users/elick/myapp&#x27; 为你主机上要共享的目录 environment: - MYSQL_ROOT_PASSWORD=123456 #根据你的需要修改数据库密码 ports: - &quot;3306:3306&quot; #根据需要修改数据库端口php: build: ./php expose: - &quot;9000&quot; volumes_from: - data links: - mysql privileged: truenginx: build: ./nginx volumes_from: - data volumes: - &quot;/c/Users/elick/myapp/nginx/nginx.conf:/etc/nginx/nginx.conf&quot; #这里修改 &#x27;/c/Users/elick/myapp&#x27; 为你主机上要共享的目录 links: - php:php ports: - &quot;80:80&quot; #根据需要修改web服务器端口 privileged: true 使用 docker-composer up 建立并启动容器 如果除了data容器 全部启动的话 并且浏览localhost也没错的话 那么你就拥有了最新的php环境了 几点需要注意的 首先你需要有docker-composer 如果你在windows下 那就下载 docker toolbox 这个默认安装了 linux下的话 我那个仓库里已经下好了 把仓库克隆下来 并共享此目录 就是替换/c/Users/elick/myapp 我这个目录 data容器指向的就是这个目录 指向时一定要是绝对路径 还有就是 windows下 要写虚拟机内的地址 不要写成windows的地址 也就是把此目录已经共享给虚拟机了 因为windows下 容器是运行在虚拟机内的 目录结构简单说明下12345678910111213myapp├─db│ └─mysql #数据保存地址├─dockerfiles│ ├─data│ ├─mysql│ ├─nginx│ └─php├─logs ├─nginx #nginx配置文件放在这里│ └─conf.d #虚拟主机配置文件└─www #网站内容 └─public 好快速搭建说到这里,喜欢唠叨的可以往下看.#下面不用看了 自己弄时的一些记录 估计没人能看懂 心路历程 单一进程容器大坑无数的nginx 单一进程容器,也就是一个服务放在一个容器里 Nginx dockerfile 1234567891011121314151617181920212223242526# Apply Nginx configuration#终于知道这句的用处了 因为每次ip都是变的#所以不能直接在这里复制到配置出 #因为第一次改变后 第二次启动就找不到替换的变量了 #看启动那个shell就明白了#ADD nginx.conf /opt/etc/nginx.confADD nginx.conf /etc/nginx/nginx.conf# Nginx startup script#再一次修改了 因为发现直接用 hosts 里的本地域名就可以指向服务器了#ADD nginx-start.sh /opt/bin/nginx-start.sh#RUN chmod u=rwx /opt/bin/nginx-start.shRUN mkdir -p /data/nginx/conf.d/VOLUME [&quot;/data&quot;]#不能执行 是找不到 sed 命令#ENTRYPOINT sed -i &quot;s/%fpm-ip%/$PHP_PORT_9000_TCP_ADDR/&quot; /etc/nginx/nginx.conf#ENTRYPOINT /etc/nginx/nginx-start.shWORKDIR /opt/bin#ENTRYPOINT [&quot;/opt/bin/nginx-start.sh&quot;]#CMD [&quot;true&quot;]CMD [&quot;nginx&quot;] 执行命令建立镜像并启动容器 1234$ docker build -t elick/nginx .$ docker run --name myapp-nginx -p 80:80 --volumes-from myapp-data -v /c/Users/elick/myapp/new/nginx/nginx.conf:/etc/nginx/nginx.conf --link myapp-php:php -d elick/nginx 这个nginx有个问题是php-fpm的ip无法得到 必须启动后手动该nginx.conf才行 以前看那个人家使用nginx-start.sh启动 可是到我这命令始终出错 说找不到文件 而且莫名其妙的在每行结尾有个/r的标 而且用#!/bin/bash定义shell也报错 真天了噜 按道理是 link myapp-php 通过环境变量取得ip 可是就这个shell命令不好使无法进行下去了-p 80 只是指向 容器端口 host端口是随机的 第一个坑,因为需要连接php容器,所以配置文件里需要php服务器的地址,一开始的解决方法是写个shell文件,读取环境变量,因为link以后容器内会包含php容器的环境变量,但是这个shell死活报错,就是下面说的那个问题. 利用命令行已经成功建城环境,不过用docker-composer就遇到问题了问题终于解决了 原来是shell脚本文件的问题 windows下编辑的文本放到linux就会有格式问题 具体解决看这里 第二个坑,当时直接把配置文件拷贝到/etc/nginx/nginx.conf 但是每次启动IP都会变化 但是替换变量已经,被替换过了.所以改写了shell 每次都重新复制一遍nginx.conf到/etc/nginx/nginx.conf 然后再去替换才行 第三个坑,在shell不行的时候,想过用dockerfile执行命令 直接替换,于是发现了 RUN,ENTRYPOINT,CMD 三个命令执行的差别 具体看这里(总结 Dockerfile 一些命令说明) 但是ENTRYPOINT 执行时 sed命令却没有 不知道为什么没深入研究 经过上面痛苦的经历,最后找到了办法,原来link后会写个静态地址到hosts,所以根本不用那么麻烦,直接在配置文件里写 服务器名称就ok 这个名称就是 –link myapp-php:php 后面php这个别名 具体说明看这里连接容器 –link 简要说明 坑少了不少的 php 1234567891011121314151617FROM php:fpmRUN mkdir -p /dataVOLUME [&quot;/data&quot;]RUN apt-get update &amp;&amp; apt-get install -y \\ libfreetype6-dev \\ libjpeg62-turbo-dev \\ libmcrypt-dev \\ libpng12-dev \\ &amp;&amp; docker-php-ext-install -j$(nproc) iconv mcrypt \\ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \\ &amp;&amp; docker-php-ext-install -j$(nproc) gd \\ #这个mysqli是我自己添加的 不过这个好像已经下载好了 所以直接install就可以了 没有的恐怕需要上面的apt-get 下载下来才行 不过不知道下载后保存的位置会不会错 因为我自己下了个mysqli 不过在容器里用命令安装时却说找不到 &amp;&amp; docker-php-ext-install -j$(nproc) mysqliCMD [&quot;php-fpm&quot;] 有link 那么 暴露端口其实没用 只要在dockerfile的 EXPOSE 9000 把端口暴露给容器即可 所以没有 -p 9000:9000 暴露端口也没事 12345$ docker build -t elick/php . #这里可是有个点的啊$ docker run --name myapp-php -p 9000:9000 --volumes-from myapp-data -d elick/php#newdocker run --name myapp-php --link db:mysql --volumes-from myapp-data -d elick/php 这里有一个坑,就是扩展php,因为官方镜像竟然没有mysqli 所以没办法只能自己弄,本来都想放弃了,后来还是平心静气看了下鸟语文档,才发现人家已经准备好命令来解决,只不过我只加了mysqli后没有再深入研究了 解决上面的问题mysql就没难度了 1234567FROM mysqlMAINTAINER &quot;elick&quot; &lt;xwiwi@foxmail.com&gt;RUN mkdir -p /dataVOLUME [&quot;/data&quot;]CMD [&quot;mysqld&quot;] 12$ docker build -t elick/mysql .$ docker run --name myapp-mysql --volumes-from myapp-data -v /c/Users/elick/myapp/db/mysql:/var/lib/mysql -d elick/mysql 以上都搞懂了 其实mysql就没什么了 其他的相加的服务也是一样 $ docker run –name myapp-data -v /c/Users/elick/myapp/:/data:rw -it elick/data/bin/bash 用php代码 取得容器环境变量 从而能连接到mysql 可以试一下能够获取环境变量 但是只能获取和自己相关的 因为使用的用户 是php那个用户 也就是 www-data 并不是root 所以没法看到完整的env环境变量 我又个下策 就是建立容器时 用shell把环境变量写到 一个文件里 然后读出来 要不然每次启动 连接数据库 还得改php文件 这有点问题啊 蠢死了 原来这么简单 就像link那篇文章里写的 –link 会写入hosts 那么 –link mysql:mysql 那么就会用这个别名 放到 hosts 这样可以直接用这个别名来当服务器名 也就是网址了 看来想的没错 Nginx 里的ip 也是只要用 php 就可以了 只要yaml里配置的别名是正确的就 哦了 123$servername = &quot;mysql&quot;;$username = &quot;root&quot;;$password = &quot;123456&quot;; myapp-data 一点小小的问题使用数据容器 用docker-composer 建立时 容器不会启动 但是共享内容还是好使的 究原因 是因为docker是一次性执行 如果没有挂起任务 就会自动关闭 解决办法 手动建立这个容器 $ docker run --name myapp-data -v /c/Users/elick/myapp/:/data:rw -it elick/data /bin/bash 千万不要用 -d 要不容器还是启动不起来 或者自己写个死循环程序 然后启动时 执行这个程序 但是坏处是 当你关闭容器时 会造成麻烦 具体看这篇文章 通过信号解决docker启动容器后Exited退出的问题 连接mysql居然还需要本地ip才可以 真实麻烦啊 另一种形式的环境 就是把nginx和php放到一个容器里 这样省去了很多麻烦推荐用这个仓库 这个比较好用一些 https://github.com/skiy-dockerfile/nginx-php7看来只能使用nginx和php绑定到一起的 因为这样都在同一个服务器 所以使用127.0.0.1 就可以了 而且这种形式也不错 因为根本也没什么必要把他们分开 如有扩展可以前台再加nginx指向这个nginx 过去的总结 这个已经过时了遇到了好多个坑,为了把php-fpm的ip传给nginx,折腾的要死啊! 使用 –link 虽然nginx容器有了 php容器的环境变量IP地址 但是得把这个IP放到nginx.conf里才行 所以需要做些动作 刚开始想放到Dockerfile里 用了 RUN sed -i &quot;s/%fpm-ip%/$PHP_PORT_9000_TCP_ADDR/&quot; /etc/nginx/nginx.conf 但是RUN只在image里 执行也就是说此时容器没有启动 所以环境变量还没有 于是乎用了 ENTRYPOINT 这个是可以 但是就是上面提到的 shell错误问题 却一直没往这方面想 所以走了弯路 其实还用了 CMD 但是好像并没有 执行命令 还得进入容器启动 不知道为什么 也懒得找了","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://elickzhao.github.io/tags/docker/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}]},{"title":"Github 更新标签","slug":"Github 更新标签","date":"2016-05-03T15:02:25.000Z","updated":"2021-09-09T16:34:44.918Z","comments":true,"path":"2016/05/Github 更新标签/","link":"","permalink":"http://elickzhao.github.io/2016/05/Github%20%E6%9B%B4%E6%96%B0%E6%A0%87%E7%AD%BE/","excerpt":"","text":"不知道为什么 我用TortoiseGit在本地打上了标签 但是同步的时候 Github却不显示 使用了 git bash 命令 推送了一下就好使了 1git push --tags 参考文章:Git查看、删除、重命名远程分支和tag","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://elickzhao.github.io/tags/Git/"}]},{"title":"连接容器 --link 简要说明","slug":"连接容器 --link 简要说明","date":"2016-05-02T15:40:34.000Z","updated":"2021-09-09T16:34:45.749Z","comments":true,"path":"2016/05/连接容器 --link 简要说明/","link":"","permalink":"http://elickzhao.github.io/2016/05/%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8%20--link%20%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E/","excerpt":"","text":"docker容器互联的两种方式连接容器 | Docker中文指南Docker多容器连接-以Nginx+PHP为例Docker学习总结之跨主机进行linkDocker Machine + Compose + Swarm让Docker功能更强大的10个开源工具 这里简单说明下 docker –link 的作用可以参考下面dockerfile文件.如果需要连接mysql容器 只要 docker –link mysql 即可 不需要暴露端口 只要dockerfile里有 expose参数 暴露默认端口 3306 就可以了使用–link 会在hosts文件里 加入一个静态ip地址 以你连接的别名命名的 如果没有别名 就是容器名 例如 mysql 172.17.0.3 所以当你需要连接mysql容器时 只需要在配置文件里写服务器地址为 mysql 就可以了 会自动为你解析成当期容器ip的 因为每次容器启动ip都会变化 根据参考文章说明 此方法试用单个服务器 即所有容器都在一个服务器上 分散的服务器还得需要别的方法 暴露端口或者共享一个连接容器 还有新的方法就是docker Swarm 创建个集群 还有docker kubernetes 这个google的 前一个是docker自己的 还有这个 Shipyard 好像也不错的样子 唉 东西太多了 根本看不过来啊 12345678910111213141516171819202122232425mysql: build: ./mysql volumes_from: - myapp-data environment: - MYSQL_ROOT_PASSWORD=123456php: build: ./php expose: - &quot;9000:9000&quot; volumes_from: - myapp-data links: - mysql privileged: truenginx: build: ./nginx volumes_from: - myapp-data links: - php:php ports: - &quot;80:80&quot; privileged: true","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://elickzhao.github.io/tags/docker/"}]},{"title":"Docker Compose 配置文件 yaml  参数简单介绍","slug":"Docker Compose 配置文件 yaml  参数简单介绍","date":"2016-05-02T15:35:58.000Z","updated":"2021-09-09T16:34:44.884Z","comments":true,"path":"2016/05/Docker Compose 配置文件 yaml  参数简单介绍/","link":"","permalink":"http://elickzhao.github.io/2016/05/Docker%20Compose%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20yaml%20%20%E5%8F%82%E6%95%B0%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","excerpt":"一般情况的用法 12345678910111213141516171819202122232425mysql: build: ./mysql volumes_from: - myapp-data environment: - MYSQL_ROOT_PASSWORD=123456php: build: ./php expose: - &quot;9000:9000&quot; volumes_from: - myapp-data links: - mysql privileged: truenginx: build: ./nginx volumes_from: - myapp-data links: - php:php ports: - &quot;80:80&quot; privileged: true","text":"一般情况的用法 12345678910111213141516171819202122232425mysql: build: ./mysql volumes_from: - myapp-data environment: - MYSQL_ROOT_PASSWORD=123456php: build: ./php expose: - &quot;9000:9000&quot; volumes_from: - myapp-data links: - mysql privileged: truenginx: build: ./nginx volumes_from: - myapp-data links: - php:php ports: - &quot;80:80&quot; privileged: true 配置参数 说明 image 从镜像的构建容器 build 直接从pwd的Dockerfile来build，而非通过image选项来pull links 连接到那些容器。每个占一行，格式为SERVICE[:ALIAS],例如 – db[:database] 如果不写别名 就是一致的 这个别名 会写在hosts里 当作服务器名 这样可以直接用于连接容器服务 external_links 连接到该compose.yaml文件之外的容器中，比如是提供共享或者通用服务的容器服务。格式同links command 替换默认的command命令 ports 导出端口 主机端口:容器端口 expose 导出端口，但不映射到宿主机的端口上。它仅对links的容器开放。格式直接指定端口号即可。 volumes 加载路径作为卷, 主机路径:容器路径:rw(读写属性) 容器路径必须是绝对路径 volumes_from 加载其他容器 服务所有卷 env_file 从一个文件中导入环境变量，文件的格式为RACK_ENV=development extends 扩展另一个服务，可以覆盖其中的一些选项 看下面 例1 net 容器的网络模式，可以为”bridge”, “none”, “container:[name or id]”, “host”中的一个。 dns 可以设置一个或多个自定义的DNS地址。 dns_search 可以设置一个或多个DNS的扫描域。 orking_dir, entrypoint, user, hostname, domainname, mem_limit, privileged, restart, stdin_open, tty, cpu_shares，docker run 这些命令都是单行的命令,效果和Dockerfile是一样的 看例2 例1 12345678910111213141516common.ymlwebapp: build:./webapp environment:- DEBUG=false- SEND_EMAILS=false----------------------------------------------------------development.ymlweb:extends: file: common.yml service: webapp ports:-&quot;8000:8000&quot; links:- db environment:- DEBUG=truedb: image: postgres 例2 1234567891011cpu_shares:73working_dir:/codeentrypoint: /code/entrypoint.shuser: postgresqlhostname: foodomainname: foo.commem_limit:1000000000privileged:truerestart: alwaysstdin_open:truetty:true 常用命令说明 命令参数 说明 docker-compose up 启动服务器 -d 以daemon(守护进程)方式启动容器 –verbose 输出详细信息 -f 制定一个非docker-compose.yml命名的yaml文件 -p 设置一个项目名称（默认是directory名） build 构建服务 kill -s SIGINT 给服务发送特定的信号 logs 输出日志 port 输出绑定的端口 ps 输出运行的容器 pull pull服务的image rm 删除停止的容器 run 运行某个服务，例如docker-compose run web python manage.py shell start 运行某个服务中存在的容器 stop 停止某个服务中存在的容器 up create + run + attach容器到服务 scale 设置服务运行的容器数量。例如：docker-compose scale web=2 worker=3 感觉有些命令和docker命令重合 所以感觉有些命令没什么用处 Docker Compose YAML 模板文件","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://elickzhao.github.io/tags/docker/"}]},{"title":"windows下如何生成 github 和 gitoschina 的 ssh 公钥 -- 更新版","slug":"windows下如何生成 github 和 gitoschina 的 ssh 公钥 -- 更新版","date":"2016-05-01T12:54:10.000Z","updated":"2021-09-09T16:34:45.482Z","comments":true,"path":"2016/05/windows下如何生成 github 和 gitoschina 的 ssh 公钥 -- 更新版/","link":"","permalink":"http://elickzhao.github.io/2016/05/windows%E4%B8%8B%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%20github%20%E5%92%8C%20gitoschina%20%E7%9A%84%20ssh%20%E5%85%AC%E9%92%A5%20--%20%E6%9B%B4%E6%96%B0%E7%89%88/","excerpt":"这个文档已经更新了三次了,所以看时要仔细阅读下. 安装git，从程序目录打开 “Git Bash” 键入命令：ssh-keygen -t rsa -C “&#x65;&#109;&#97;&#105;&#108;&#64;&#101;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;““&#101;&#x6d;&#x61;&#105;&#108;&#x40;&#x65;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;“是github账号 提醒你输入key的名称，输入如id_rsa 在C:\\Documents and Settings\\Administrator\\下产生两个文件：id_rsa和id_rsa.pub 把4中生成的密钥文件复制到C:\\Documents and Settings\\Administrator.ssh\\ 目 录下。 用记事本打开id_rsa.pub文件，复制内容，在github.com的网站上到ssh密钥管理页面，添加新公钥，随便取个名字，内容粘贴刚 才复制的内容。7. ^_^ OK了 需要注意步骤2中产生的密钥文件在当前用户的根目录，必须把这两个文件放到当前用户目录的“.ssh”目录下才能生效。在windows中只能在命令行下输入创建”.”开头的文件夹。命令为 mkdir .ssh","text":"这个文档已经更新了三次了,所以看时要仔细阅读下. 安装git，从程序目录打开 “Git Bash” 键入命令：ssh-keygen -t rsa -C “&#x65;&#109;&#97;&#105;&#108;&#64;&#101;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;““&#101;&#x6d;&#x61;&#105;&#108;&#x40;&#x65;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;“是github账号 提醒你输入key的名称，输入如id_rsa 在C:\\Documents and Settings\\Administrator\\下产生两个文件：id_rsa和id_rsa.pub 把4中生成的密钥文件复制到C:\\Documents and Settings\\Administrator.ssh\\ 目 录下。 用记事本打开id_rsa.pub文件，复制内容，在github.com的网站上到ssh密钥管理页面，添加新公钥，随便取个名字，内容粘贴刚 才复制的内容。7. ^_^ OK了 需要注意步骤2中产生的密钥文件在当前用户的根目录，必须把这两个文件放到当前用户目录的“.ssh”目录下才能生效。在windows中只能在命令行下输入创建”.”开头的文件夹。命令为 mkdir .ssh 以上的方法有可能存在问题使用 Git Bash 生成的公钥与私钥 放到github 经过测试 ssh -T git@github.com 却返回禁止访问 第三次更新.如图一 虽然显示github好像没有通过.但如图二,其实是能更新github的.这里还要注意一下当使用测试命令的时候会自动添加ip到 known_hosts 如果没有这个的话会报错如图三. 这次因为用Vagrant ssh 需要ssh程序所以下载了 cygwin 注意:cygwin的ssh也不是默认的 需要选择下载 用这里的ssh生成的密钥就可以了 生成的方法跟上面是一致的 不过这个密钥的存放位置需要找一下 就是在cygwin的安装目录下的/home里面 /home/elick/.ssh/id_rsa 这里是cygwin默认的家目录然后把公钥复制到github和oschina 用命令测试 ssh -T git@git.oschina.net 返回欢迎就ok了参考文档 但还有个问题 Git Tortoise用的是putty密钥 所以这个密钥虽然测试成功 但是不能用客户端来用 这个有空看看怎么办 上面那个问题已经 解决了 解决的文章在这里 简单说明一下 就是 GitTortoise 会自带一个 putty 密码生成工具 用这个工具转换 这个密码 并用 Git Tortoise 另一个工具 Pageant 把密码填进去 以后提交git时 这个工具帮你自动转换putty密码了 同步的时候 GitTortoise有个选项转换密码 勾上就行了 详情还是看上面的那个文章","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://elickzhao.github.io/tags/Git/"},{"name":"ssh","slug":"ssh","permalink":"http://elickzhao.github.io/tags/ssh/"}]},{"title":"常用的apt-get命令","slug":"常用的apt-get命令","date":"2016-04-30T16:15:51.000Z","updated":"2021-09-09T16:34:45.634Z","comments":true,"path":"2016/05/常用的apt-get命令/","link":"","permalink":"http://elickzhao.github.io/2016/05/%E5%B8%B8%E7%94%A8%E7%9A%84apt-get%E5%91%BD%E4%BB%A4/","excerpt":"apt-get update：在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。 apt-get install packagename：安装一个新软件包 apt-get remove packagename：卸载一个已安装的软件包（保留配置文件） apt-get remove package - - purge: 删除包，包括删除配置文件等 apt-get clean：这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。 apt-get upgrade：更新所有已安装的软件包 apt-get dist-upgrade：将系统升级到新版本 apt-cache search package 搜索包","text":"apt-get update：在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。 apt-get install packagename：安装一个新软件包 apt-get remove packagename：卸载一个已安装的软件包（保留配置文件） apt-get remove package - - purge: 删除包，包括删除配置文件等 apt-get clean：这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。 apt-get upgrade：更新所有已安装的软件包 apt-get dist-upgrade：将系统升级到新版本 apt-cache search package 搜索包 apt-cache show package 获取包的相关信息，如说明、大小、版本等 apt-get install package - - reinstall 重新安装包 apt-get -f install 修复安装”-f = ——fix-missing” apt-get install build-essential 配置c/c++ compile环境 apt-cache depends package 了解使用依赖 apt-cache rdepends package 是查看该包被哪些包依赖 apt-get build-dep package 安装相关的编译环境 apt-get source package 下载该包的源代码 apt-get check 检查是否有损坏的依赖 apt-get autoclean：定期运行这个命令来清除那些已经卸载的软件包的.deb文件。 apt-get autoremove :自动清除不需要的程序包。 aptitude 比apt-get更加好的选择 当一些依赖无法正确安装时可以用这个命令试试, 不过得先安装 dpkg —- apt-get —— aptitude 三种方式的区别 及命令格式apt-get靠边，用aptitude解决比较复杂的软件关系apt-get和aptitude的区别","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://elickzhao.github.io/tags/ubuntu/"}]},{"title":"Linux下怎样搜索文件","slug":"Linux下怎样搜索文件","date":"2016-04-30T13:39:59.000Z","updated":"2021-09-09T16:34:44.966Z","comments":true,"path":"2016/04/Linux下怎样搜索文件/","link":"","permalink":"http://elickzhao.github.io/2016/04/Linux%E4%B8%8B%E6%80%8E%E6%A0%B7%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6/","excerpt":"使用linux系统难免会忘记文件所在的位置，可以使用以下命令对系统中的文件进行搜索。搜索文件的命令为”find“；”locate“；”whereis“；”which“；”type“ findlinux下最强大的搜索命令为”find“。它的格式为 find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;；比如使用find命令搜索在根目录下的所有interfaces文件所在位置，命令格式为 find / -name &#39;interfaces&#39; 查找当前目录下以@开头的文件或者目录，搜索深度为一级也就是只在当前目录找，不进入子目录find . -maxdepth 1 -name &quot;@*&quot;","text":"使用linux系统难免会忘记文件所在的位置，可以使用以下命令对系统中的文件进行搜索。搜索文件的命令为”find“；”locate“；”whereis“；”which“；”type“ findlinux下最强大的搜索命令为”find“。它的格式为 find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;；比如使用find命令搜索在根目录下的所有interfaces文件所在位置，命令格式为 find / -name &#39;interfaces&#39; 查找当前目录下以@开头的文件或者目录，搜索深度为一级也就是只在当前目录找，不进入子目录find . -maxdepth 1 -name &quot;@*&quot; locate使用locate搜索linux系统中的文件，它比find命令快。因为它查询的是数据库(/var/lib/locatedb)，数据库包含本地所有的文件信息。使用locate命令在根目录下搜索interfaces文件的命令为 locate interfaces whereis使用”whereis“命令可以搜索linux系统中的所有可执行文件即二进制文件。使用whereis命令搜索grep二进制文件的命令为 whereis grep。 which使用which命令查看系统命令是否存在，并返回系统命令所在的位置。使用which命令查看grep命令是否存在以及存在的目录的命令为 which grep。 type使用type命令查看系统中的某个命令是否为系统自带的命令。使用type命令查看cd命令是否为系统自带的命令；查看grep 是否为系统自带的命令。type cd type grep","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"}]},{"title":"PHP 获取服务器详细信息代码","slug":"PHP 获取服务器详细信息代码","date":"2016-04-29T15:37:15.000Z","updated":"2021-09-09T16:34:45.013Z","comments":true,"path":"2016/04/PHP 获取服务器详细信息代码/","link":"","permalink":"http://elickzhao.github.io/2016/04/PHP%20%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E4%BB%A3%E7%A0%81/","excerpt":"说明一下为什么写这个.因为docker的link时需要取得环境变量里面的mysql容器的IP地址,所以想用php取得容器的环境变量.原本想用 $_ENV[] 发现没有内容 原来需要修改 php.ini 里面 variables_order = &quot;EGPCS&quot;上述配置表示PHP 接受的外部变量来源及顺序，EGPCS 是Environment、Get、Post、Cookies 和Server 的缩写。如果variables_order 的配置中缺少E ，则PHP 无法接受环境变量，那么$_ENV 也就为空了。 后来想到用 php 执行 shell 命令 使用exec , system , shell_exec 但还是获取不到 好赖用 system(env) 才发现原来是我登录的用户为 www-data 所以根本获取不到额外的环境变量 所以这个想法只能作罢, 至于下面 是顺手总结的 一些全局变量的用法","text":"说明一下为什么写这个.因为docker的link时需要取得环境变量里面的mysql容器的IP地址,所以想用php取得容器的环境变量.原本想用 $_ENV[] 发现没有内容 原来需要修改 php.ini 里面 variables_order = &quot;EGPCS&quot;上述配置表示PHP 接受的外部变量来源及顺序，EGPCS 是Environment、Get、Post、Cookies 和Server 的缩写。如果variables_order 的配置中缺少E ，则PHP 无法接受环境变量，那么$_ENV 也就为空了。 后来想到用 php 执行 shell 命令 使用exec , system , shell_exec 但还是获取不到 好赖用 system(env) 才发现原来是我登录的用户为 www-data 所以根本获取不到额外的环境变量 所以这个想法只能作罢, 至于下面 是顺手总结的 一些全局变量的用法 功能 代码 备注 获取系统类型及版本号： php_uname() (例：Windows NT COMPUTER 5.1 build 2600) 只获取系统类型： php_uname(&#39;s&#39;) (或：PHP_OS，例：Windows NT) 只获取系统版本号： php_uname(&#39;r&#39;) 无 获取PHP运行方式： php_sapi_name() (PHP run mode：apache2handler) 获取前进程用户名： Get_Current_User() 无 获取PHP版本： PHP_VERSION 无 获取Zend版本： Zend_Version() 无 获取PHP安装路径： DEFAULT_INCLUDE_PATH 无 获取当前文件绝对路径： FILE 无 获取客户端IP： $_SERVER[&#39;REMOTE_ADDR&#39;] 无 获取服务器解译引擎： $_SERVER[&#39;SERVER_SOFTWARE&#39;] 无 获取服务器CPU数量： $_SERVER[&#39;PROCESSOR_IDENTIFIER&#39;] 无 获取服务器系统目录： $_SERVER[&#39;SystemRoot&#39;] 无 获取服务器域名： `$_SERVER[‘SERVER_NAME’] (建议使用：$_SERVER[“HTTP_HOST”])` 获取用户域名： $_SERVER[&#39;USERDOMAIN&#39;] 无 获取服务器语言： $_SERVER[&#39;HTTP_ACCEPT_LANGUAGE&#39;] 无 获取服务器Web端口： $_SERVER[&#39;SERVER_PORT&#39;] 无 获取服务器IP： GetHostByName($_SERVER[&#39;SERVER_NAME&#39;]) 推荐 获取Http请求中Host值： $_SERVER[&quot;HTTP_HOST&quot;] 返回值为域名或IP 接受请求的服务器IP： $_SERVER[&quot;SERVER_ADDR&quot;] (有时候获取不到，) 在PHP网站开发中，为了满足网站的需要，时常需要对PHP环境变量进行设置和应用，在虚拟主机环境下，有时我们更需要通过PHP环境变量操作函 数来对PHP环境变量值进行设置。为此我们有必要对PHP环境变量先有所熟悉。今天和大家分享PHP环境变量$_SERVER和PHP系统常量的部分详细 说明。 PHP提供了很多默认的系统变量，用于获得系统配置信息、网络请求相关信息等。这些默认的系统变量及其作用如表2-1所示。 变量 作用 $GLOBALS[] 储存当前脚本中的所有全局变量，其KEY为变量名，VALUE为变量值 $_SERVER[] 当前WEB服务器变量数组 $_GET[] 存储以GET方法提交表单中的数据 $_POST[] 存储以POST方法提交表单中的数据 $_COOKIE[] 取得或设置用户浏览器Cookies中存储的变量数组 $_FILES[] 存储上传文件提交到当前脚本的数据 $_ENV[] 存储当前WEB环境变量 $_REQUEST[] 存储提交表单中所有请求数组，其中包括$_GET、$_POST、$_COOKIE和$_SESSION中的所有内容 $_SESSION[] 存储当前脚本的会话变量数组 配置文件的不同，在不同环境下显示的内容可能会有所不同。 与系统变量一样，PHP也提供了一些默认的系统常量供使用。在程序中可以随时应用这些系统常量，但是我们不能任意更改这些常量的值。PHP中常用的一些默认系统常量及其作用如表2-2所示。 常量 作用 FILE 存储当前脚本的绝对路径及文件名称 LINE 存储该常量所在的行号 FUNCTION 存储该常量所在的函数名称 CLASS 存储该常量所在的类的名称 PHP_VERSION 存储当前PHP的版本号 PHP_OS 存储当前服务器的操作系统 $_GET 和$_POST主要针对FORM表单提交的数据， $_COOKIE和$_SESSION主要针对客户端游览器和服务器端会话数据。 $_FILES主要针对文件上传时提交的数据， $_REQUEST主要针对提交表单中所有请求数组，包括$_GET、$_POST、 $_COOKIE中的所有内容，你可以通过print_r函数分别输出$_REQUEST或者$_COOKIE等进行比较。 PHP环境变量$_SERVER简介 是一个包含服务器端相关信息的PHP全局环境变量，在PHP4.1.0之前的版本使用$HTTP_SERVER_VARS。 $_SERVER[&#39;PHP_SELF&#39;] 当前正在执行脚本的文件名，与 document root相关。在FORM表单中，如执行文件是本身，你可以在ACTION中使用$_SERVER[&#39;PHP_SELF&#39;]，好处是当执行文件名有变动时可以不去频繁替换ACTION中的文件名。 变量 作用 $_SERVER[&#39;SERVER_NAME&#39;] 当前运行的PHP程序所在服务器主机的名称。 $_SERVER[&#39;REQUEST_METHOD&#39;] 访问页面时的请求方法，即GET、HEAD、POST、PUT。 $_SERVER[&#39;DOCUMENT_ROOT&#39;] 当前运行的PHP程序所在的文档根目录。也就是PHP.INI文件中的定义。 $_SERVER[&#39;HTTP_REFERER&#39;] 链接到当前页面的前一页面的URL地址。在页面跳转功能中非常有用。 $_SERVER[&#39;REMOTE_ADDR&#39;] 正在浏览当前页面访问者的IP地址。 $_SERVER[&#39;REMOTE_HOST&#39;] 正在浏览当前页面用户的主机名。 $_SERVER[&#39;REMOTE_PORT&#39;] 正在游览的用户连接到服务器时所使用的端口。 $_SERVER[&#39;SCRIPT_FILENAME&#39;] 当前执行脚本的绝对路径名。 $_SERVER[&#39;SERVER_PORT&#39;] 服务器所使用的端口 $_SERVER[&#39;SCRIPT_NAME&#39;] 包含当前脚本的路径。这在页面需要指向自己时非常有用。 $_SERVER[&#39;REQUEST_URI&#39;] 访问此页面所需的URI。如“/index.html”。 $_SERVER[&#39;PHP_AUTH_USER&#39;] 应用在HTTP用户登录认证功能中，这个变量是用户输入的用户名。 $_SERVER[&#39;PHP_AUTH_PW&#39;] 应用在HTTP用户登录认证功能中，这个变量便是用户输入的密码。 $_SERVER[&#39;AUTH_TYPE&#39;] 应用在HTTP用户登录认证功能中，这个变量便是认证的类型。 注：上述提到的这些PHP全局环境变量，在php.ini中的register_globals设置为on时，这些变量在所有PHP程序脚本中都可用，也就是$_SERVER数组被分离了。当然为了安全考虑，还是不要将register_globals打开为好。 PHP环境变量$_SERVER的更多信息请参考PHP帮助手册，文章开头提到在虚拟主机环境下我们需要通过PHP环境变量操作函数来对PHP环境变量值进行设置，主要用到ini_set和ini_get，其实还有更多此类函数，比如PHP中的错误报告设置等，其实都涉及到PHP.INI中的相关内容，有机会下次分享。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"}]},{"title":"脚本报错没有那个文件或目录","slug":"脚本报错没有那个文件或目录","date":"2016-04-28T15:26:00.000Z","updated":"2021-09-09T16:34:45.725Z","comments":true,"path":"2016/04/脚本报错没有那个文件或目录/","link":"","permalink":"http://elickzhao.github.io/2016/04/%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/","excerpt":"","text":"shell脚本报错：#!binbash 没有那个文件或目录 在Windows下编辑的，文件每行末尾会多出^M，所以先转格式： linux下有个 dos2unix 脚本文件 可以转换 windows下可以使用 Notepad++ 编辑文件 或者 使用 菜单-&gt;编辑-&gt;文档格式转换 来转换文件格式","categories":[],"tags":[{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"}]},{"title":"总结 Dockerfile 一些命令说明","slug":"总结 Dockerfile 一些命令说明","date":"2016-04-27T15:44:57.000Z","updated":"2021-09-09T16:34:45.655Z","comments":true,"path":"2016/04/总结 Dockerfile 一些命令说明/","link":"","permalink":"http://elickzhao.github.io/2016/04/%E6%80%BB%E7%BB%93%20Dockerfile%20%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E/","excerpt":"Dockerfile是一个镜像的表示，可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器所有的 Dockerfile 命令格式都是:INSTRUCTION arguments虽然指令忽略大小写，但是建议使用大写。 FROM 命令1FROM &lt;image&gt; 或 1FROM &lt;image&gt;:&lt;tag&gt; 这个设置基本的镜像，为后续的命令使用，所以应该作为Dockerfile的第一条指令。 比如: 1FROM ubuntu 如果没有指定 tag ，则默认tag是latest，如果都没有则会报错。 CMD 命令有三种格式: 123CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (like an exec, preferred form)CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)CMD command param1 param2 (as a shell) 一个Dockerfile里只能有一个CMD，如果有多个，只有最后一个生效。这是为了引用镜像时避免启动服务器而无法配置 所以你可以在最后再写个CMD从而屏蔽原镜像的命令","text":"Dockerfile是一个镜像的表示，可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器所有的 Dockerfile 命令格式都是:INSTRUCTION arguments虽然指令忽略大小写，但是建议使用大写。 FROM 命令1FROM &lt;image&gt; 或 1FROM &lt;image&gt;:&lt;tag&gt; 这个设置基本的镜像，为后续的命令使用，所以应该作为Dockerfile的第一条指令。 比如: 1FROM ubuntu 如果没有指定 tag ，则默认tag是latest，如果都没有则会报错。 CMD 命令有三种格式: 123CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (like an exec, preferred form)CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)CMD command param1 param2 (as a shell) 一个Dockerfile里只能有一个CMD，如果有多个，只有最后一个生效。这是为了引用镜像时避免启动服务器而无法配置 所以你可以在最后再写个CMD从而屏蔽原镜像的命令 RUN 命令RUN命令会在上面FROM指定的镜像里执行任何命令，然后提交(commit)结果，提交的镜像会在后面继续用到。 两种格式: 1RUN &lt;command&gt; (the command is run in a shell - `/bin/sh -c`) 或: 12345RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ... ] (exec form)#RUN命令等价于:docker run image commanddocker commit container_id #ENTRYPOINT 命令 有两种语法格式，一种就是上面的(shell方式): 1ENTRYPOINT cmd param1 param2 ... 第二种是 exec 格式: 1ENTRYPOINT [&quot;cmd&quot;, &quot;param1&quot;, &quot;param2&quot;...] 如: 1ENTRYPOINT [&quot;echo&quot;, &quot;Whale you be my container&quot;] ENTRYPOINT 命令设置在容器启动时执行命令 这样 –link 的其他容器环境变量用这个命令将会取得 这个可能是 和 RUN最大区别 RUN是生成容器时执行一次,还有个区别就是 ENTRYPOINT 和 CMD 一样只执行最后一个 RUN是可以执行多次的有一次使用sed命令时 RUN可以用 ENTRYPOINT 虽然能生成容器但是却启动不起来 那次用的Docker-composer 所以也不知道和那个是否有关 123456root@tankywoo-docker:~# cat DockerfileFROM ubuntuENTRYPOINT echo &quot;Welcome!&quot;root@tankywoo-docker:~# docker run 62fda5e450d5Welcome! 启动几次执行几次 最上面 Step 7 哪行命令 简要说明:RUN是在building image时会运行的指令, 在Dockerfile中可以写多条RUN指令.CMD和ENTRYPOINT则是在运行container 时会运行的指令, 都只能写一条, 如果写了多条, 则最后一条生效.CMD和ENTRYPOINT的区别是:CMD在运行时会被command覆盖, ENTRYPOINT不会被运行时的command覆盖, 但是也可以指定. ADD 命令从src复制文件到container的dest路径: 1ADD &lt;src&gt; &lt;dest&gt; &lt;src&gt; 是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url&lt;dest&gt; 是container中的绝对路径 VOLUME 命令1VOLUME [&quot;&lt;mountpoint&gt;&quot;] 如: 1VOLUME [&quot;/data&quot;] 创建一个挂载点用于共享目录 #USER 命令 比如指定 memcached 的运行用户，可以使用上面的 ENTRYPOINT 来实现: 1ENTRYPOINT [&quot;memcached&quot;, &quot;-u&quot;, &quot;daemon&quot;] 更好的方式是： 12ENTRYPOINT [&quot;memcached&quot;]USER daemon #MAINTAINER 命令 1MAINTAINER &lt;name&gt; MAINTAINER命令用来指定维护者的姓名和联系方式 EXPOSE 命令EXPOSE 命令可以设置一个端口在运行的镜像中暴露在外 1EXPOSE &lt;port&gt; [&lt;port&gt;...] 比如Nginx使用端口 80，可以把这个端口暴露在外，这样容器外可以看到这个端口并与其通信。 1EXPOSE 80 详细内容可以看这篇文章 -&gt; Docker网络原则入门：EXPOSE，-p，-P，-link WORKDIR 命令1WORKDIR /opt/bin 配置RUN, CMD, ENTRYPOINT 命令设置当前工作路径 可以设置多次，如果是相对路径，则相对前一个 WORKDIR 命令 比如: 12WORKDIR /opt/binRUN pwd 其实是在 /opt/bin 下执行 pwd ENV 命令用于设置环境变量 1ENV &lt;key&gt; &lt;value&gt; 设置了后，后续的RUN命令都可以使用 使用此dockerfile生成的image新建container，可以通过 docker inspect 看到这个环境变量: 123456789101112root@tankywoo-docker:~# docker inspect 49bfc7a9817f ... &quot;Env&quot;: [ &quot;name=tanky&quot;, &quot;HOME=/&quot;, &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], ...``` 里面的name=tanky就是设置的。也可以通过在docker run时设置或修改环境变量: docker run -i -t –env name=”tanky” ubuntu:newtest /bin/bash```","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://elickzhao.github.io/tags/docker/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}]},{"title":"linux sed 批量替换字符串","slug":"linux sed 批量替换字符串","date":"2016-04-27T14:25:04.000Z","updated":"2021-09-09T16:34:45.288Z","comments":true,"path":"2016/04/linux sed 批量替换字符串/","link":"","permalink":"http://elickzhao.github.io/2016/04/linux%20sed%20%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"Linux下批量替换多个文件中的字符串的简单方法。用sed命令可以批量替换多个文件中的字符串。命令如下：sed -i “s/原字符串/新字符串/g” grep 原字符串 -rl 所在目录例如：我要把 charset=gb2312 替换为 charset=UTF-8，执行命令：sed -i “s/charset=gb2312/charset=UTF-8/g” ‘grep charset=gb2312 -rl /www’ 即可。 解释一下： -i 表示inplace edit，就地修改文件 -r 表示搜索子目录 -l 表示输出匹配的文件名 这个命令组合很强大，要注意备份文件。","text":"Linux下批量替换多个文件中的字符串的简单方法。用sed命令可以批量替换多个文件中的字符串。命令如下：sed -i “s/原字符串/新字符串/g” grep 原字符串 -rl 所在目录例如：我要把 charset=gb2312 替换为 charset=UTF-8，执行命令：sed -i “s/charset=gb2312/charset=UTF-8/g” ‘grep charset=gb2312 -rl /www’ 即可。 解释一下： -i 表示inplace edit，就地修改文件 -r 表示搜索子目录 -l 表示输出匹配的文件名 这个命令组合很强大，要注意备份文件。 #关于 sed 的更多说明：sed ‘y/1234567890/ABCDEFGHIJ/’ test_sed test_sed的内容是： 1234123456789023456789013456789012 4567890123 执行后，test_sed的内容是： 1234ABCDEFGHIJBCDEFGHIJACDEFGHIJABDEFGHIJABC 注意变换关系是按两个list的位置对应变换 替换每行所有匹配 sed ‘s/01/Ab/g’ test_sed 1234123456789023456789Ab3456789Ab2456789Ab23 注意：第一行的0，1没有分别替换为A,b删除：d命令 1234$ sed ‘2d’ example—–删除example文件的第二行。$ sed ‘2,$d’ example—–删除example文件的第二行到末尾所有行。$ sed ‘$d’ example—–删除example文件的最后一行。$ sed ‘/test/’d example—–删除example文件所有包含test的行。 替换：s命令 123456789$ sed ‘s/test/mytest/g’ example—–在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。$ sed -n ‘s/^test/mytest/p’ example—–(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。$ sed ‘s/^192.168.0.1/&amp;localhost/’example—–&amp;符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加localhost，变成192.168.0.1localhost。$ sed -n ‘s/\\(love\\)able/\\1rs/p’ example—–love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。$ sed ‘s#10#100#g’ example—–不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。选定行的范围：逗号$ sed -n ‘/test/,/check/p’ example—–所有在模板test和check所确定的范围内的行都被打印。$ sed -n ‘5,/^test/p’ example—–打印从第五行开始到第一个包含以test开始的行之间的所有行。$ sed ‘/test/,/check/s/$/sed test/’ example—–对于模板test和west之间的行，每行的末尾用字符串sed test替换。 多点编辑：e命令 12$ sed -e ‘1,5d’ -e ‘s/test/check/’example—–(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。$ sed –expression=’s/test/check/’ –expression=’/love/d’ example—–一个比-e更好的命令是–expression。它能给sed表达式赋值。 从文件读入：r命令 123$ sed ‘/test/r file’ example—–file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。写入文件：w命令$ sed -n ‘/test/w file’ example—–在example中所有包含test的行都被写入file里。 追加命令：a命令 1$ sed ‘/^test/a\\\\—&gt;this is a example’ example&lt;—–‘this is a example’被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。 插入：i命令 1234$ sed ‘/test/i\\\\new line————————-‘ example如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。 下一个：n命令 1$ sed ‘/test/&#123; n; s/aa/bb/; &#125;’ example—–如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。 变形：y命令 1$ sed ‘1,10y/abcde/ABCDE/’ example—–把1–10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。 退出：q命令 1$ sed ’10q’ example—–打印完第10行后，退出sed。 保持和获取：h命令和G命令 123$ sed -e ‘/test/h’ -e ‘$Gexample—–在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。保持和互换：h命令和x命令$ sed -e ‘/test/h’ -e ‘/check/x’ example —–互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。 原文地址: http://www.frostsky.com/2014/01/linux-sed-command/","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"}]},{"title":"ubuntu 国内源列表","slug":"ubuntu 国内源列表","date":"2016-04-26T15:40:34.000Z","updated":"2021-09-09T16:34:45.418Z","comments":true,"path":"2016/04/ubuntu 国内源列表/","link":"","permalink":"http://elickzhao.github.io/2016/04/ubuntu%20%E5%9B%BD%E5%86%85%E6%BA%90%E5%88%97%E8%A1%A8/","excerpt":"","text":"详细地址都在下面连接 ubuntu国内官网源列表","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"}]},{"title":"用docker搭建laravel环境 (Docker for the Laravel framework)","slug":"用docker搭建laravel环境 (Docker for the Laravel framework)","date":"2016-04-25T15:54:28.000Z","updated":"2021-09-09T16:34:45.696Z","comments":true,"path":"2016/04/用docker搭建laravel环境 (Docker for the Laravel framework)/","link":"","permalink":"http://elickzhao.github.io/2016/04/%E7%94%A8docker%E6%90%AD%E5%BB%BAlaravel%E7%8E%AF%E5%A2%83%20(Docker%20for%20the%20Laravel%20framework)/","excerpt":"前言 最近一直想搭建个自己的docker开发环境,找了不少资料.在docker-hub上发现这个,虽然内容老一点,不过思路还是很好的.而且发现用docker搭建原来是如此的so easy! 好吧,让我们开始吧. 首先来看看布局结构 简单说明下.每一个服务用了一个容器.所有容器的数据都指向数据容器.这样统一管理的同时,也方便修改和报错.这里原作者把artisan和composer也放在一个容器里,但是我个人感觉这样不是太好.当然为了保持宿主主机的纯净度来讲,这是个正确的选择,就是操作起来太费事了.","text":"前言 最近一直想搭建个自己的docker开发环境,找了不少资料.在docker-hub上发现这个,虽然内容老一点,不过思路还是很好的.而且发现用docker搭建原来是如此的so easy! 好吧,让我们开始吧. 首先来看看布局结构 简单说明下.每一个服务用了一个容器.所有容器的数据都指向数据容器.这样统一管理的同时,也方便修改和报错.这里原作者把artisan和composer也放在一个容器里,但是我个人感觉这样不是太好.当然为了保持宿主主机的纯净度来讲,这是个正确的选择,就是操作起来太费事了. 下载所有镜像12345$ docker pull dylanlindgren/docker-laravel-data &amp;&amp; \\ docker pull dylanlindgren/docker-laravel-composer &amp;&amp; \\ docker pull dylanlindgren/docker-laravel-artisan &amp;&amp; \\ docker pull dylanlindgren/docker-laravel-phpfpm &amp;&amp; \\ docker pull dylanlindgren/docker-laravel-nginx Nginx这个镜像的Github地址,其他的我就不放了,因为这个仓库的首页上都有.所以如果你想去详细了解文件内容可以去看看. 下载虚拟机并建立共享目录 要说明一点我用的是windows,所以下面的操作讲的都是windows下的操作经过.OS X 大致类似,linux是最简单的完全不需要虚拟机的,只要建立共享目录就可以了. 下载docker toolbox并安装 (原文是boot2docker 但是貌似不更新了 而且用不了docker composer 所以用新的吧) 建立共享目录并与虚拟机设置共享 1234567#首先进入 virtualbox的目录 使用命令创建共享目录VBoxManage sharedfolder add boot2docker-vm --name myapp --hostpath C:\\Users\\dylan\\myapp#创建转发端口VBoxManage modifyvm boot2docker-vm --natpf1 &quot;web,tcp,,80,,80&quot;#当然你还可以直接在virtualbox设置里直接设置这些不用命令 12345#进入linux挂载刚才的共享目录$ boot2docker ssh &#x27;sudo mkdir /data&#x27;$ boot2docker ssh &#x27;sudo mount -t vboxsf -o &quot;defaults,uid=33,gid=33,rw&quot; myapp /data&#x27;#共享目录我个人感觉没用,因为每次都得进入linux挂载一次可用,而且只用启动容器时 使用 -v 直接挂载目录就可以了 也不需要这个.当然你可以按着步骤一步一步做 这样肯定能成功! 万事俱备 启动容器1234567891011#启动数据容器 原本好像有点问题 必须这么写要不启动不起来 至于原因嘛 可能跟 bash有关 比较懒没仔细查`docker run --name myapp-data -v /Users/dylan/myapp:/data:rw -id dylanlindgren/docker-laravel-data /bin/bash ` #启动php容器 --privileged=true 这个必须要不无法创建目录docker run --privileged=true --name myapp-php --volumes-from myapp-data -d dylanlindgren/docker-laravel-phpfpm #启动Nginxdocker run --privileged=true --name myapp-web --volumes-from myapp-data -p 80:80 --link myapp-php:fpm -d dylanlindgren/docker-laravel-nginx #剩下两个 不想写了 因为感觉没用 如果你想用可以看下面 有原文链接 到那里看一下就会了 跟上面大同小异 检查浏览器成功与否进入http://localhost查看是否有你想要的内容.这里提个醒因为是laravel环境,所以做了地址改写,把根目录指向了public下,我第一次也是找半天,后来看Github源代码才搞懂. 所以你只要把代码放到你的共享目录,也就是上面C:\\Users\\dylan\\myapp\\www\\public下就ok了. 打完收工到此为止你有了个全新的laravel环境了.不过这还不是我想要的,毕竟版本都很低了,而且有些设置不太合我的心意,所以会自己弄一个环境出来的. 想看原文的点这里……","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://elickzhao.github.io/tags/docker/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"}]},{"title":"linux mount命令的用法详细解析","slug":"linux mount命令的用法详细解析","date":"2016-04-21T15:52:53.000Z","updated":"2021-09-09T16:34:45.285Z","comments":true,"path":"2016/04/linux mount命令的用法详细解析/","link":"","permalink":"http://elickzhao.github.io/2016/04/linux%20mount%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/","excerpt":"挂接命令(mount)首先，介绍一下挂接(mount)命令的使用方法，mount命令参数非常多，这里主要讲一下今天我们要用到的。命令格式：mount [-t vfstype] [-o options] device dir其中： -t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：光盘或光盘镜像：iso9660DOS fat16文件系统：msdosWindows 9x fat32文件系统：vfatWindows NT ntfs文件系统：ntfsMount Windows文件网络共享：smbfsUNIX(LINUX) 文件网络共享：nfsVirtualBox 文件网络共享: vboxsf -o options 主要用来描述设备或档案的挂接方式。常用的参数有：loop：用来把一个文件当成硬盘分区挂接上系统ro：采用只读方式挂接设备rw：采用读写方式挂接设备iocharset：指定访问文件系统所用字符集 device 要挂接(mount)的设备。 dir设备在系统上的挂接点(mount point)。","text":"挂接命令(mount)首先，介绍一下挂接(mount)命令的使用方法，mount命令参数非常多，这里主要讲一下今天我们要用到的。命令格式：mount [-t vfstype] [-o options] device dir其中： -t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：光盘或光盘镜像：iso9660DOS fat16文件系统：msdosWindows 9x fat32文件系统：vfatWindows NT ntfs文件系统：ntfsMount Windows文件网络共享：smbfsUNIX(LINUX) 文件网络共享：nfsVirtualBox 文件网络共享: vboxsf -o options 主要用来描述设备或档案的挂接方式。常用的参数有：loop：用来把一个文件当成硬盘分区挂接上系统ro：采用只读方式挂接设备rw：采用读写方式挂接设备iocharset：指定访问文件系统所用字符集 device 要挂接(mount)的设备。 dir设备在系统上的挂接点(mount point)。 挂接光盘镜像文件 从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。 123$ cp /dev/cdrom /home/sunky/mydisk.iso 或$ dd if=/dev/cdrom of=/home/sunky/mydisk.iso# 注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/sunky/mydisk.iso 将文件和目录制作成光盘镜像文件，执行下面的命令。 12$ mkisofs -r -J -V mydisk -o /home/sunky/mydisk.iso /home/sunky/ mydir# 注：这条命令将/home/sunky/mydir目录下所有的目录和文件制作成光盘镜像文件/home/sunky/mydisk.iso，光盘卷标为：mydisk 光盘镜像文件的挂接(mount) 12345$ mkdir /mnt/vcdrom# 注：建立一个目录用来作挂接点(mount point)$ mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom# 注：使用/mnt/vcdrom就可以访问盘镜像文件mydisk.iso里的所有文件了。 挂接移动硬盘对linux系统而言，USB接口的移动硬盘是当作SCSI设备对待的。插入移动硬盘之前，应先用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。 1[root at pldyrouter /]# fdisk -l 接好移动硬盘后，再用fdisk –l 或 more/proc/partitions查看系统的硬盘和硬盘分区情况.应该可以发现多了一个SCSI硬盘/dev/sdc和它的两个磁盘分区/dev/sdc1?、/dev/sdc2,其中/dev/sdc5是/dev/sdc2分区的逻辑分区。我们可以使用下面的命令挂接/dev/sdc1和/dev/sdc5。 12345678910111213$mkdir -p /mnt/usbhd1$mkdir -p /mnt/usbhd2# 注：建立目录用来作挂接点(mount point)$ mount -t ntfs /dev/sdc1 /mnt/usbhd1$ mount -t vfat /dev/sdc5 /mnt/usbhd2# 注：对ntfs格式的磁盘分区应使用-t ntfs 参数，对fat32格式的磁盘分区应使用-t vfat参数。若汉字文件名显示为乱码或不显示，可以使用下面的命令格式。$ mount -t ntfs -o iocharset=cp936 /dev/sdc1 /mnt/usbhd1$ mount -t vfat -o iocharset=cp936 /dev/sdc5 /mnt/usbhd2# linux系统下使用fdisk分区命令和mkfs文件系统创建命令可以将移动硬盘的分区制作成linux系统所特有的ext2、ext3格式。这样，在linux下使用就更方便了。使用下面的命令直接挂接即可。$ mount /dev/sdc1 /mnt/usbhd1 挂接U盘和USB接口的移动硬盘一样对linux系统而言U盘也是当作SCSI设备对待的。使用方法和移动硬盘完全一样。插入U盘之前，应先用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。 1[root at pldyrouter root]# fdisk -l 插入U盘后，再用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。 1[root at pldyrouter root]# fdisk -l 系统多了一个SCSI硬盘/dev/sdd和一个磁盘分区/dev/sdd1,/dev/sdd1就是我们要挂接的U盘。 12345$ mkdir -p /mnt/usb# 注：建立一个目录用来作挂接点(mount point)$ mount -t vfat /dev/sdd1 /mnt/usb# 注：现在可以通过/mnt/usb来访问U盘了, 若汉字文件名显示为乱码或不显示，可以使用下面的命令。$ mount -t vfat -o iocharset=cp936 /dev/sdd1 /mnt/usb 挂接Windows文件共享Windows网络共享的核心是SMB/CIFS，在linux下要挂接(mount)windows的磁盘共享，就必须安装和使用samba 软件包。现在流行的linux发行版绝大多数已经包含了samba软件包，如果安装linux系统时未安装samba请首先安装samba。当然也可以到 www.samba.org网站下载......新的版本是3.0.10版。当windows系统共享设置好以后，就可以在linux客户端挂接(mount)了，具体操作如下： 1234$ mkdir –p /mnt/samba# 注：建立一个目录用来作挂接点(mount point)$ mount -t smbfs -o username=administrator,password=pldy123 //10.140.133.23/c$ /mnt/samba# 注：administrator 和 pldy123 是ip地址为10.140.133.23 windows计算机的一个用户名和密码，c$是这台计算机的一个磁盘共享如此就可以在linux系统上通过/mnt/samba来访问windows系统磁盘上的文件了。以上操作在redhat as server 3、redflag server 4.1、suse server 9以及windows NT 4.0、windows 2000、windows xp、windows 2003环境下测试通过。 挂接UNIX系统NFS文件共享类似于windows的网络共享，UNIX(Linux)系统也有自己的网络共享，那就是NFS(网络文件系统)，下面我们就以SUN Solaris2.8和REDHAT as server 3 为例简单介绍一下在linux下如何mount nfs网络共享。在linux客户端挂接(mount)NFS磁盘共享之前，必须先配置好NFS服务端。 Solaris系统NFS服务端配置方法如下： 修改 /etc/dfs/dfstab, 增加共享目录1share -F nfs -o rw /export/home/sunky 启动nfs服务1$ /etc/init.d/nfs.server start NFS服务启动以后，也可以使用下面的命令增加新的共享123$ share /export/home/sunky1$ share /export/home/sunky2# 注：/export/home/sunky和/export/home/sunky1是准备共享的目录 linux系统NFS服务端配置方法如下： 修改 /etc/exports,增加共享目录12345/export/home/sunky 10.140.133.23(rw)/export/home/sunky1 *(rw)/export/home/sunky2 linux-client(rw)# 注：/export/home/目录下的sunky、sunky1、sunky2是准备共享的目录，10.140.133.23、*、 linux-client是被允许挂接此共享linux客户机的IP地址或主机名。如果要使用主机名linux-client必须在服务端主机 /etc/hosts文件里增加linux-client主机ip定义。格式如下：10.140.133.23 linux-client 启动与停止NFS服务1234/etc/rc.d/init.d/portmap start (在REDHAT中PORTMAP是默认启动的)/etc/rc.d/init.d/nfs start 启动NFS服务/etc/rc.d/init.d/nfs stop 停止NFS服务# 注：若修改/etc/export文件增加新的共享，应先停止NFS服务，再启动NFS服务方能使新增加的共享起作用。使用命令exportfs -rv也可以达到同样的效果。 linux客户端挂接(mount)其他linux系统或UNIX系统的NFS共享12345$ mkdir –p /mnt/nfs# 注：建立一个目录用来作挂接点(mount point)$ mount -t nfs -o rw 10.140.133.9:/export/home/sunky /mnt/nfs# 注：这里我们假设10.140.133.9是NFS服务端的主机IP地址，当然这里也可以使用主机名，但必须在本机/etc/hosts文件里增加服务端ip定义。/export/home/sunky为服务端共享的目录。如此就可以在linux客户端通过/mnt/nfs来访问其它linux系统或UNIX系统以NFS方式共享出来的文件了。以上操作在 redhat as server redflag server4.1、suse server 9以及Solaris 7、Solaris 8、Solaris 9 for x86&amp;sparc环境下测试通过 补充：linux加载光驱（1）使用光驱前，要先mount一下：＃mount /dev/cdrom /mnt/cdrom，然后您就可以进入/mnt/cdrom目录下读取光盘内容了； （2）当您想退出光盘时，须使用umout命令，否则光驱就会一直处于死锁状态：＃umount /mnt/cdrom。","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"}]},{"title":"Dockerfile VOLUME 和 -v 的区别","slug":"Dockerfile VOLUME 和 -v 的区别","date":"2016-04-21T13:27:05.000Z","updated":"2021-09-09T16:34:44.886Z","comments":true,"path":"2016/04/Dockerfile VOLUME 和 -v 的区别/","link":"","permalink":"http://elickzhao.github.io/2016/04/Dockerfile%20VOLUME%20%E5%92%8C%20-v%20%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"elick 发布 新文稿 Dockerfile VOLUME 和 -v 的区别 docker 服务器相关技术 找到了官方的userguide： https://docs.docker.com/engine/userguide… 从中了解了一点：VOLUME并非只是声明，它会把指定路径重新加载一遍，我通过inspect容器也发现了这一点。 这是在Dockerfile指定了VOLUME，并没有指定-v，查看容器的Mounts信息： 12345678910&quot;Mounts&quot;: [ &#123; &quot;Name&quot;: &quot;b3e2dcacd3f9f40b43ccd5773d45ca74f0f49b02d3da17749cb378ff9f59bb67&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/b3e2dcacd3f9f40b43ccd5773d45ca74f0f49b02d3da17749cb378ff9f59bb67/_data&quot;, &quot;Destination&quot;: &quot;/etc&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true &#125; ], 这是在上一个的基础上，指定了-v，查看容器的Mounts信息： 12345678&quot;Mounts&quot;: [ &#123; &quot;Source&quot;: &quot;/etc&quot;, &quot;Destination&quot;: &quot;/etc&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true &#125; ], 然后你去/var/lib/docker/volumes/b3e2dcacd3f9f40b43ccd5773d45ca74f0f49b02d3da17749cb378ff9f59bb67/_data目录下看一下，大致就清楚了。当Dockerfile里设置的VOLUME目录存在文件,那么在这个目录里就会出现 如用用了-v再指向这个VOLUME目录,又会被host目录覆盖掉 你可以把VOLUME理解为，从镜像中复制指定卷的文件夹到本地/var/lib/docker/volumes/xxxxxxxxx/文件夹，然后把本地的该文件夹挂载到容器里面去。 本质上还是相当于一个本地文件夹挂载而已。 继续补充，因为VOLUME实际上就是在本地新建了一个文件夹挂载了，那么实际上容器内部的文件夹有三种情况：1、没有指定VOLUME也没有指定-v，这种是普通文件夹。2、指定了VOLUME没有指定-v，这种文件夹可以在不同容器之间共享，但是无法在本地修改。3、指定了-v的文件夹，这种文件夹可以在不同容器之间共享，且可以在本地修改。 那就列举一种需要在不同容器之间共享且不需要在本地修改的情况。 首先，我们先了解容器中获取动态数据的方式：1、本地提供，挂载到容器2、远程提供，从远程下载3、生成提供，在容器内部生成 后面两种命令都不需要在本地修改，但是他们生成的动态数据却可能需要共享。下载命令，比如git clone直接从git服务器拉取代码，不需要挂载本地文件夹。生成命令，比如jekyll（静态网站生成器），你可能挂载一个代码文件夹，然后build目录里生成的静态网页文件需要提供给Apache服务器，那么你需要指定build目录为VOLUME。","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://elickzhao.github.io/tags/docker/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}]},{"title":"常用的vagrant命令","slug":"常用的vagrant命令","date":"2016-04-20T14:28:00.000Z","updated":"2021-09-09T16:34:45.637Z","comments":true,"path":"2016/04/常用的vagrant命令/","link":"","permalink":"http://elickzhao.github.io/2016/04/%E5%B8%B8%E7%94%A8%E7%9A%84vagrant%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用的vagrant命令: 12345678910111213$ vagrant box add NAME URL #添加一个box$ vagrant box list #查看本地已添加的box$ vagrant box remove NAME virtualbox #删除本地已添加的box，如若是版本1.0.x，执行$ vagrant box remove NAME$ vagrant init NAME #初始化，实质应是创建Vagrantfile文件$ vagrant up #启动虚拟机$ vagrant halt #关闭虚拟机$ vagrant destroy #销毁虚拟机$ vagrant reload #重启虚拟机$ vagrant package #当前正在运行的VirtualBox虚拟环境打包成一个可重复使用的box$ vagrant ssh #进入虚拟环境$ vagrant init laravel/homestead #初始化并下载box$ vagrant box add base precise64.box #base 表示指定默认的box，也可以为box指定名称，使用base时，之后可以直接使用 vagrant init 进行初始化，如果自行指定名称，则初始化的时候需要指定box的名称。","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"vagrant","slug":"vagrant","permalink":"http://elickzhao.github.io/tags/vagrant/"}]},{"title":"应用TortoiseGit为github账号添加SSH keys","slug":"应用TortoiseGit为github账号添加SSH keys","date":"2016-04-19T10:35:30.000Z","updated":"2021-09-09T16:34:45.639Z","comments":true,"path":"2016/04/应用TortoiseGit为github账号添加SSH keys/","link":"","permalink":"http://elickzhao.github.io/2016/04/%E5%BA%94%E7%94%A8TortoiseGit%E4%B8%BAgithub%E8%B4%A6%E5%8F%B7%E6%B7%BB%E5%8A%A0SSH%20keys/","excerpt":"","text":"呵呵 我算是比较懒的 不过避免重复造轮子这种降低效率的事 还是直接引入别人写得详细的文章吧 这个方法可以解决TortoiseGit的问题,但是无法解决hexo上传的问题.因为hexo用到的密钥其实是ssh的,并不是TortoiseGit里面的.所以解决了TortoiseGit也不代表hexo就可用了. 看来我得回家看看了,怎么用一个密码实现了hexo和TortoiseGit两个同时上传目前来看必须使用两个才行,TortoiseGit使用的是putty,但是hexo必须用ssh才可以啊. 所以家里那个电脑怎么做到的.上面这个问题我想起来了,putty那个生成密码的工具,还可以转换密码,把ssh转换成putty密码.这样就可以使用一个公钥了.这样hexo和TortoiseGit 简单说下步骤吧,ssh生成密钥,用putty转换密钥-&gt;保存私钥,用putty自动加载转换工具再次转换以供TortoiseGit提交github用. 看最下面 文章地址","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://elickzhao.github.io/tags/Git/"},{"name":"ssh","slug":"ssh","permalink":"http://elickzhao.github.io/tags/ssh/"}]},{"title":"composer 一些使用记录","slug":"composer 一些使用记录","date":"2016-04-18T17:01:32.000Z","updated":"2021-09-09T16:34:45.118Z","comments":true,"path":"2016/04/composer 一些使用记录/","link":"","permalink":"http://elickzhao.github.io/2016/04/composer%20%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1234567891011121314151617181920212223composer selfupdate composer require &quot;foo/bar:1.0.0&quot; 安装一个库composer update foo/bar 更新单个库composer create-project laravel/laravel myapp --prefer-dist 创建laravel项目composer config -g repo.packagist composer https://packagist.phpcomposer.com 配置仓库镜像composer global require &quot;laravel/installer=~1.1&quot; 全局安装laravel安装器composer install update --prefer-dist 后面这个参数是强制使用压缩包composer install --profile 后面这个参数是显示安装时间composer dump-autoload --optimize 生产环境优化composer update symfony/yaml --prefer-source 强制克隆代码 用于修改库文件当你更新一个修改的库的时候 会提示你是否放弃修改----------------------------------------------------------------------------------------------------$ composer updateLoading composer repositories with package information Updating dependencies - Updating symfony/symfony v2.2.0 (v2.2.0- =&gt; v2.2.0) The package has modified files: M Dumper.php Discard changes [y,n,v,s,?]?---------------------------------------------------------------------------------------------------- 全局配置目录C:\\Users\\elick\\AppData\\Roaming\\Composer","categories":[],"tags":[{"name":"composer","slug":"composer","permalink":"http://elickzhao.github.io/tags/composer/"}]},{"title":"Docker常用命令","slug":"Docker常用命令","date":"2016-04-18T16:42:00.000Z","updated":"2021-09-09T16:34:44.888Z","comments":true,"path":"2016/04/Docker常用命令/","link":"","permalink":"http://elickzhao.github.io/2016/04/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看docker信息（version、info）12345# 查看docker版本 $docker version # 显示docker系统的信息 $docker info 对image的操作（search、pull、images、rmi、history）123456789101112131415161718192021222324252627282930313233343536373839404142# 检索image $docker search image_name # 下载image $docker pull image_name # 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don&#x27;t truncate output; -q, --quiet=false Only show numeric IDs $docker images # 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents $docker rmi image_name #删除所有镜像docker rmi $(docker images -q)docker rmi $(docker images | grep none | awk &#x27;&#123;print $3&#125;&#x27; | sort -r)#删除所有未打 tag 的镜像docker rmi $(docker images -q | awk &#x27;/^&lt;none&gt;/ &#123; print $3 &#125;&#x27;)#根据格式删除所有镜像docker rm $(docker ps -qf status=exited) # 显示一个镜像的历史; --no-trunc=false Don&#x27;t truncate output; -q, --quiet=false Only show numeric IDs $docker history image_name #导出容器到本地镜像库：$docker export container_id &gt; centos.tar#导入容器快照为镜像(docker import)：#(1)容器在本地：cat centos.tar | docker import - registry.intra.weibo.com/yushuang3/centos:v2.0#(2)容器在网络上：docker import http://example.com/exampleimage.tgz registry.intra.weibo.com/yushuang3/centos:v2.0Note：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。 启动容器（run）docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。 1234567891011121314151617181920212223242526272829303132333435# 在容器中运行&quot;echo&quot;命令，输出&quot;hello word&quot; $docker run image_name echo &quot;hello word&quot; #命名容器$docker run --name test image_nameNote: 这个很有用 这样删除容器等一些操作直接用名称就可以 不用去看ID了 # 交互式进入容器中 $docker run -i -t image_name /bin/bash Note: 如果镜像有tag，需要在image后加:tag名 （-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开）#后台执行容器$docker run -d image_name #转发端口$docker run -p 8080:8080 image_name Note: 主机端口(host port) : 容器端口(container post)#挂载指定的主机目录$ docker run -v /c/Users/elick/www:/var/wwwNote: 主机目录 : 容器目录 挂载指定主机目录 这个是Dockerfile VOLUME没法办到的 因为考虑的Dockerfile的迁移问题 主机目录是不确定的,所这个指定目录只能用命令行来执行 而Dockerfile VOLUME 只是挂载了容器内一个目录 还有个问题是 这个挂载是吧主机目录完全复制到容器目录 但不是双向的 会把容器目录内容删除 **两个地址都必须是绝对地址 还有容器内的目录可以没有 会自动添加的** # 在容器中安装新的程序 $docker run image_name apt-get install -y app_name Note： 在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。# container内的root拥有真正的root权限。docker run --privileged=false Note: 使用该参数，container内的root拥有真正的root权限。否则，container内的root只是外部的一个普通用户权限。否则，container内的root只是外部的一个普通用户权限。privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。甚至允许你在docker容器中启动docker容器。 查看容器（ps）123456# 列出当前所有正在运行的container $docker ps # 列出所有的container $docker ps -a # 列出最近一次启动的container $docker ps -l 保存对容器的修改（commit）当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。 12345# 保存对容器的修改; -a, --author=&quot;&quot; Author; -m, --message=&quot;&quot; Commit message $docker commit -a &#x27;author&#x27; ID new_image_name Note： image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。 对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach、exec、rename、logs、link）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 删除所有容器 $docker rm `docker ps -a -q` # 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container $docker rm Name/ID # 停止、启动、杀死一个容器 $docker stop Name/ID $docker start Name/ID $docker kill Name/ID # 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps $docker logs Name/ID # 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的 $docker diff Name/ID # 显示一个运行的容器里面的进程信息 $docker top Name/ID # 从容器里面拷贝文件/目录到本地一个路径 $docker cp Name:/container_path to_path $docker cp ID:/container_path to_path # 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10 $docker restart Name/ID # 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process $docker attach ID Note： attach命令允许你查看或者影响一个运行的容器。你可以在同一时间attach同一个容器。你也可以从一个容器中脱离出来，是从CTRL-C。但是脱离出来后 容器也就停止了#进入容器$docker exec -it container_name /bin/bashNote: exec 使用-it时，和我们平常操作console界面类似。而且也不会像attach方式因为退出，导致 整个容器退出。（-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开） 和run -it 一样后面必须接上要执行的命令 比如 /bin/bash 否则会报错#修改容器名$docker rename old容器名 new容器名#要获取容器的输出信息:$docker logs -f &lt;容器名orID&gt;#查看容器的root用户密码$docker logs &lt;容器名orID&gt; 2&gt;&amp;1 | grep &#x27;^User: &#x27; | tail -n1#一个容器连接到另一个容器$docker run -i -t --name sonar -d -link mmysql:db tpires/sonar-serverNote: sonar容器连接到mmysql容器，并将mmysql容器重命名为db。这样，sonar容器就可以使用db的相关的环境变量了。如下查看环境变量就可以看到mmysql相关环境变量root@665f1bdc5913:/# envHOSTNAME=665f1bdc5913DB_NAME=/compassionate_pasteur/dbTERM=xtermDB_PORT=tcp://172.17.0.2:11211DB_PORT_3306_TCP_PROTO=tcpDB_PORT_3306_TCP_ADDR=172.17.0.2PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPWD=/SHLVL=1HOME=/DB_PORT_3306_TCP_PORT=3306DB_PORT_3306_TCP=tcp://172.17.0.2:3306container=lxc_=/usr/bin/env 保存和加载镜像（save、load）当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。 123456789# 保存镜像到一个tar包; -o, --output=&quot;&quot; Write to an file $docker save image_name -o file_path # 加载一个tar包格式的镜像; -i, --input=&quot;&quot; Read from a tar archive file $docker load -i file_path # 机器a $docker save image_name &gt; /home/save.tar # 使用scp将save.tar拷到机器b上，然后： $docker load &lt; /home/save.tar 登录registry server（login）12# 登陆registry server; -e, --email=&quot;&quot; Email; -p, --password=&quot;&quot; Password; -u, --username=&quot;&quot; Username $docker login 发布image（push）12# 发布docker镜像 $docker push new_image_name 根据Dockerfile 构建出一个容器123456#build --no-cache=false Do not use cache when building the image -q, --quiet=false Suppress the verbose output generated by the containers --rm=true Remove intermediate containers after a successful build -t, --tag=&quot;&quot; Repository name (and optionally a tag) to be applied to the resulting image in case of success $docker build -t image_name Dockerfile_path Docker 2 – 关于DockerfileDocker 4 – 总结深入理解 Docker Volume（一）docker 容器相关命令","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://elickzhao.github.io/tags/docker/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}]},{"title":"docker及boot2docker相关研究","slug":"docker及boot2docker相关研究","date":"2016-04-18T15:51:49.000Z","updated":"2021-09-09T16:34:45.150Z","comments":true,"path":"2016/04/docker及boot2docker相关研究/","link":"","permalink":"http://elickzhao.github.io/2016/04/docker%E5%8F%8Aboot2docker%E7%9B%B8%E5%85%B3%E7%A0%94%E7%A9%B6/","excerpt":"boot2docker转发端口问题 这是个很恶心的问题 因为boot2docker还是依赖与virtualbox 所以虽然使用命令 docker run -dp 8080:8080 php进行转发 但是还需要修改虚拟机的端口转发才可以 命令解析: docker -d 后台执行 -p 转发端口","text":"boot2docker转发端口问题 这是个很恶心的问题 因为boot2docker还是依赖与virtualbox 所以虽然使用命令 docker run -dp 8080:8080 php进行转发 但是还需要修改虚拟机的端口转发才可以 命令解析: docker -d 后台执行 -p 转发端口 boot2docker数据卷问题 这个就更恶心了,使用在windows下的boot2docker命令行就会报错,只有进入virtualbox 使用命令 docker run -dp 8080:8080 --name test1 -v /c/Users/elick/www:/var/www elick/php才可以 真是醉了 需要注意的一点: boot2docker建立的虚拟机有个自启动共享目录 c/Users C:\\Users 在虚拟机里的根目录下能看到这个目录 所以windows上的目录的根目录是/c/开始的 boot2docker使用总结 从上面两点来看,虽然省略了配置vagrantfile的麻烦,但是还得去弄虚拟机从这点看,貌似还不如使用vagrant来的简单些 相关资料Docker在PHP项目开发环境中的应用{译} 深入理解 Docker Volume（一）Dockers 快速学习（四）Docker 容器的使用Docker安装_Ubuntu 15.10 &amp; 14.04 LTS上安装和管理DockerDocker exec与Docker attachDocker之常用命令Docker学习笔记(2)–Docker常用命令利用Docker构建开发环境利用docker快速部署应用Docker volume使用Docker学习—挂载本地目录","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://elickzhao.github.io/tags/docker/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"}]},{"title":"解决ln -s 软链接产生Too many levels of symbolic links错误","slug":"解决ln -s 软链接产生Too many levels of symbolic links错误","date":"2016-04-18T03:50:14.000Z","updated":"2021-09-09T16:34:45.735Z","comments":true,"path":"2016/04/解决ln -s 软链接产生Too many levels of symbolic links错误/","link":"","permalink":"http://elickzhao.github.io/2016/04/%E8%A7%A3%E5%86%B3ln%20-s%20%E8%BD%AF%E9%93%BE%E6%8E%A5%E4%BA%A7%E7%94%9FToo%20many%20levels%20of%20symbolic%20links%E9%94%99%E8%AF%AF/","excerpt":"","text":"今天生成软连接发生这个报错,查了一下,原来是因为使用了相对路径,改成绝对路径就没有问题了 1$ln -s /cygdrive/f/Vagrant /home/elick/vagrant 命令解析:ln [参数][源文件或目录][目标文件或目录]","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"}]},{"title":"在VirtualBox和Vagrant中安装Docker","slug":"在VirtualBox和Vagrant中安装Docker","date":"2016-04-13T17:18:48.000Z","updated":"2021-09-09T16:34:45.593Z","comments":true,"path":"2016/04/在VirtualBox和Vagrant中安装Docker/","link":"","permalink":"http://elickzhao.github.io/2016/04/%E5%9C%A8VirtualBox%E5%92%8CVagrant%E4%B8%AD%E5%AE%89%E8%A3%85Docker/","excerpt":"参考文章在VirtualBox和Vagrant中安装DockerOSX下使用vagrant和docker管理创建虚拟环境Vagrant简介和安装配置使用 Vagrant 搭建本地开发环境的教程使用 Vagrant 和 Docker 在一个 VM 中进行开发1+1&gt;2:用Docker和Vagrant构建简洁高效开发环境Vagrant运行Docker的几种方法vagrant在windows下的使用服务器操作系统CoreOS初体验‘当流浪者(Vagrant)遇见码头工人(Docker)’系列","text":"参考文章在VirtualBox和Vagrant中安装DockerOSX下使用vagrant和docker管理创建虚拟环境Vagrant简介和安装配置使用 Vagrant 搭建本地开发环境的教程使用 Vagrant 和 Docker 在一个 VM 中进行开发1+1&gt;2:用Docker和Vagrant构建简洁高效开发环境Vagrant运行Docker的几种方法vagrant在windows下的使用服务器操作系统CoreOS初体验‘当流浪者(Vagrant)遇见码头工人(Docker)’系列 自我理解用boot2docker启动docker 容器一直会卡在 default: Syncing folders to the host VM... 看了下官方文档 Synced folder note: Vagrant will attempt to use the “best” synced folder implementation it can. For boot2docker, this is often rsync. In this case, make sure you have rsync installed on your host machine. Vagrant will give you a human-friendly error message if it is not. 这尿性是要安装一个rsync的同步软件 这鸟东西安装起来蛮麻烦的 而且基本用不到 所以不装了 毕竟就算是生产环境肯定用不到这个 linux版本 所以开发的时候还得装别的版本 以达到和生产环境同步 所以算了直接搞个 CoreOS 这个试试吧 这个挺新的比较有趣最后还是测试了rsync这个软件,因为使用CoreOS加载docker镜像 也会出现卡在同步文件夹那 所以看来问题不在boot2docker 得到升华我找到个方法 可以解决这个问题 但是并不是十全十美的方法就是屏蔽同步文件夹 12345678910111213Vagrant.configure(2) do |config| config.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;, disabled: true #这一句就是 config.vm.provider &quot;docker&quot; do |d| d.image = &quot;tknerr/baseimage-ubuntu:14.04&quot; d.has_ssh = true #这句是新加的 #d.vagrant_machine = &quot;dockerhost&quot; #d.vagrant_vagrantfile = &quot;../coreos/Vagrantfile&quot; #config.vm.box = &quot;coreos-stable&quot; end config.vm.provision &quot;shell&quot;, inline: &quot;echo &#x27;hello docker!&#x27;&quot;end 惊喜发现这个简直太省地方了: 利用boot2docker 加载 tknerr/baseimage-ubuntu:14.04 这个基础镜像 最后生成的虚拟机才有400M coreOS是900M多 而Homestead 已经是2.67G了 而且使用的box也非常省 boot2docker只有20M而已 目录说明C:\\Users\\elick.vagrant.d 这是vagrant的根目录 最主要有两个目录 boxes 这个是存放box的目录,所有你下载的各种box都在这里 data 这个是存放host的一些信息的地方 docker-host 这个就是用docker,而没有加载box的时候 自动下载的boot2docker machine-index 存着建立多少个host和host状态的信息 就是那个index 如果在virtualbox删除了host 这里还显示可以在这里手动删了 C:\\Users\\elick\\VirtualBox VMs 就是virtualbox存放虚拟机的位置","categories":[{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"},{"name":"vagrant","slug":"vagrant","permalink":"http://elickzhao.github.io/tags/vagrant/"}]}],"categories":[{"name":"测试","slug":"测试","permalink":"http://elickzhao.github.io/categories/%E6%B5%8B%E8%AF%95/"},{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"php开发","slug":"php开发","permalink":"http://elickzhao.github.io/categories/php%E5%BC%80%E5%8F%91/"},{"name":"服务器端","slug":"服务器端","permalink":"http://elickzhao.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://elickzhao.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"php","slug":"php","permalink":"http://elickzhao.github.io/tags/php/"},{"name":"小百科","slug":"小百科","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91/"},{"name":"前端","slug":"前端","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"http://elickzhao.github.io/tags/css/"},{"name":"IDE","slug":"IDE","permalink":"http://elickzhao.github.io/tags/IDE/"},{"name":"js","slug":"js","permalink":"http://elickzhao.github.io/tags/js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://elickzhao.github.io/tags/JavaScript/"},{"name":"Echarts","slug":"Echarts","permalink":"http://elickzhao.github.io/tags/Echarts/"},{"name":"小程序","slug":"小程序","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"mysql","slug":"mysql","permalink":"http://elickzhao.github.io/tags/mysql/"},{"name":"composer","slug":"composer","permalink":"http://elickzhao.github.io/tags/composer/"},{"name":"vue","slug":"vue","permalink":"http://elickzhao.github.io/tags/vue/"},{"name":"待读","slug":"待读","permalink":"http://elickzhao.github.io/tags/%E5%BE%85%E8%AF%BB/"},{"name":"node.js","slug":"node-js","permalink":"http://elickzhao.github.io/tags/node-js/"},{"name":"小百科,杂学","slug":"小百科-杂学","permalink":"http://elickzhao.github.io/tags/%E5%B0%8F%E7%99%BE%E7%A7%91-%E6%9D%82%E5%AD%A6/"},{"name":"mock","slug":"mock","permalink":"http://elickzhao.github.io/tags/mock/"},{"name":"npm","slug":"npm","permalink":"http://elickzhao.github.io/tags/npm/"},{"name":"Electron","slug":"Electron","permalink":"http://elickzhao.github.io/tags/Electron/"},{"name":"webpack","slug":"webpack","permalink":"http://elickzhao.github.io/tags/webpack/"},{"name":"服务器相关技术","slug":"服务器相关技术","permalink":"http://elickzhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"},{"name":"其他","slug":"其他","permalink":"http://elickzhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"草稿","slug":"草稿","permalink":"http://elickzhao.github.io/tags/%E8%8D%89%E7%A8%BF/"},{"name":"laravel","slug":"laravel","permalink":"http://elickzhao.github.io/tags/laravel/"},{"name":"杂学","slug":"杂学","permalink":"http://elickzhao.github.io/tags/%E6%9D%82%E5%AD%A6/"},{"name":"APP","slug":"APP","permalink":"http://elickzhao.github.io/tags/APP/"},{"name":"日志","slug":"日志","permalink":"http://elickzhao.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"玩机技巧","slug":"玩机技巧","permalink":"http://elickzhao.github.io/tags/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/"},{"name":"SSR","slug":"SSR","permalink":"http://elickzhao.github.io/tags/SSR/"},{"name":"App","slug":"App","permalink":"http://elickzhao.github.io/tags/App/"},{"name":"软件","slug":"软件","permalink":"http://elickzhao.github.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"chrome","slug":"chrome","permalink":"http://elickzhao.github.io/tags/chrome/"},{"name":"postman","slug":"postman","permalink":"http://elickzhao.github.io/tags/postman/"},{"name":"Git","slug":"Git","permalink":"http://elickzhao.github.io/tags/Git/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://elickzhao.github.io/tags/MongoDB/"},{"name":"sqlite","slug":"sqlite","permalink":"http://elickzhao.github.io/tags/sqlite/"},{"name":"NoSql","slug":"NoSql","permalink":"http://elickzhao.github.io/tags/NoSql/"},{"name":"hexo","slug":"hexo","permalink":"http://elickzhao.github.io/tags/hexo/"},{"name":"前端技术","slug":"前端技术","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"前台框架","slug":"前台框架","permalink":"http://elickzhao.github.io/tags/%E5%89%8D%E5%8F%B0%E6%A1%86%E6%9E%B6/"},{"name":"jquery","slug":"jquery","permalink":"http://elickzhao.github.io/tags/jquery/"},{"name":"easing","slug":"easing","permalink":"http://elickzhao.github.io/tags/easing/"},{"name":"atom","slug":"atom","permalink":"http://elickzhao.github.io/tags/atom/"},{"name":"nginx","slug":"nginx","permalink":"http://elickzhao.github.io/tags/nginx/"},{"name":"心情随笔","slug":"心情随笔","permalink":"http://elickzhao.github.io/tags/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"},{"name":"dingo","slug":"dingo","permalink":"http://elickzhao.github.io/tags/dingo/"},{"name":"laravel dingo","slug":"laravel-dingo","permalink":"http://elickzhao.github.io/tags/laravel-dingo/"},{"name":"laravel插件","slug":"laravel插件","permalink":"http://elickzhao.github.io/tags/laravel%E6%8F%92%E4%BB%B6/"},{"name":"linux","slug":"linux","permalink":"http://elickzhao.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://elickzhao.github.io/tags/ubuntu/"},{"name":"phpstudy","slug":"phpstudy","permalink":"http://elickzhao.github.io/tags/phpstudy/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"http://elickzhao.github.io/tags/VirtualBox/"},{"name":"phpstorm","slug":"phpstorm","permalink":"http://elickzhao.github.io/tags/phpstorm/"},{"name":"XSS","slug":"XSS","permalink":"http://elickzhao.github.io/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"http://elickzhao.github.io/tags/CSRF/"},{"name":"bower","slug":"bower","permalink":"http://elickzhao.github.io/tags/bower/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://elickzhao.github.io/tags/bootstrap/"},{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"http://elickzhao.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"},{"name":"gulp","slug":"gulp","permalink":"http://elickzhao.github.io/tags/gulp/"},{"name":"Emmet","slug":"Emmet","permalink":"http://elickzhao.github.io/tags/Emmet/"},{"name":"ide","slug":"ide","permalink":"http://elickzhao.github.io/tags/ide/"},{"name":"vagrant","slug":"vagrant","permalink":"http://elickzhao.github.io/tags/vagrant/"},{"name":"docker","slug":"docker","permalink":"http://elickzhao.github.io/tags/docker/"},{"name":"ssh","slug":"ssh","permalink":"http://elickzhao.github.io/tags/ssh/"}]}